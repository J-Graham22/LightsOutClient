// node_modules/@tresjs/core/dist/tres.js
import { Fragment as Fragment2, computed as computed3, createBlock, createCommentVNode, createElementBlock, createRenderer, defineComponent as defineComponent2, getCurrentInstance as getCurrentInstance3, h as h2, isRef as isRef4, mergeProps, normalizeClass, normalizeStyle, onMounted as onMounted3, onUnmounted as onUnmounted2, openBlock, provide as provide2, reactive as reactive3, readonly as readonly3, ref as ref3, renderSlot, shallowRef as shallowRef3, toValue as toValue2, unref as unref3, useSlots, watch as watch3, watchEffect as watchEffect3, withCtx } from "vue";
import * as THREE from "three";
import { ACESFilmicToneMapping, ArrowHelper, BackSide, BufferAttribute as BufferAttribute2, BufferGeometry, Clock, Color, DirectionalLightHelper, DoubleSide, Float32BufferAttribute, HemisphereLightHelper, Layers, Line, LineBasicMaterial, Material, MathUtils, Mesh as Mesh6, MeshBasicMaterial, Object3D as Object3D2, PCFSoftShadowMap, PerspectiveCamera, PointLightHelper, Scene, SpotLightHelper, Vector3 as Vector36, WebGLRenderer } from "three";

// node_modules/@vueuse/shared/index.mjs
import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, shallowReadonly, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from "vue";
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const clear = () => {
    fns.clear();
  };
  const on2 = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on: on2,
    off,
    trigger,
    clear
  };
}
var localProvidedStateMap = /* @__PURE__ */ new WeakMap();
var injectLocal = (...args) => {
  var _a25;
  const key = args[0];
  const instance = (_a25 = getCurrentInstance()) == null ? void 0 : _a25.proxy;
  if (instance == null && !hasInjectionContext())
    throw new Error("injectLocal must be called in setup");
  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))
    return localProvidedStateMap.get(instance)[key];
  return inject(...args);
};
function provideLocal(key, value) {
  var _a25;
  const instance = (_a25 = getCurrentInstance()) == null ? void 0 : _a25.proxy;
  if (instance == null)
    throw new Error("provideLocal must be called in setup");
  if (!localProvidedStateMap.has(instance))
    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));
  const localProvidedState = localProvidedStateMap.get(instance);
  localProvidedState[key] = value;
  return provide(key, value);
}
function createInjectionState(composable, options) {
  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || "InjectionState");
  const defaultValue = options == null ? void 0 : options.defaultValue;
  const useProvidingState = (...args) => {
    const state = composable(...args);
    provideLocal(key, state);
    return state;
  };
  const useInjectedState = () => injectLocal(key, defaultValue);
  return [useProvidingState, useInjectedState];
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a25, _b25;
  return isClient && ((_a25 = window == null ? void 0 : window.navigator) == null ? void 0 : _a25.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b25 = window == null ? void 0 : window.navigator) == null ? void 0 : _b25.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve2, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  let lastInvoker;
  const filter = (invoke) => {
    const duration = toValue$1(ms);
    const maxDuration = toValue$1(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = void 0;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve2, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve2;
      lastInvoker = invoke;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = void 0;
          resolve2(lastInvoker());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = void 0;
        resolve2(invoke());
      }, duration);
    });
  };
  return filter;
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve2, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve2, ms);
  });
}
function identity(arg) {
  return arg;
}
function pxValue(px) {
  return px.endsWith("rem") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function getLifeCycleTarget(target2) {
  return target2 || getCurrentInstance();
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function refDebounced(value, ms = 200, options = {}) {
  const debounced = ref(toValue$1(value));
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return shallowReadonly(debounced);
}
function tryOnMounted(fn, sync = true, target2) {
  const instance = getLifeCycleTarget(target2);
  if (instance)
    onMounted(fn, target2);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop = null;
    const watcher = new Promise((resolve2) => {
      stop = watch(
        r,
        (v) => {
          if (condition(v) !== isNot) {
            if (stop)
              stop();
            else
              nextTick(() => stop == null ? void 0 : stop());
            resolve2(v);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? void 0 : stop())
      );
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!isRef(value))
      return toMatch((v) => v === value, options);
    const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
    let stop = null;
    const watcher = new Promise((resolve2) => {
      stop = watch(
        [r, value],
        ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            if (stop)
              stop();
            else
              nextTick(() => stop == null ? void 0 : stop());
            resolve2(v1);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(
        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {
          stop == null ? void 0 : stop();
          return toValue$1(r);
        })
      );
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(toValue$1(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(toValue$1(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
function until(r) {
  return createUntil(r);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = shallowRef(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue$1(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    if (isActive.value)
      timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive: shallowReadonly(isActive),
    pause,
    resume
  };
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const isPending = shallowRef(false);
  let timer;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    if (immediateCallback)
      cb();
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = void 0;
      cb(...args);
    }, toValue$1(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending: shallowReadonly(isPending),
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(
    callback != null ? callback : noop,
    interval,
    options
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
function watchImmediate(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
function whenever(source, cb, options) {
  const stop = watch(
    source,
    (v, ov, onInvalidate) => {
      if (v) {
        if (options == null ? void 0 : options.once)
          nextTick(() => stop());
        cb(v, ov, onInvalidate);
      }
    },
    {
      ...options,
      once: false
    }
  );
  return stop;
}

// node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, shallowRef as shallowRef2, ref as ref2, watchEffect as watchEffect2, computed as computed2, inject as inject2, defineComponent, h, TransitionGroup, Fragment, shallowReactive, toValue, unref as unref2, getCurrentInstance as getCurrentInstance2, onMounted as onMounted2, watch as watch2, customRef as customRef2, onUpdated, readonly as readonly2, reactive as reactive2, hasInjectionContext as hasInjectionContext2, toRaw, shallowReadonly as shallowReadonly2, nextTick as nextTick2, markRaw, getCurrentScope as getCurrentScope2, isReadonly, onBeforeUpdate } from "vue";
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a25;
  const plain = toValue(elRef);
  return (_a25 = plain == null ? void 0 : plain.$el) != null ? _a25 : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed2(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a25, _b25;
      return [
        (_b25 = (_a25 = firstParamTargets.value) == null ? void 0 : _a25.map((e) => unrefElement(e))) != null ? _b25 : [defaultWindow].filter((e) => e != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref2(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
function useMounted() {
  const isMounted = shallowRef2(false);
  const instance = getCurrentInstance2();
  if (instance) {
    onMounted2(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed2(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once: once2 = false
  } = options;
  const isActive = shallowRef2(false);
  const intervalLimit = computed2(() => {
    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once2) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly2(isActive),
    pause,
    resume
  };
}
function useAsyncState(promise, initialState, options) {
  var _a25;
  const {
    immediate = true,
    delay = 0,
    onError = (_a25 = globalThis.reportError) != null ? _a25 : noop,
    onSuccess = noop,
    resetOnExecute = true,
    shallow = true,
    throwError
  } = options != null ? options : {};
  const state = shallow ? shallowRef2(initialState) : ref2(initialState);
  const isReady = shallowRef2(false);
  const isLoading = shallowRef2(false);
  const error = shallowRef2(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.value = toValue(initialState);
    error.value = void 0;
    isReady.value = false;
    isLoading.value = true;
    if (delay2 > 0)
      await promiseTimeout(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      state.value = data;
      isReady.value = true;
      onSuccess(data);
    } catch (e) {
      error.value = e;
      onError(e);
      if (throwError)
        throw e;
    } finally {
      isLoading.value = false;
    }
    return state.value;
  }
  if (immediate) {
    execute(delay);
  }
  const shell = {
    state,
    isReady,
    isLoading,
    error,
    execute,
    executeImmediate: (...args) => execute(0, ...args)
  };
  function waitUntilIsLoaded() {
    return new Promise((resolve2, reject) => {
      until(isLoading).toBe(false).then(() => resolve2(shell)).catch(reject);
    });
  }
  return {
    ...shell,
    then(onFulfilled, onRejected) {
      return waitUntilIsLoaded().then(onFulfilled, onRejected);
    }
  };
}
var ssrWidthSymbol = /* @__PURE__ */ Symbol("vueuse-ssr-width");
function useSSRWidth() {
  const ssrWidth = hasInjectionContext2() ? injectLocal(ssrWidthSymbol, null) : null;
  return typeof ssrWidth === "number" ? ssrWidth : void 0;
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow, ssrWidth = useSSRWidth() } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  const ssrSupport = shallowRef2(typeof ssrWidth === "number");
  const mediaQuery = shallowRef2();
  const matches = shallowRef2(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  watchEffect2(() => {
    if (ssrSupport.value) {
      ssrSupport.value = !isSupported.value;
      const queryStrings = toValue(query).split(",");
      matches.value = queryStrings.some((queryString) => {
        const not = queryString.includes("not all");
        const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let res = Boolean(minWidth || maxWidth);
        if (minWidth && res) {
          res = ssrWidth >= pxValue(minWidth[1]);
        }
        if (maxWidth && res) {
          res = ssrWidth <= pxValue(maxWidth[1]);
        }
        return not ? !res : res;
      });
      return;
    }
    if (!isSupported.value)
      return;
    mediaQuery.value = window2.matchMedia(toValue(query));
    matches.value = mediaQuery.value.matches;
  });
  useEventListener(mediaQuery, "change", handler, { passive: true });
  return computed2(() => matches.value);
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = shallowRef2(1);
  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);
  let stop = noop;
  if (window2) {
    stop = watchImmediate(query, () => pixelRatio.value = window2.devicePixelRatio);
  }
  return {
    pixelRatio: readonly2(pixelRatio),
    stop
  };
}
function useResizeObserver(target2, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed2(() => {
    const _targets = toValue(target2);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch2(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementSize(target2, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed2(() => {
    var _a25, _b25;
    return (_b25 = (_a25 = unrefElement(target2)) == null ? void 0 : _a25.namespaceURI) == null ? void 0 : _b25.includes("svg");
  });
  const width = shallowRef2(initialSize.width);
  const height = shallowRef2(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target2,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target2);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = toArray(boxSize);
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target2);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch2(
    () => unrefElement(target2),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useFps(options) {
  var _a25;
  const fps = shallowRef2(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a25 = options == null ? void 0 : options.every) != null ? _a25 : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
function useMemory(options = {}) {
  const memory = ref2();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true,
    type = "inner"
  } = options;
  const width = shallowRef2(initialWidth);
  const height = shallowRef2(initialHeight);
  const update2 = () => {
    if (window2) {
      if (type === "outer") {
        width.value = window2.outerWidth;
        height.value = window2.outerHeight;
      } else if (type === "visual" && window2.visualViewport) {
        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window2.visualViewport;
        width.value = Math.round(visualViewportWidth * scale);
        height.value = Math.round(visualViewportHeight * scale);
      } else if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update2();
  tryOnMounted(update2);
  const listenerOptions = { passive: true };
  useEventListener("resize", update2, listenerOptions);
  if (window2 && type === "visual" && window2.visualViewport) {
    useEventListener(window2.visualViewport, "resize", update2, listenerOptions);
  }
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch2(matches, () => update2());
  }
  return { width, height };
}

// node_modules/radashi/dist/radashi.js
var once = (() => {
  const onceSymbol = /* @__PURE__ */ Symbol();
  const once2 = (fn) => {
    const onceFn = function(...args) {
      if (onceFn[onceSymbol] === onceSymbol) {
        onceFn[onceSymbol] = fn.apply(this, args);
      }
      return onceFn[onceSymbol];
    };
    onceFn[onceSymbol] = onceSymbol;
    return onceFn;
  };
  once2.reset = (fn) => {
    fn[onceSymbol] = onceSymbol;
  };
  return once2;
})();
var AggregateErrorOrPolyfill = (() => globalThis.AggregateError ?? class AggregateError extends Error {
  constructor(errors = []) {
    var _a25, _b25;
    super();
    const name = ((_a25 = errors.find((e) => e.name)) == null ? void 0 : _a25.name) ?? "";
    this.name = `AggregateError(${name}...)`;
    this.message = `AggregateError with ${errors.length} errors`;
    this.stack = ((_b25 = errors.find((e) => e.stack)) == null ? void 0 : _b25.stack) ?? this.stack;
    this.errors = errors;
  }
})();
function camel(str) {
  var _a25;
  const parts = ((_a25 = str == null ? void 0 : str.replace(/([A-Z])+/g, capitalize)) == null ? void 0 : _a25.split(/(?=[A-Z])|[\.\-\s_]/).map((x) => x.toLowerCase())) ?? [];
  if (parts.length === 0) {
    return "";
  }
  if (parts.length === 1) {
    return parts[0];
  }
  return parts.reduce((acc, part) => {
    return `${acc}${part.charAt(0).toUpperCase()}${part.slice(1)}`;
  });
}
function capitalize(str) {
  if (!str || str.length === 0) {
    return "";
  }
  const lower = str.toLowerCase();
  return lower.substring(0, 1).toUpperCase() + lower.substring(1, lower.length);
}
function isEqual(x, y) {
  if (Object.is(x, y)) {
    return true;
  }
  if (x instanceof Date && y instanceof Date) {
    return x.getTime() === y.getTime();
  }
  if (x instanceof RegExp && y instanceof RegExp) {
    return x.toString() === y.toString();
  }
  if (typeof x !== "object" || x === null || typeof y !== "object" || y === null) {
    return false;
  }
  const keysX = Reflect.ownKeys(x);
  const keysY = Reflect.ownKeys(y);
  if (keysX.length !== keysY.length) {
    return false;
  }
  for (let i = 0; i < keysX.length; i++) {
    if (!Reflect.has(y, keysX[i])) {
      return false;
    }
    if (!isEqual(x[keysX[i]], y[keysX[i]])) {
      return false;
    }
  }
  return true;
}
function isFunction(value) {
  return typeof value === "function";
}
var isInt = (() => Number.isInteger)();
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isObject2(value) {
  return isTagged(value, "[object Object]");
}
function isString(value) {
  return typeof value === "string";
}
function isTagged(value, tag) {
  return Object.prototype.toString.call(value) === tag;
}
function isUndefined(value) {
  return typeof value === "undefined";
}

// node_modules/@pmndrs/pointer-events/dist/pointer.js
import { Object3D } from "three";

// node_modules/@pmndrs/pointer-events/dist/event.js
import { Ray, Vector2, Vector3 } from "three";

// node_modules/@pmndrs/pointer-events/dist/html-event.js
var HtmlEvent = class {
  nativeEvent;
  NONE = 0;
  CAPTURING_PHASE = 1;
  AT_TARGET = 2;
  BUBBLING_PHASE = 3;
  relatedTarget = null;
  get altKey() {
    return this.getFromNative("altKey", false);
  }
  get button() {
    return this.getFromNative("button", 0);
  }
  get buttons() {
    return this.getFromNative("buttons", 0);
  }
  get clientX() {
    return this.getFromNative("clientX", 0);
  }
  get clientY() {
    return this.getFromNative("clientY", 0);
  }
  get ctrlKey() {
    return this.getFromNative("ctrlKey", false);
  }
  get layerX() {
    return this.getFromNative("layerX", 0);
  }
  get layerY() {
    return this.getFromNative("layerY", 0);
  }
  get metaKey() {
    return this.getFromNative("metaKey", false);
  }
  get movementX() {
    return this.getFromNative("movementX", 0);
  }
  get movementY() {
    return this.getFromNative("movementY", 0);
  }
  get offsetX() {
    return this.getFromNative("offsetX", 0);
  }
  get offsetY() {
    return this.getFromNative("offsetY", 0);
  }
  get pageX() {
    return this.getFromNative("pageX", 0);
  }
  get pageY() {
    return this.getFromNative("pageY", 0);
  }
  get screenX() {
    return this.getFromNative("screenX", 0);
  }
  get screenY() {
    return this.getFromNative("screenY", 0);
  }
  get shiftKey() {
    return this.getFromNative("shiftKey", false);
  }
  get x() {
    return this.getFromNative("x", 0);
  }
  get y() {
    return this.getFromNative("y", 0);
  }
  get detail() {
    return this.getFromNative("detail", 0);
  }
  get view() {
    return this.getFromNative("view", null);
  }
  get which() {
    return this.getFromNative("which", 0);
  }
  get cancelBubble() {
    return this.getFromNative("cancelBubble", false);
  }
  get composed() {
    return this.getFromNative("composed", false);
  }
  get eventPhase() {
    return this.getFromNative("eventPhase", 0);
  }
  get isTrusted() {
    return this.getFromNative("isTrusted", false);
  }
  get returnValue() {
    return this.getFromNative("returnValue", false);
  }
  get timeStamp() {
    return this.getFromNative("timeStamp", 0);
  }
  get cancelable() {
    return this.getFromNative("cancelable", false);
  }
  get defaultPrevented() {
    return this.getFromNative("defaultPrevented", false);
  }
  constructor(nativeEvent) {
    this.nativeEvent = nativeEvent;
  }
  getFromNative(key, defaultValue) {
    if (key in this.nativeEvent) {
      return this.nativeEvent[key];
    }
    return defaultValue;
  }
};

// node_modules/@pmndrs/pointer-events/dist/event.js
var helperVector = new Vector3();
var PointerEvent = class _PointerEvent extends HtmlEvent {
  type;
  bubbles;
  internalPointer;
  intersection;
  camera;
  currentObject;
  object;
  propagationState;
  //--- pointer events data
  get pointerId() {
    return this.internalPointer.id;
  }
  get pointerType() {
    return this.internalPointer.type;
  }
  get pointerState() {
    return this.internalPointer.state;
  }
  //--- intersection data
  get distance() {
    return this.intersection.distance;
  }
  get distanceToRay() {
    return this.intersection.distanceToRay;
  }
  get point() {
    return this.intersection.point;
  }
  get index() {
    return this.intersection.index;
  }
  get face() {
    return this.intersection.face;
  }
  get faceIndex() {
    return this.intersection.faceIndex;
  }
  get uv() {
    return this.intersection.uv;
  }
  get uv1() {
    return this.intersection.uv1;
  }
  get normal() {
    return this.intersection.normal;
  }
  get instanceId() {
    return this.intersection.instanceId;
  }
  get pointOnLine() {
    return this.intersection.pointOnLine;
  }
  get batchId() {
    return this.intersection.batchId;
  }
  get pointerPosition() {
    return this.intersection.pointerPosition;
  }
  get pointerQuaternion() {
    return this.intersection.pointerQuaternion;
  }
  get pointOnFace() {
    return this.intersection.pointOnFace;
  }
  get localPoint() {
    return this.intersection.localPoint;
  }
  get details() {
    return this.intersection.details;
  }
  /** same as object */
  get target() {
    return this.object;
  }
  /** same as currentObject */
  get currentTarget() {
    return this.currentObject;
  }
  /** same as currentObject */
  get eventObject() {
    return this.currentObject;
  }
  /** same as object */
  get srcElement() {
    return this.currentObject;
  }
  _pointer;
  get pointer() {
    if (this._pointer == null) {
      helperVector.copy(this.intersection.point).project(this.camera);
      this._pointer = new Vector2(helperVector.x, helperVector.y);
    }
    return this._pointer;
  }
  _ray;
  get ray() {
    if (this._ray != null) {
      return this._ray;
    }
    switch (this.intersection.details.type) {
      case "screen-ray":
      case "ray":
      case "sphere":
        return this._ray = new Ray(this.intersection.pointerPosition, new Vector3(0, 0, -1).applyQuaternion(this.intersection.pointerQuaternion));
      case "lines":
        return this._ray = new Ray(this.intersection.details.line.start, this.intersection.details.line.end.clone().sub(this.intersection.details.line.start).normalize());
    }
  }
  _intersections = [];
  get intersections() {
    if (this._intersections == null) {
      this._intersections = [{ ...this.intersection, eventObject: this.currentObject }];
    }
    return this._intersections;
  }
  _unprojectedPoint;
  get unprojectedPoint() {
    if (this._unprojectedPoint == null) {
      const p = this.pointer;
      this._unprojectedPoint = new Vector3(p.x, p.y, 0).unproject(this.camera);
    }
    return this._unprojectedPoint;
  }
  get stopped() {
    return this.propagationState.stoppedImmediate || this.propagationState.stopped;
  }
  get stoppedImmediate() {
    return this.propagationState.stoppedImmediate;
  }
  get delta() {
    throw new Error(`not supported`);
  }
  constructor(type, bubbles, nativeEvent, internalPointer, intersection, camera, currentObject = intersection.object, object = currentObject, propagationState = {
    stopped: !bubbles,
    stoppedImmediate: false
  }) {
    super(nativeEvent);
    this.type = type;
    this.bubbles = bubbles;
    this.internalPointer = internalPointer;
    this.intersection = intersection;
    this.camera = camera;
    this.currentObject = currentObject;
    this.object = object;
    this.propagationState = propagationState;
  }
  stopPropagation() {
    this.propagationState.stopped = true;
  }
  stopImmediatePropagation() {
    this.propagationState.stoppedImmediate = true;
  }
  /**
   * for internal use
   */
  retarget(currentObject) {
    return new _PointerEvent(this.type, this.bubbles, this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target, this.propagationState);
  }
};
var WheelEvent = class _WheelEvent extends PointerEvent {
  get deltaX() {
    return this.nativeEvent.deltaX;
  }
  get deltaY() {
    return this.nativeEvent.deltaY;
  }
  get deltaZ() {
    return this.nativeEvent.deltaZ;
  }
  constructor(nativeEvent, pointer, intersection, camera, currentObject, object) {
    super("wheel", true, nativeEvent, pointer, intersection, camera, currentObject, object);
  }
  /**
   * for internal use
   */
  retarget(currentObject) {
    return new _WheelEvent(this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target);
  }
};
function emitPointerEvent(event) {
  emitPointerEventRec(event, event.currentObject);
}
function emitPointerEventRec(baseEvent, currentObject) {
  if (currentObject == null) {
    return;
  }
  const listeners = getObjectListeners(currentObject, baseEvent.type);
  if (listeners != null && listeners.length > 0) {
    const event = baseEvent.retarget(currentObject);
    const length = listeners.length;
    for (let i = 0; i < length && !event.stoppedImmediate; i++) {
      listeners[i](event);
    }
  }
  if (baseEvent.stopped) {
    return;
  }
  emitPointerEventRec(baseEvent, currentObject.parent);
}
var r3fEventToHandlerMap = {
  click: "onClick",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick",
  pointercancel: "onPointerCancel",
  pointerdown: "onPointerDown",
  pointerenter: "onPointerEnter",
  pointerleave: "onPointerLeave",
  pointermove: "onPointerMove",
  pointerout: "onPointerOut",
  pointerover: "onPointerOver",
  pointerup: "onPointerUp",
  wheel: "onWheel"
};
var listenerNames = Object.keys(r3fEventToHandlerMap);
function getObjectListeners(object, forEvent) {
  if (object._listeners != null && forEvent in object._listeners) {
    return object._listeners[forEvent];
  }
  let handler;
  if (object.isVoidObject && forEvent === "click" && object.parent?.__r3f != null) {
    handler = object.parent.__r3f.root.getState().onPointerMissed;
  }
  if (object.__r3f != null) {
    handler = object.__r3f.handlers[r3fEventToHandlerMap[forEvent]];
  }
  if (handler == null) {
    return void 0;
  }
  return [handler];
}

// node_modules/@pmndrs/pointer-events/dist/intersections/intersector.js
import { Mesh, SphereGeometry } from "three";
var VoidObjectRadius = 1e10;
var VoidObjectGeometry = new SphereGeometry(VoidObjectRadius);
var sceneVoidObjectMap = /* @__PURE__ */ new Map();
function getVoidObject(scene) {
  let entry = sceneVoidObjectMap.get(scene);
  if (entry == null) {
    entry = new Mesh(VoidObjectGeometry);
    entry.isVoidObject = true;
    entry.parent = scene;
    entry.pointerEventsOrder = -Infinity;
    sceneVoidObjectMap.set(scene, entry);
  }
  return entry;
}

// node_modules/@pmndrs/pointer-events/dist/intersections/utils.js
function computeIntersectionWorldPlane(target2, intersection, objectMatrixWorld) {
  const normal = intersection.normal ?? intersection.face?.normal;
  if (normal == null) {
    return false;
  }
  target2.setFromNormalAndCoplanarPoint(normal, intersection.localPoint);
  target2.applyMatrix4(objectMatrixWorld);
  return true;
}
function isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType) {
  if (pointerEvents === "none") {
    return false;
  }
  if (pointerEvents === "listener" && !hasListener) {
    return false;
  }
  if (pointerEventsType === "all") {
    return true;
  }
  if (typeof pointerEventsType === "function") {
    return ({ id, type, state }) => pointerEventsType(id, type, state);
  }
  let value;
  let invert;
  if ("deny" in pointerEventsType) {
    invert = true;
    value = pointerEventsType.deny;
  } else {
    invert = false;
    value = pointerEventsType.allow;
  }
  if (Array.isArray(value)) {
    return (pointer) => invertIf(value.includes(pointer.type), invert);
  }
  return (pointer) => invertIf(value === pointer.type, invert);
}
function invertIf(toInvert, ifIsTrue) {
  return ifIsTrue ? !toInvert : toInvert;
}
function intersectPointerEventTargets(type, object, pointers, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {
  const hasListener = parentHasListener || hasObjectListeners(type, object);
  const pointerEvents = object.pointerEvents ?? parentPointerEvents;
  const pointerEventsOrDefault = pointerEvents ?? object.defaultPointerEvents ?? "listener";
  const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType ?? "all";
  const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder ?? 0;
  const isAllowed = isPointerEventsAllowed(hasListener, pointerEventsOrDefault, pointerEventsType);
  const length = pointers.length;
  if (length === 1) {
    if (isAllowed === true || typeof isAllowed === "function" && isAllowed(pointers[0])) {
      filterAndInteresct(pointers[0], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);
    }
  } else if (isAllowed === true) {
    for (let i = 0; i < length; i++) {
      filterAndInteresct(pointers[i], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);
    }
  } else if (typeof isAllowed === "function") {
    for (let i = 0; i < length; i++) {
      const pointer = pointers[i];
      if (!isAllowed(pointer)) {
        continue;
      }
      filterAndInteresct(pointer, object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);
    }
  }
  if (object.children.length === 0 || object.intersectChildren === false) {
    return;
  }
  const descendants = object.interactableDescendants ?? object.children;
  const descendantsLength = descendants.length;
  for (let i = 0; i < descendantsLength; i++) {
    intersectPointerEventTargets(type, descendants[i], pointers, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);
  }
}
function hasObjectListeners(type, object) {
  if (object.ancestorsHaveListeners) {
    return true;
  }
  if (type === "pointer" && object.ancestorsHavePointerListeners) {
    return true;
  }
  if (type === "wheel" && object.ancestorsHaveWheelListeners) {
    return true;
  }
  if (object.__r3f != null && object.__r3f?.eventCount > 0) {
    if (type === "wheel" && object.__r3f["handlers"]["onWheel"] != null) {
      return true;
    }
    if (type === "pointer" && Object.keys(object.__r3f["handlers"]).some((key) => key != "onWheel")) {
      return true;
    }
  }
  if (object._listeners == null) {
    return false;
  }
  if (type === "wheel") {
    const wheelListeners = object._listeners.wheel;
    return wheelListeners != null && wheelListeners.length > 0;
  }
  const entries = Object.entries(object._listeners);
  const length = entries.length;
  for (let i = 0; i < length; i++) {
    const entry = entries[i];
    if (entry[0] === "wheel") {
      continue;
    }
    if (!listenerNames.includes(entry[0])) {
      continue;
    }
    if (entry[1] != null && entry[1].length > 0) {
      return true;
    }
  }
  return false;
}
function filterAndInteresct({ intersector, options }, object, pointerEvents, pointerEventsType, pointerEventsOrder) {
  if (options.filter?.(object, pointerEvents, pointerEventsType, pointerEventsOrder) === false) {
    return;
  }
  intersector.executeIntersection(object, pointerEventsOrder);
}
function getDominantIntersectionIndex(intersections, pointerEventsOrders, { customSort: compare = defaultSort } = {}, filter) {
  let intersection = void 0;
  let pointerEventsOrder = void 0;
  let index = void 0;
  const length = intersections.length;
  for (let i = 0; i < length; i++) {
    const newIntersection = intersections[i];
    if (filter?.(newIntersection) === false) {
      continue;
    }
    const newPointerEventsOrder = pointerEventsOrders?.[i];
    if (intersection == null || compare(newIntersection, newPointerEventsOrder, intersection, pointerEventsOrder) < 0) {
      index = i;
      intersection = newIntersection;
      pointerEventsOrder = newPointerEventsOrder;
    }
  }
  return index;
}
function defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {
  if (pointerEventsOrder1 != pointerEventsOrder2) {
    return pointerEventsOrder2 - pointerEventsOrder1;
  }
  return i1.distance - i2.distance;
}
var VoidObjectDistance = 1e7;
function voidObjectIntersectionFromRay(scene, ray, getDetails, pointerPosition, pointerQuaternion, addToDistance = 0) {
  const point = ray.direction.clone().multiplyScalar(VoidObjectDistance);
  const distanceOnRay = VoidObjectDistance;
  return {
    distance: distanceOnRay + addToDistance,
    object: getVoidObject(scene),
    point,
    normal: ray.origin.clone().sub(point).normalize(),
    details: getDetails(point, distanceOnRay),
    pointerPosition,
    pointerQuaternion,
    pointOnFace: point,
    localPoint: point
  };
}
function pushTimes(target2, value, times) {
  while (times > 0) {
    target2.push(value);
    --times;
  }
}

// node_modules/@pmndrs/pointer-events/dist/pointer.js
var buttonsDownTimeKey = /* @__PURE__ */ Symbol("buttonsDownTime");
var buttonsClickTimeKey = /* @__PURE__ */ Symbol("buttonsClickTime");
globalThis.pointerEventspointerMap ??= /* @__PURE__ */ new Map();
Object3D.prototype.setPointerCapture = function(pointerId) {
  getPointerById(pointerId)?.setCapture(this);
};
Object3D.prototype.releasePointerCapture = function(pointerId) {
  const pointer = getPointerById(pointerId);
  if (pointer == null || !pointer.hasCaptured(this)) {
    return;
  }
  pointer.setCapture(void 0);
};
Object3D.prototype.hasPointerCapture = function(pointerId) {
  return getPointerById(pointerId)?.hasCaptured(this) ?? false;
};
function getPointerById(pointerId) {
  return globalThis.pointerEventspointerMap?.get(pointerId);
}
var Pointer = class {
  id;
  type;
  state;
  intersector;
  getCamera;
  onMoveCommited;
  parentSetPointerCapture;
  parentReleasePointerCapture;
  options;
  //state
  prevIntersection;
  intersection;
  prevEnabled = true;
  enabled = true;
  wheelIntersection;
  //derived state
  /**
   * ordered leaf -> root (bottom -> top)
   */
  pointerEntered = [];
  pointerEnteredHelper = [];
  pointerCapture;
  buttonsDownTime = /* @__PURE__ */ new Map();
  buttonsDown = /* @__PURE__ */ new Set();
  //to handle interaction before first move (after exit)
  wasMoved = false;
  onFirstMove = [];
  constructor(id, type, state, intersector, getCamera, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {
    this.id = id;
    this.type = type;
    this.state = state;
    this.intersector = intersector;
    this.getCamera = getCamera;
    this.onMoveCommited = onMoveCommited;
    this.parentSetPointerCapture = parentSetPointerCapture;
    this.parentReleasePointerCapture = parentReleasePointerCapture;
    this.options = options;
    globalThis.pointerEventspointerMap?.set(id, this);
  }
  getPointerCapture() {
    return this.pointerCapture;
  }
  hasCaptured(object) {
    return this.pointerCapture?.object === object;
  }
  setCapture(object) {
    if (this.pointerCapture?.object === object) {
      return;
    }
    if (this.pointerCapture != null) {
      this.parentReleasePointerCapture?.();
      this.pointerCapture = void 0;
    }
    if (object != null && this.intersection != null) {
      this.pointerCapture = { object, intersection: this.intersection };
      this.parentSetPointerCapture?.();
    }
  }
  getButtonsDown() {
    return this.buttonsDown;
  }
  /**
   * @returns undefined if no intersection was executed yet
   */
  getIntersection() {
    return this.intersection;
  }
  getEnabled() {
    return this.enabled;
  }
  setEnabled(enabled, nativeEvent, commit = true) {
    if (this.enabled === enabled) {
      return;
    }
    if (!enabled && this.pointerCapture != null) {
      this.parentReleasePointerCapture?.();
      this.pointerCapture = void 0;
    }
    this.enabled = enabled;
    if (commit) {
      this.commit(nativeEvent, false);
    }
  }
  computeIntersection(type, scene, nativeEvent) {
    if (this.pointerCapture != null) {
      return this.intersector.intersectPointerCapture(this.pointerCapture, nativeEvent);
    }
    this.intersector.startIntersection(nativeEvent);
    intersectPointerEventTargets(type, scene, [this]);
    return this.intersector.finalizeIntersection(scene);
  }
  setIntersection(intersection) {
    this.intersection = intersection;
  }
  commit(nativeEvent, emitMove) {
    const camera = this.getCamera();
    const prevIntersection = this.prevEnabled ? this.prevIntersection : void 0;
    const intersection = this.enabled ? this.intersection : void 0;
    if (prevIntersection != null && prevIntersection.object != intersection?.object) {
      emitPointerEvent(new PointerEvent("pointerout", true, nativeEvent, this, prevIntersection, camera));
    }
    const pointerLeft = this.pointerEntered;
    this.pointerEntered = [];
    this.pointerEnteredHelper.length = 0;
    computeEnterLeave(intersection?.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);
    const length = pointerLeft.length;
    for (let i = 0; i < length; i++) {
      const object = pointerLeft[i];
      emitPointerEvent(new PointerEvent("pointerleave", false, nativeEvent, this, prevIntersection, camera, object));
    }
    if (intersection != null && prevIntersection?.object != intersection.object) {
      emitPointerEvent(new PointerEvent("pointerover", true, nativeEvent, this, intersection, camera));
    }
    for (let i = this.pointerEnteredHelper.length - 1; i >= 0; i--) {
      const object = this.pointerEnteredHelper[i];
      emitPointerEvent(new PointerEvent("pointerenter", false, nativeEvent, this, intersection, camera, object));
    }
    if (emitMove && intersection != null) {
      emitPointerEvent(new PointerEvent("pointermove", true, nativeEvent, this, intersection, camera));
    }
    this.prevIntersection = this.intersection;
    this.prevEnabled = this.enabled;
    if (!this.wasMoved && this.intersector.isReady()) {
      this.wasMoved = true;
      const length2 = this.onFirstMove.length;
      for (let i = 0; i < length2; i++) {
        this.onFirstMove[i](camera);
      }
      this.onFirstMove.length = 0;
    }
    this.onMoveCommited?.(this);
  }
  /**
   * computes and commits a move
   */
  move(scene, nativeEvent) {
    this.intersection = this.computeIntersection("pointer", scene, nativeEvent);
    this.commit(nativeEvent, true);
  }
  /**
   * computes and commits the pointer if a move has not yet occured
   */
  over(scene, nativeEvent) {
    if (!this.wasMoved) {
      this.intersection = this.computeIntersection("pointer", scene, nativeEvent);
      this.commit(nativeEvent, false);
    }
  }
  /**
   * emits a move without (re-)computing the intersection
   * just emitting a move event to the current intersection
   */
  emitMove(nativeEvent) {
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointermove", true, nativeEvent, this, this.intersection, this.getCamera()));
  }
  down(nativeEvent) {
    this.buttonsDown.add(nativeEvent.button);
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.down.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointerdown", true, nativeEvent, this, this.intersection, this.getCamera()));
    const { object } = this.intersection;
    object[buttonsDownTimeKey] ??= /* @__PURE__ */ new Map();
    object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);
    this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);
  }
  up(nativeEvent) {
    this.buttonsDown.delete(nativeEvent.button);
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.up.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    const { clickThesholdMs, contextMenuButton = 2, dblClickThresholdMs = 500, clickThresholdMs = clickThesholdMs ?? 300 } = this.options;
    this.pointerCapture = void 0;
    const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThresholdMs);
    const camera = this.getCamera();
    if (isClicked && nativeEvent.button === contextMenuButton) {
      emitPointerEvent(new PointerEvent("contextmenu", true, nativeEvent, this, this.intersection, camera));
    }
    emitPointerEvent(new PointerEvent("pointerup", true, nativeEvent, this, this.intersection, camera));
    if (!isClicked || nativeEvent.button === contextMenuButton) {
      return;
    }
    emitPointerEvent(new PointerEvent("click", true, nativeEvent, this, this.intersection, camera));
    const { object } = this.intersection;
    const buttonsClickTime = object[buttonsClickTimeKey] ??= /* @__PURE__ */ new Map();
    const buttonClickTime = buttonsClickTime.get(nativeEvent.button);
    if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {
      buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);
      return;
    }
    emitPointerEvent(new PointerEvent("dblclick", true, nativeEvent, this, this.intersection, camera));
    buttonsClickTime.delete(nativeEvent.button);
  }
  cancel(nativeEvent) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved) {
      this.onFirstMove.push(this.cancel.bind(this, nativeEvent));
      return;
    }
    if (this.intersection == null) {
      return;
    }
    emitPointerEvent(new PointerEvent("pointercancel", true, nativeEvent, this, this.intersection, this.getCamera()));
  }
  wheel(scene, nativeEvent, useMoveIntersection = false) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved && useMoveIntersection) {
      this.onFirstMove.push(this.wheel.bind(this, scene, nativeEvent, useMoveIntersection));
      return;
    }
    if (!useMoveIntersection) {
      this.wheelIntersection = this.computeIntersection("wheel", scene, nativeEvent);
    }
    const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;
    if (intersection == null) {
      return;
    }
    emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));
  }
  emitWheel(nativeEvent, useMoveIntersection = false) {
    if (!this.enabled) {
      return;
    }
    if (!this.wasMoved && useMoveIntersection) {
      this.onFirstMove.push(this.emitWheel.bind(this, nativeEvent, useMoveIntersection));
      return;
    }
    const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;
    if (intersection == null) {
      return;
    }
    emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));
  }
  exit(nativeEvent) {
    if (this.wasMoved) {
      if (this.pointerCapture != null) {
        this.parentReleasePointerCapture?.();
        this.pointerCapture = void 0;
      }
      this.intersection = void 0;
      this.commit(nativeEvent, false);
    }
    this.onFirstMove.length = 0;
    this.wasMoved = false;
  }
};
function computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {
  if (currentObject == null) {
    return;
  }
  const index = targeDiffRemovedAncestors.indexOf(currentObject);
  if (index != -1) {
    targeDiffRemovedAncestors.splice(index, 1);
  } else {
    targetDiffAddedAncestors.push(currentObject);
  }
  targetAllAncestors.push(currentObject);
  computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);
}
function getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThresholdMs) {
  if (objectButtonsDownTime == null) {
    return false;
  }
  const objectButtonPressTime = objectButtonsDownTime.get(button);
  if (objectButtonPressTime == null) {
    return false;
  }
  if (buttonUpTime - objectButtonPressTime > clickThresholdMs) {
    return false;
  }
  if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {
    return false;
  }
  return true;
}

// node_modules/@pmndrs/pointer-events/dist/intersections/lines.js
import { Line3, Matrix4 as Matrix42, Plane, Quaternion, Ray as Ray2, Raycaster, Vector3 as Vector33, Mesh as Mesh2, Vector2 as Vector23 } from "three";

// node_modules/@pmndrs/pointer-events/dist/utils.js
import { BufferAttribute, Matrix4, Triangle, Vector2 as Vector22, Vector3 as Vector32 } from "three";
var triangleHelper1 = new Triangle();
var triangleHelper2 = new Triangle();
var aVec2Helper = new Vector22();
var bVec2Helper = new Vector22();
var cVec2Helper = new Vector22();
var pointHelper = new Vector32();
var inverseMatrix = new Matrix4();
var localPointHelper = new Vector32();
function getClosestUV(target2, point, mesh) {
  localPointHelper.copy(point).applyMatrix4(inverseMatrix.copy(mesh.matrixWorld).invert());
  const uv = mesh.geometry.attributes.uv;
  if (uv == null || !(uv instanceof BufferAttribute)) {
    return false;
  }
  let clostestDistance;
  loopThroughTriangles(mesh, (i1, i2, i3) => {
    mesh.getVertexPosition(i1, triangleHelper1.a);
    mesh.getVertexPosition(i2, triangleHelper1.b);
    mesh.getVertexPosition(i3, triangleHelper1.c);
    const distance = triangleHelper1.closestPointToPoint(localPointHelper, pointHelper).distanceTo(localPointHelper);
    if (clostestDistance != null && distance >= clostestDistance) {
      return;
    }
    clostestDistance = distance;
    triangleHelper2.copy(triangleHelper1);
    aVec2Helper.fromBufferAttribute(uv, i1);
    bVec2Helper.fromBufferAttribute(uv, i2);
    cVec2Helper.fromBufferAttribute(uv, i3);
  });
  if (clostestDistance == null) {
    return false;
  }
  triangleHelper2.closestPointToPoint(localPointHelper, pointHelper);
  triangleHelper2.getInterpolation(pointHelper, aVec2Helper, bVec2Helper, cVec2Helper, target2);
  return true;
}
function loopThroughTriangles(mesh, fn) {
  const drawRange = mesh.geometry.drawRange;
  if (mesh.geometry.index != null) {
    const index = mesh.geometry.index;
    const start2 = Math.max(0, drawRange.start);
    const end2 = Math.min(index.count, drawRange.start + drawRange.count);
    for (let i = start2; i < end2; i += 3) {
      fn(index.getX(i), index.getX(i + 1), index.getX(i + 2));
    }
    return;
  }
  const position = mesh.geometry.attributes.position;
  if (position == null) {
    return;
  }
  const start = Math.max(0, drawRange.start);
  const end = Math.min(position.count, drawRange.start + drawRange.count);
  for (let i = start; i < end; i += 3) {
    fn(i, i + 1, i + 2);
  }
}

// node_modules/@pmndrs/pointer-events/dist/intersections/lines.js
var invertedMatrixHelper = new Matrix42();
var lineHelper = new Line3();
var scaleHelper = new Vector33();
var planeHelper = new Plane();
var rayHelper = new Ray2();
var point2Helper = new Vector23();
var defaultLinePoints = [new Vector33(0, 0, 0), new Vector33(0, 0, 1)];

// node_modules/@pmndrs/pointer-events/dist/intersections/ray.js
import { Matrix4 as Matrix43, Plane as Plane2, Quaternion as Quaternion2, Raycaster as Raycaster2, Vector3 as Vector34, Vector2 as Vector24, Mesh as Mesh3 } from "three";
var invertedMatrixHelper2 = new Matrix43();
var scaleHelper2 = new Vector34();
var NegZAxis = new Vector34(0, 0, -1);
var planeHelper2 = new Plane2();
var point2Helper2 = new Vector24();
var directionHelper = new Vector34();
var ScreenRayIntersector = class {
  prepareTransformation;
  options;
  raycaster = new Raycaster2();
  cameraQuaternion = new Quaternion2();
  fromPosition = new Vector34();
  fromQuaternion = new Quaternion2();
  coords = new Vector24();
  viewPlane = new Plane2();
  intersects = [];
  pointerEventsOrders = [];
  constructor(prepareTransformation, options) {
    this.prepareTransformation = prepareTransformation;
    this.options = options;
  }
  isReady() {
    return true;
  }
  intersectPointerCapture({ intersection, object }, nativeEvent) {
    const details = intersection.details;
    if (details.type != "screen-ray") {
      throw new Error(`unable to process a pointer capture of type "${intersection.details.type}" with a camera ray intersector`);
    }
    if (!this.startIntersection(nativeEvent)) {
      return intersection;
    }
    this.viewPlane.constant -= details.distanceViewPlane;
    const point = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector34());
    if (point == null) {
      return intersection;
    }
    intersection.object.updateWorldMatrix(true, false);
    computeIntersectionWorldPlane(this.viewPlane, intersection, intersection.object.matrixWorld);
    let uv = intersection.uv;
    if (intersection.object instanceof Mesh3 && getClosestUV(point2Helper2, point, intersection.object)) {
      uv = point2Helper2.clone();
    }
    return {
      ...intersection,
      details: {
        ...details,
        direction: this.raycaster.ray.direction.clone(),
        screenPoint: this.coords.clone()
      },
      uv,
      object,
      point,
      pointOnFace: point,
      pointerPosition: this.raycaster.ray.origin.clone(),
      pointerQuaternion: this.cameraQuaternion.clone()
    };
  }
  startIntersection(nativeEvent) {
    const from = this.prepareTransformation(nativeEvent, this.coords);
    if (from == null) {
      return false;
    }
    from.updateWorldMatrix(true, false);
    from.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper2);
    this.raycaster.setFromCamera(this.coords, from);
    this.viewPlane.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), this.raycaster.ray.origin);
    return true;
  }
  executeIntersection(object, objectPointerEventsOrder) {
    const start = this.intersects.length;
    object.raycast(this.raycaster, this.intersects);
    pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);
  }
  finalizeIntersection(scene) {
    const pointerPosition = this.fromPosition.clone();
    const pointerQuaternion = this.cameraQuaternion.clone();
    const pointerDirection = this.raycaster.ray.direction.clone();
    const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);
    const intersection = index == null ? void 0 : this.intersects[index];
    this.intersects.length = 0;
    this.pointerEventsOrders.length = 0;
    if (intersection == null) {
      return voidObjectIntersectionFromRay(scene, this.raycaster.ray, (_point, distance) => ({
        type: "screen-ray",
        distanceViewPlane: distance,
        screenPoint: this.coords.clone(),
        direction: pointerDirection
      }), pointerPosition, pointerQuaternion);
    }
    intersection.object.updateWorldMatrix(true, false);
    invertedMatrixHelper2.copy(intersection.object.matrixWorld).invert();
    return Object.assign(intersection, {
      details: {
        type: "screen-ray",
        distanceViewPlane: this.viewPlane.distanceToPoint(intersection.point),
        screenPoint: this.coords.clone(),
        direction: pointerDirection
      },
      pointOnFace: intersection.point,
      pointerPosition,
      pointerQuaternion,
      localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper2)
    });
  }
};

// node_modules/@pmndrs/pointer-events/dist/intersections/sphere.js
import { InstancedMesh, Matrix4 as Matrix44, Mesh as Mesh4, Vector3 as Vector35, Sphere, Quaternion as Quaternion3, Plane as Plane3, Vector2 as Vector25 } from "three";
var scaleHelper3 = new Vector35();
var point2Helper3 = new Vector25();
var matrixHelper = new Matrix44();
var oldInputDevicePointOffset = new Vector35();
var inputDeviceQuaternionOffset = new Quaternion3();
var planeHelper3 = new Plane3();
var helperSphere = new Sphere();
var vectorHelper = new Vector35();
var boxSizeHelper = new Vector35();
var boxCenterHelper = new Vector35();
var vec0_0001 = new Vector35(1e-4, 1e-4, 1e-4);
var invertedMatrixHelper3 = new Matrix44();

// node_modules/@pmndrs/pointer-events/dist/pointer/index.js
var pointerIdCounter = 23412;
function generateUniquePointerId() {
  return pointerIdCounter++;
}

// node_modules/@pmndrs/pointer-events/dist/forward.js
function htmlEventToCoords(element, e, target2) {
  if (!(e instanceof globalThis.MouseEvent)) {
    return target2.set(0, 0);
  }
  const { width, height, top, left } = element.getBoundingClientRect();
  const x = e.clientX - left;
  const y = e.clientY - top;
  return target2.set(x / width * 2 - 1, -(y / height) * 2 + 1);
}
function forwardHtmlEvents(fromElement, getCamera, scene, options) {
  return forwardEvents(
    fromElement,
    //backwards compatibility
    typeof getCamera === "function" ? getCamera : () => getCamera,
    scene,
    htmlEventToCoords.bind(null, fromElement),
    fromElement.setPointerCapture.bind(fromElement),
    (pointerId) => {
      if (fromElement.hasPointerCapture(pointerId)) {
        fromElement.releasePointerCapture(pointerId);
      }
    },
    {
      pointerTypePrefix: "screen-",
      ...options
    }
  );
}
function forwardEvents(from, getCamera, scene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {
  const forwardPointerCapture = options?.forwardPointerCapture ?? true;
  const pointerMap = /* @__PURE__ */ new Map();
  const pointerTypePrefix = options.pointerTypePrefix ?? "forward-";
  const getInnerPointer = (event, eventType) => {
    let innerPointer = pointerMap.get(event.pointerId);
    if (innerPointer != null) {
      return innerPointer;
    }
    innerPointer = new Pointer(generateUniquePointerId(), `${pointerTypePrefix}${event.pointerType}`, event.pointerState, new ScreenRayIntersector((nativeEvent, coords) => {
      toCoords(nativeEvent, coords);
      return getCamera();
    }, options), getCamera, void 0, forwardPointerCapture ? setPointerCapture.bind(null, event.pointerId) : void 0, forwardPointerCapture ? releasePointerCapture.bind(null, event.pointerId) : void 0, options);
    if (eventType != "move" && eventType != "wheel") {
      innerPointer.setIntersection(innerPointer.computeIntersection("pointer", scene, event));
      innerPointer.commit(event, false);
    }
    pointerMap.set(event.pointerId, innerPointer);
    return innerPointer;
  };
  const latestWheelEventMap = /* @__PURE__ */ new Map();
  const latestMoveEventMap = /* @__PURE__ */ new Map();
  const movedPointerList = [];
  const eventList = [];
  const emitEvent = (type, event, pointer) => {
    switch (type) {
      case "move":
        pointer.move(scene, event);
        return;
      case "over":
        pointer.move(scene, event);
        return;
      case "wheel":
        pointer.wheel(scene, event);
        return;
      case "cancel":
        pointer.cancel(event);
        return;
      case "down":
        if (!hasButton(event)) {
          return;
        }
        pointer.down(event);
        return;
      case "up":
        if (!hasButton(event)) {
          return;
        }
        pointer.up(event);
        return;
      case "exit":
        latestMoveEventMap.delete(pointer);
        latestWheelEventMap.delete(pointer);
        pointer.exit(event);
        return;
    }
  };
  const onEvent = (type, event) => {
    const pointer = getInnerPointer(event, type);
    if (type === "move") {
      latestMoveEventMap.set(pointer, event);
    }
    if (type === "wheel") {
      latestWheelEventMap.set(pointer, event);
    }
    if (options.batchEvents ?? true) {
      eventList.push({ type, event });
    } else {
      emitEvent(type, event, pointer);
    }
  };
  const pointerMoveListener = onEvent.bind(null, "move");
  const pointerOverListener = onEvent.bind(null, "over");
  const pointerCancelListener = onEvent.bind(null, "cancel");
  const pointerDownListener = onEvent.bind(null, "down");
  const pointerUpListener = onEvent.bind(null, "up");
  const wheelListener = onEvent.bind(null, "wheel");
  const pointerLeaveListener = onEvent.bind(null, "exit");
  from.addEventListener("pointermove", pointerMoveListener);
  from.addEventListener("pointerover", pointerOverListener);
  from.addEventListener("pointercancel", pointerCancelListener);
  from.addEventListener("pointerdown", pointerDownListener);
  from.addEventListener("pointerup", pointerUpListener);
  from.addEventListener("wheel", wheelListener);
  from.addEventListener("pointerleave", pointerLeaveListener);
  return {
    destroy() {
      from.removeEventListener("pointermove", pointerMoveListener);
      from.removeEventListener("pointerover", pointerOverListener);
      from.removeEventListener("pointercancel", pointerCancelListener);
      from.removeEventListener("pointerdown", pointerDownListener);
      from.removeEventListener("pointerup", pointerUpListener);
      from.removeEventListener("wheel", wheelListener);
      from.removeEventListener("pointerleave", pointerLeaveListener);
      latestMoveEventMap.clear();
      latestWheelEventMap.clear();
    },
    update() {
      const length = eventList.length;
      for (let i = 0; i < length; i++) {
        const { type, event } = eventList[i];
        const pointer = getInnerPointer(event, type);
        if (type === "move") {
          movedPointerList.push(pointer);
          if (latestMoveEventMap.get(pointer) != event) {
            pointer.emitMove(event);
            continue;
          }
        }
        if (type === "wheel" && latestWheelEventMap.get(pointer) != event) {
          pointer.emitWheel(event);
          continue;
        }
        emitEvent(type, event, pointer);
      }
      eventList.length = 0;
      if (options.intersectEveryFrame ?? false) {
        for (const [pointer, event] of latestMoveEventMap.entries()) {
          if (movedPointerList.includes(pointer)) {
            continue;
          }
          pointer.move(scene, event);
        }
      }
      movedPointerList.length = 0;
    }
  };
}
function hasButton(val) {
  return val.button != null;
}

// node_modules/@vue/devtools-shared/dist/index.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});
var require_rfdc = __commonJS({
  "../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = rfdc2;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc2(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys2 = Object.keys(a);
        const a2 = new Array(keys2.length);
        for (let i = 0; i < keys2.length; i++) {
          const k = keys2[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys2 = Object.keys(a);
        const a2 = new Array(keys2.length);
        for (let i = 0; i < keys2.length; i++) {
          const k = keys2[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});
init_esm_shims();
init_esm_shims();
init_esm_shims();
var isBrowser = typeof navigator !== "undefined";
var target = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : {};
var isInChromePanel = typeof target.chrome !== "undefined" && !!target.chrome.devtools;
var isInIframe = isBrowser && target.self !== target.top;
var _a;
var isInElectron = typeof navigator !== "undefined" && ((_a = navigator.userAgent) == null ? void 0 : _a.toLowerCase().includes("electron"));
var isNuxtApp = typeof window !== "undefined" && !!window.__NUXT__;
init_esm_shims();
var import_rfdc = __toESM(require_rfdc(), 1);
var classifyRE = /(?:^|[-_/])(\w)/g;
function toUpper(_, c) {
  return c ? c.toUpperCase() : "";
}
function classify(str) {
  return str && `${str}`.replace(classifyRE, toUpper);
}
function basename(filename, ext) {
  let normalizedFilename = filename.replace(/^[a-z]:/i, "").replace(/\\/g, "/");
  if (normalizedFilename.endsWith(`index${ext}`)) {
    normalizedFilename = normalizedFilename.replace(`/index${ext}`, ext);
  }
  const lastSlashIndex = normalizedFilename.lastIndexOf("/");
  const baseNameWithExt = normalizedFilename.substring(lastSlashIndex + 1);
  if (ext) {
    const extIndex = baseNameWithExt.lastIndexOf(ext);
    return baseNameWithExt.substring(0, extIndex);
  }
  return "";
}
var deepClone = (0, import_rfdc.default)({ circles: true });

// node_modules/perfect-debounce/dist/index.mjs
var DEBOUNCE_DEFAULTS = {
  trailing: true
};
function debounce(fn, wait = 25, options = {}) {
  options = { ...DEBOUNCE_DEFAULTS, ...options };
  if (!Number.isFinite(wait)) {
    throw new TypeError("Expected `wait` to be a finite number");
  }
  let leadingValue;
  let timeout;
  let resolveList = [];
  let currentPromise;
  let trailingArgs;
  const applyFn = (_this, args) => {
    currentPromise = _applyPromised(fn, _this, args);
    currentPromise.finally(() => {
      currentPromise = null;
      if (options.trailing && trailingArgs && !timeout) {
        const promise = applyFn(_this, trailingArgs);
        trailingArgs = null;
        return promise;
      }
    });
    return currentPromise;
  };
  return function(...args) {
    if (currentPromise) {
      if (options.trailing) {
        trailingArgs = args;
      }
      return currentPromise;
    }
    return new Promise((resolve2) => {
      const shouldCallNow = !timeout && options.leading;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const promise = options.leading ? leadingValue : applyFn(this, args);
        for (const _resolve of resolveList) {
          _resolve(promise);
        }
        resolveList = [];
      }, wait);
      if (shouldCallNow) {
        leadingValue = applyFn(this, args);
        resolve2(leadingValue);
      } else {
        resolveList.push(resolve2);
      }
    });
  };
}
async function _applyPromised(fn, _this, args) {
  return await fn.apply(_this, args);
}

// node_modules/hookable/dist/index.mjs
function flatHooks(configHooks, hooks2 = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks2, name);
    } else if (typeof subHook === "function") {
      hooks2[name] = subHook;
    }
  }
  return hooks2;
}
var defaultTask = { run: (function_) => function_() };
var _createTask = () => defaultTask;
var createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks2, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks2.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks2, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks2.map((hook2) => task.run(() => hook2(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}
var Hookable = class {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook2 of _hooks) {
      this.hook(name, hook2);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks2 = flatHooks(configHooks);
    const removeFns = Object.keys(hooks2).map(
      (key) => this.hook(key, hooks2[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks2 = flatHooks(configHooks);
    for (const key in hooks2) {
      this.removeHook(key, hooks2[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
};
function createHooks() {
  return new Hookable();
}

// node_modules/birpc/dist/index.mjs
var { clearTimeout: clearTimeout2, setTimeout: setTimeout2 } = globalThis;
var random = Math.random.bind(Math);

// node_modules/@vue/devtools-kit/dist/index.js
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __esm2 = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target22) => (target22 = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target22, "default", { value: mod, enumerable: true }) : target22,
  mod
));
var init_esm_shims2 = __esm2({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});
var require_speakingurl = __commonJS2({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/lib/speakingurl.js"(exports, module) {
    "use strict";
    init_esm_shims2();
    (function(root) {
      "use strict";
      var charMap = {
        // latin
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "Ae",
        "": "A",
        "": "AE",
        "": "C",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "D",
        "": "N",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "Oe",
        "": "O",
        "": "O",
        "": "U",
        "": "U",
        "": "U",
        "": "Ue",
        "": "U",
        "": "Y",
        "": "TH",
        "": "ss",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "ae",
        "": "a",
        "": "ae",
        "": "c",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "d",
        "": "n",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "oe",
        "": "o",
        "": "o",
        "": "u",
        "": "u",
        "": "u",
        "": "ue",
        "": "u",
        "": "y",
        "": "th",
        "": "y",
        "": "SS",
        // language specific
        // Arabic
        "": "a",
        "": "a",
        "": "i",
        "": "aa",
        "": "u",
        "": "e",
        "": "a",
        "": "b",
        "": "t",
        "": "th",
        "": "j",
        "": "h",
        "": "kh",
        "": "d",
        "": "th",
        "": "r",
        "": "z",
        "": "s",
        "": "sh",
        "": "s",
        "": "dh",
        "": "t",
        "": "z",
        "": "a",
        "": "gh",
        "": "f",
        "": "q",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "h",
        "": "w",
        "": "y",
        "": "a",
        "": "h",
        "": "la",
        "": "laa",
        "": "lai",
        "": "laa",
        // Persian additional characters than Arabic
        "": "g",
        "": "ch",
        "": "p",
        "": "zh",
        "": "k",
        "": "y",
        // Arabic diactrics
        "": "a",
        "": "an",
        "": "e",
        "": "en",
        "": "u",
        "": "on",
        "": "",
        // Arabic numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Persian numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // Burmese consonants
        "": "k",
        "": "kh",
        "": "g",
        "": "ga",
        "": "ng",
        "": "s",
        "": "sa",
        "": "z",
        "": "za",
        "": "ny",
        "": "t",
        "": "ta",
        "": "d",
        "": "da",
        "": "na",
        "": "t",
        "": "ta",
        "": "d",
        "": "da",
        "": "n",
        "": "p",
        "": "pa",
        "": "b",
        "": "ba",
        "": "m",
        "": "y",
        "": "ya",
        "": "l",
        "": "w",
        "": "th",
        "": "h",
        "": "la",
        "": "a",
        // consonant character combos
        "": "y",
        "": "ya",
        "": "w",
        "": "yw",
        "": "ywa",
        "": "h",
        // independent vowels
        "": "e",
        "": "-e",
        "": "i",
        "": "-i",
        "": "u",
        "": "-u",
        "": "aw",
        "": "aw",
        "": "aw",
        // numbers
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        // virama and tone marks which are silent in transliteration
        "": "",
        "": "",
        "": "",
        // Czech
        "": "c",
        "": "d",
        "": "e",
        "": "n",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "z",
        "": "C",
        "": "D",
        "": "E",
        "": "N",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "Z",
        // Dhivehi
        "": "h",
        "": "sh",
        "": "n",
        "": "r",
        "": "b",
        "": "lh",
        "": "k",
        "": "a",
        "": "v",
        "": "m",
        "": "f",
        "": "dh",
        "": "th",
        "": "l",
        "": "g",
        "": "gn",
        "": "s",
        "": "d",
        "": "z",
        "": "t",
        "": "y",
        "": "p",
        "": "j",
        "": "ch",
        "": "tt",
        "": "hh",
        "": "kh",
        "": "th",
        "": "z",
        "": "sh",
        "": "s",
        "": "d",
        "": "t",
        "": "z",
        "": "a",
        "": "gh",
        "": "q",
        "": "w",
        "": "a",
        "": "aa",
        "": "i",
        "": "ee",
        "": "u",
        "": "oo",
        "": "e",
        "": "ey",
        "": "o",
        "": "oa",
        "": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        "": "a",
        "": "b",
        "": "g",
        "": "d",
        "": "e",
        "": "v",
        "": "z",
        "": "t",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "zh",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "p",
        "": "k",
        "": "gh",
        "": "q",
        "": "sh",
        "": "ch",
        "": "ts",
        "": "dz",
        "": "ts",
        "": "ch",
        "": "kh",
        "": "j",
        "": "h",
        // Greek
        "": "a",
        "": "v",
        "": "g",
        "": "d",
        "": "e",
        "": "z",
        "": "i",
        "": "th",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "ks",
        "": "o",
        "": "p",
        "": "r",
        "": "s",
        "": "t",
        "": "y",
        "": "f",
        "": "x",
        "": "ps",
        "": "o",
        "": "a",
        "": "e",
        "": "i",
        "": "o",
        "": "y",
        "": "i",
        "": "o",
        "": "s",
        "": "i",
        "": "y",
        "": "y",
        "": "i",
        "": "A",
        "": "B",
        "": "G",
        "": "D",
        "": "E",
        "": "Z",
        "": "I",
        "": "TH",
        "": "I",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "KS",
        "": "O",
        "": "P",
        "": "R",
        "": "S",
        "": "T",
        "": "Y",
        "": "F",
        "": "X",
        "": "PS",
        "": "O",
        "": "A",
        "": "E",
        "": "I",
        "": "O",
        "": "Y",
        "": "I",
        "": "O",
        "": "I",
        "": "Y",
        // Latvian
        "": "a",
        // '': 'c', // duplicate
        "": "e",
        "": "g",
        "": "i",
        "": "k",
        "": "l",
        "": "n",
        // '': 's', // duplicate
        "": "u",
        // '': 'z', // duplicate
        "": "A",
        // '': 'C', // duplicate
        "": "E",
        "": "G",
        "": "I",
        "": "k",
        "": "L",
        "": "N",
        // '': 'S', // duplicate
        "": "U",
        // '': 'Z', // duplicate
        // Macedonian
        "": "Kj",
        "": "kj",
        "": "Lj",
        "": "lj",
        "": "Nj",
        "": "nj",
        "": "Ts",
        "": "ts",
        // Polish
        "": "a",
        "": "c",
        "": "e",
        "": "l",
        "": "n",
        // '': 'o', // duplicate
        "": "s",
        "": "z",
        "": "z",
        "": "A",
        "": "C",
        "": "E",
        "": "L",
        "": "N",
        "": "S",
        "": "Z",
        "": "Z",
        // Ukranian
        "": "Ye",
        "": "I",
        "": "Yi",
        "": "G",
        "": "ye",
        "": "i",
        "": "yi",
        "": "g",
        // Romanian
        "": "a",
        "": "A",
        "": "s",
        "": "S",
        // '': 's', // duplicate
        // '': 'S', // duplicate
        "": "t",
        "": "T",
        "": "t",
        "": "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        "": "a",
        "": "b",
        "": "v",
        "": "g",
        "": "d",
        "": "e",
        "": "yo",
        "": "zh",
        "": "z",
        "": "i",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "f",
        "": "kh",
        "": "c",
        "": "ch",
        "": "sh",
        "": "sh",
        "": "",
        "": "y",
        "": "",
        "": "e",
        "": "yu",
        "": "ya",
        "": "A",
        "": "B",
        "": "V",
        "": "G",
        "": "D",
        "": "E",
        "": "Yo",
        "": "Zh",
        "": "Z",
        "": "I",
        "": "I",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "F",
        "": "Kh",
        "": "C",
        "": "Ch",
        "": "Sh",
        "": "Sh",
        "": "",
        "": "Y",
        "": "",
        "": "E",
        "": "Yu",
        "": "Ya",
        // Serbian
        "": "dj",
        "": "j",
        // '': 'lj',  // duplicate
        // '': 'nj', // duplicate
        "": "c",
        "": "dz",
        "": "Dj",
        "": "j",
        // '': 'Lj', // duplicate
        // '': 'Nj', // duplicate
        "": "C",
        "": "Dz",
        // Slovak
        "": "l",
        "": "l",
        "": "r",
        "": "L",
        "": "L",
        "": "R",
        // Turkish
        "": "s",
        "": "S",
        "": "i",
        "": "I",
        // '': 'c', // duplicate
        // '': 'C', // duplicate
        // '': 'u', // duplicate, see langCharMap
        // '': 'U', // duplicate, see langCharMap
        // '': 'o', // duplicate, see langCharMap
        // '': 'O', // duplicate, see langCharMap
        "": "g",
        "": "G",
        // Vietnamese
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "d",
        "": "D",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "e",
        "": "E",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "O",
        "": "o",
        "": "o",
        "": "i",
        "": "I",
        "": "i",
        "": "I",
        "": "i",
        "": "i",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "U",
        "": "u",
        "": "",
        "": "y",
        "": "y",
        "": "y",
        "": "Y",
        "": "y",
        "": "Y",
        "": "y",
        "": "Y",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        // '': 'a', // duplicate
        // '': 'A', // duplicate
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "a",
        "": "A",
        "": "0",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "18",
        "": "18",
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "10",
        "": "0",
        "": "11",
        "": "12",
        "": "13",
        "": "14",
        "": "15",
        "": "16",
        "": "17",
        "": "18",
        "": "19",
        "": "20",
        "": "A",
        "": "B",
        "": "C",
        "": "D",
        "": "E",
        "": "F",
        "": "G",
        "": "H",
        "": "I",
        "": "J",
        "": "K",
        "": "L",
        "": "M",
        "": "N",
        "": "O",
        "": "P",
        "": "Q",
        "": "R",
        "": "S",
        "": "T",
        "": "U",
        "": "V",
        "": "W",
        "": "X",
        "": "Y",
        "": "Z",
        "": "a",
        "": "b",
        "": "c",
        "": "d",
        "": "e",
        "": "f",
        "": "g",
        "": "h",
        "": "i",
        "": "j",
        "": "k",
        "": "l",
        "": "m",
        "": "n",
        "": "o",
        "": "p",
        "": "q",
        "": "r",
        "": "s",
        "": "t",
        "": "u",
        "": "v",
        "": "w",
        "": "x",
        "": "y",
        "": "z",
        // symbols
        "": '"',
        "": '"',
        "": "'",
        "": "'",
        "": "d",
        "": "f",
        "": "(TM)",
        "": "(C)",
        "": "oe",
        "": "OE",
        "": "(R)",
        "": "+",
        "": "(SM)",
        "": "...",
        "": "o",
        "": "o",
        "": "a",
        "": "*",
        "": ",",
        "": ".",
        // currency
        "$": "USD",
        "": "EUR",
        "": "BRN",
        "": "FRF",
        "": "GBP",
        "": "ITL",
        "": "NGN",
        "": "ESP",
        "": "KRW",
        "": "ILS",
        "": "VND",
        "": "LAK",
        "": "MNT",
        "": "GRD",
        "": "ARS",
        "": "PYG",
        "": "ARA",
        "": "UAH",
        "": "GHS",
        "": "cent",
        "": "CNY",
        "": "CNY",
        "": "YEN",
        "": "IRR",
        "": "EWE",
        "": "THB",
        "": "INR",
        "": "INR",
        "": "PF",
        "": "TRY",
        "": "AFN",
        "": "AZN",
        "": "BGN",
        "": "KHR",
        "": "CRC",
        "": "KZT",
        "": "MKD",
        "z": "PLN",
        "": "RUB",
        "": "GEL"
      };
      var lookAheadCharArray = [
        // burmese
        "",
        // Dhivehi
        ""
      ];
      var diatricMap = {
        // Burmese
        // dependent vowels
        "": "a",
        "": "a",
        "": "e",
        "": "e",
        "": "i",
        "": "i",
        "": "o",
        "": "u",
        "": "u",
        "": "aung",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "aw",
        "": "",
        // this is special case but the character will be converted to latin in the code
        "": "et",
        "": "aik",
        "": "auk",
        "": "in",
        "": "aing",
        "": "aung",
        "": "it",
        "": "i",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "it",
        "": "d",
        "": "ok",
        "": "ait",
        "": "an",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "at",
        "": "eik",
        "": "ok",
        "": "ut",
        "": "nub",
        "": "an",
        "": "ein",
        "": "on",
        "": "un",
        "": "e",
        "": "ol",
        "": "in",
        "": "an",
        "": "ein",
        "": "on",
        // Dhivehi
        "": "ah",
        "": "ah"
      };
      var langCharMap = {
        "en": {},
        // default language
        "az": {
          // Azerbaijani
          "": "c",
          "": "e",
          "": "g",
          "": "i",
          "": "o",
          "": "s",
          "": "u",
          "": "C",
          "": "E",
          "": "G",
          "": "I",
          "": "O",
          "": "S",
          "": "U"
        },
        "cs": {
          // Czech
          "": "c",
          "": "d",
          "": "e",
          "": "n",
          "": "r",
          "": "s",
          "": "t",
          "": "u",
          "": "z",
          "": "C",
          "": "D",
          "": "E",
          "": "N",
          "": "R",
          "": "S",
          "": "T",
          "": "U",
          "": "Z"
        },
        "fi": {
          // Finnish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "a",
          // ok
          "": "A",
          // ok
          "": "o",
          // ok
          "": "O"
          // ok
        },
        "hu": {
          // Hungarian
          "": "a",
          // ok
          "": "A",
          // ok
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "o",
          // ok
          "": "O",
          // ok
          // '': 'o', duplicate see charMap/latin
          // '': 'O', duplicate see charMap/latin
          "": "u",
          "": "U",
          "": "u",
          "": "U"
        },
        "lt": {
          // Lithuanian
          "": "a",
          "": "c",
          "": "e",
          "": "e",
          "": "i",
          "": "s",
          "": "u",
          "": "u",
          "": "z",
          "": "A",
          "": "C",
          "": "E",
          "": "E",
          "": "I",
          "": "S",
          "": "U",
          "": "U"
        },
        "lv": {
          // Latvian
          "": "a",
          "": "c",
          "": "e",
          "": "g",
          "": "i",
          "": "k",
          "": "l",
          "": "n",
          "": "s",
          "": "u",
          "": "z",
          "": "A",
          "": "C",
          "": "E",
          "": "G",
          "": "i",
          "": "k",
          "": "L",
          "": "N",
          "": "S",
          "": "u",
          "": "Z"
        },
        "pl": {
          // Polish
          "": "a",
          "": "c",
          "": "e",
          "": "l",
          "": "n",
          "": "o",
          "": "s",
          "": "z",
          "": "z",
          "": "A",
          "": "C",
          "": "e",
          "": "L",
          "": "N",
          "": "O",
          "": "S",
          "": "Z",
          "": "Z"
        },
        "sv": {
          // Swedish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "": "a",
          // ok
          "": "A",
          // ok
          "": "o",
          // ok
          "": "O"
          // ok
        },
        "sk": {
          // Slovak
          "": "a",
          "": "A"
        },
        "sr": {
          // Serbian
          "": "lj",
          "": "nj",
          "": "Lj",
          "": "Nj",
          "": "dj",
          "": "Dj"
        },
        "tr": {
          // Turkish
          "": "U",
          "": "O",
          "": "u",
          "": "o"
        }
      };
      var symbolMap = {
        "ar": {
          "": "delta",
          "": "la-nihaya",
          "": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "": "majmou",
          "": "omla"
        },
        "az": {},
        "ca": {
          "": "delta",
          "": "infinit",
          "": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "": "suma dels",
          "": "moneda"
        },
        "cs": {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "": "soucet",
          "": "mena"
        },
        "de": {
          "": "delta",
          "": "unendlich",
          "": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "": "Summe von",
          "": "Waehrung"
        },
        "dv": {
          "": "delta",
          "": "kolunulaa",
          "": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "": "jumula",
          "": "faisaa"
        },
        "en": {
          "": "delta",
          "": "infinity",
          "": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "": "sum",
          "": "currency"
        },
        "es": {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "": "suma de los",
          "": "moneda"
        },
        "fa": {
          "": "delta",
          "": "bi-nahayat",
          "": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "": "majmooe",
          "": "vahed"
        },
        "fi": {
          "": "delta",
          "": "aarettomyys",
          "": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "": "summa",
          "": "valuutta"
        },
        "fr": {
          "": "delta",
          "": "infiniment",
          "": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "": "somme des",
          "": "monnaie"
        },
        "ge": {
          "": "delta",
          "": "usasruloba",
          "": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "": "jami",
          "": "valuta"
        },
        "gr": {},
        "hu": {
          "": "delta",
          "": "vegtelen",
          "": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "": "szumma",
          "": "penznem"
        },
        "it": {
          "": "delta",
          "": "infinito",
          "": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "": "somma",
          "": "moneta"
        },
        "lt": {
          "": "delta",
          "": "begalybe",
          "": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "": "suma",
          "": "valiuta"
        },
        "lv": {
          "": "delta",
          "": "bezgaliba",
          "": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "": "summa",
          "": "valuta"
        },
        "my": {
          "": "kwahkhyaet",
          "": "asaonasme",
          "": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "": "paungld",
          "": "ngwekye"
        },
        "mk": {},
        "nl": {
          "": "delta",
          "": "oneindig",
          "": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "": "som",
          "": "valuta"
        },
        "pl": {
          "": "delta",
          "": "nieskonczonosc",
          "": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "": "suma",
          "": "waluta"
        },
        "pt": {
          "": "delta",
          "": "infinito",
          "": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "": "soma",
          "": "moeda"
        },
        "ro": {
          "": "delta",
          "": "infinit",
          "": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "": "suma",
          "": "valuta"
        },
        "ru": {
          "": "delta",
          "": "beskonechno",
          "": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "": "summa",
          "": "valjuta"
        },
        "sk": {
          "": "delta",
          "": "nekonecno",
          "": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "": "sucet",
          "": "mena"
        },
        "sr": {},
        "tr": {
          "": "delta",
          "": "sonsuzluk",
          "": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "": "toplam",
          "": "para birimi"
        },
        "uk": {
          "": "delta",
          "": "bezkinechnist",
          "": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "": "suma",
          "": "valjuta"
        },
        "vn": {
          "": "delta",
          "": "vo cuc",
          "": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "": "tong",
          "": "tien te"
        }
      };
      var uricChars = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join("");
      var uricNoSlashChars = [";", "?", ":", "@", "&", "=", "+", "$", ","].join("");
      var markChars = [".", "!", "~", "*", "'", "(", ")"].join("");
      var getSlug = function getSlug2(input, opts) {
        var separator = "-";
        var result = "";
        var diatricString = "";
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = "";
        if (typeof input !== "string") {
          return "";
        }
        if (typeof opts === "string") {
          separator = opts;
        }
        symbol = symbolMap.en;
        langChar = langCharMap.en;
        if (typeof opts === "object") {
          maintainCase = opts.maintainCase || false;
          customReplacements = opts.custom && typeof opts.custom === "object" ? opts.custom : customReplacements;
          truncate = +opts.truncate > 1 && opts.truncate || false;
          uricFlag = opts.uric || false;
          uricNoSlashFlag = opts.uricNoSlash || false;
          markFlag = opts.mark || false;
          convertSymbols = opts.symbols === false || opts.lang === false ? false : true;
          separator = opts.separator || separator;
          if (uricFlag) {
            allowedChars += uricChars;
          }
          if (uricNoSlashFlag) {
            allowedChars += uricNoSlashChars;
          }
          if (markFlag) {
            allowedChars += markChars;
          }
          symbol = opts.lang && symbolMap[opts.lang] && convertSymbols ? symbolMap[opts.lang] : convertSymbols ? symbolMap.en : {};
          langChar = opts.lang && langCharMap[opts.lang] ? langCharMap[opts.lang] : opts.lang === false || opts.lang === true ? {} : langCharMap.en;
          if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {
            opts.titleCase.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
            titleCase = true;
          } else {
            titleCase = !!opts.titleCase;
          }
          if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {
            opts.custom.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
          }
          Object.keys(customReplacements).forEach(function(v) {
            var r;
            if (v.length > 1) {
              r = new RegExp("\\b" + escapeChars(v) + "\\b", "gi");
            } else {
              r = new RegExp(escapeChars(v), "gi");
            }
            input = input.replace(r, customReplacements[v]);
          });
          for (ch in customReplacements) {
            allowedChars += ch;
          }
        }
        allowedChars += separator;
        allowedChars = escapeChars(allowedChars);
        input = input.replace(/(^\s+|\s+$)/g, "");
        lastCharWasSymbol = false;
        lastCharWasDiatric = false;
        for (i = 0, l = input.length; i < l; i++) {
          ch = input[i];
          if (isReplacedCustomChar(ch, customReplacements)) {
            lastCharWasSymbol = false;
          } else if (langChar[ch]) {
            ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? " " + langChar[ch] : langChar[ch];
            lastCharWasSymbol = false;
          } else if (ch in charMap) {
            if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
              diatricString += ch;
              ch = "";
            } else if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + charMap[ch];
              diatricString = "";
            } else {
              ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? " " + charMap[ch] : charMap[ch];
            }
            lastCharWasSymbol = false;
            lastCharWasDiatric = false;
          } else if (ch in diatricMap) {
            diatricString += ch;
            ch = "";
            if (i === l - 1) {
              ch = diatricMap[diatricString];
            }
            lastCharWasDiatric = true;
          } else if (
            // process symbol chars
            symbol[ch] && !(uricFlag && uricChars.indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.indexOf(ch) !== -1)
          ) {
            ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
            ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : "";
            lastCharWasSymbol = true;
          } else {
            if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + ch;
              diatricString = "";
              lastCharWasDiatric = false;
            } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
              ch = " " + ch;
            }
            lastCharWasSymbol = false;
          }
          result += ch.replace(new RegExp("[^\\w\\s" + allowedChars + "_-]", "g"), separator);
        }
        if (titleCase) {
          result = result.replace(/(\w)(\S*)/g, function(_, i2, r) {
            var j = i2.toUpperCase() + (r !== null ? r : "");
            return Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0 ? j : j.toLowerCase();
          });
        }
        result = result.replace(/\s+/g, separator).replace(new RegExp("\\" + separator + "+", "g"), separator).replace(new RegExp("(^\\" + separator + "+|\\" + separator + "+$)", "g"), "");
        if (truncate && result.length > truncate) {
          lucky = result.charAt(truncate) === separator;
          result = result.slice(0, truncate);
          if (!lucky) {
            result = result.slice(0, result.lastIndexOf(separator));
          }
        }
        if (!maintainCase && !titleCase) {
          result = result.toLowerCase();
        }
        return result;
      };
      var createSlug = function createSlug2(opts) {
        return function getSlugWithConfig(input) {
          return getSlug(input, opts);
        };
      };
      var escapeChars = function escapeChars2(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      };
      var isReplacedCustomChar = function(ch, customReplacements) {
        for (var c in customReplacements) {
          if (customReplacements[c] === ch) {
            return true;
          }
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return getSlug;
        });
      } else {
        try {
          if (root.getSlug || root.createSlug) {
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          } else {
            root.getSlug = getSlug;
            root.createSlug = createSlug;
          }
        } catch (e) {
        }
      }
    })(exports);
  }
});
var require_speakingurl2 = __commonJS2({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/index.js"(exports, module) {
    "use strict";
    init_esm_shims2();
    module.exports = require_speakingurl();
  }
});
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
function getComponentTypeName(options) {
  var _a25;
  const name = options.name || options._componentTag || options.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ || options.__name;
  if (name === "index" && ((_a25 = options.__file) == null ? void 0 : _a25.endsWith("index.vue"))) {
    return "";
  }
  return name;
}
function getComponentFileName(options) {
  const file = options.__file;
  if (file)
    return classify(basename(file, ".vue"));
}
function saveComponentGussedName(instance, name) {
  instance.type.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ = name;
  return name;
}
function getAppRecord(instance) {
  if (instance.__VUE_DEVTOOLS_NEXT_APP_RECORD__)
    return instance.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
  else if (instance.root)
    return instance.appContext.app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
}
function isFragment(instance) {
  var _a25, _b25;
  const subTreeType = (_a25 = instance.subTree) == null ? void 0 : _a25.type;
  const appRecord = getAppRecord(instance);
  if (appRecord) {
    return ((_b25 = appRecord == null ? void 0 : appRecord.types) == null ? void 0 : _b25.Fragment) === subTreeType;
  }
  return false;
}
function getInstanceName(instance) {
  var _a25, _b25, _c;
  const name = getComponentTypeName((instance == null ? void 0 : instance.type) || {});
  if (name)
    return name;
  if ((instance == null ? void 0 : instance.root) === instance)
    return "Root";
  for (const key in (_b25 = (_a25 = instance.parent) == null ? void 0 : _a25.type) == null ? void 0 : _b25.components) {
    if (instance.parent.type.components[key] === (instance == null ? void 0 : instance.type))
      return saveComponentGussedName(instance, key);
  }
  for (const key in (_c = instance.appContext) == null ? void 0 : _c.components) {
    if (instance.appContext.components[key] === (instance == null ? void 0 : instance.type))
      return saveComponentGussedName(instance, key);
  }
  const fileName = getComponentFileName((instance == null ? void 0 : instance.type) || {});
  if (fileName)
    return fileName;
  return "Anonymous Component";
}
function getUniqueComponentId(instance) {
  var _a25, _b25, _c;
  const appId = (_c = (_b25 = (_a25 = instance == null ? void 0 : instance.appContext) == null ? void 0 : _a25.app) == null ? void 0 : _b25.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__) != null ? _c : 0;
  const instanceId = instance === (instance == null ? void 0 : instance.root) ? "root" : instance.uid;
  return `${appId}:${instanceId}`;
}
function getComponentInstance(appRecord, instanceId) {
  instanceId = instanceId || `${appRecord.id}:root`;
  const instance = appRecord.instanceMap.get(instanceId);
  return instance || appRecord.instanceMap.get(":root");
}
function createRect() {
  const rect = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    get width() {
      return rect.right - rect.left;
    },
    get height() {
      return rect.bottom - rect.top;
    }
  };
  return rect;
}
var range;
function getTextRect(node) {
  if (!range)
    range = document.createRange();
  range.selectNode(node);
  return range.getBoundingClientRect();
}
function getFragmentRect(vnode) {
  const rect = createRect();
  if (!vnode.children)
    return rect;
  for (let i = 0, l = vnode.children.length; i < l; i++) {
    const childVnode = vnode.children[i];
    let childRect;
    if (childVnode.component) {
      childRect = getComponentBoundingRect(childVnode.component);
    } else if (childVnode.el) {
      const el = childVnode.el;
      if (el.nodeType === 1 || el.getBoundingClientRect)
        childRect = el.getBoundingClientRect();
      else if (el.nodeType === 3 && el.data.trim())
        childRect = getTextRect(el);
    }
    if (childRect)
      mergeRects(rect, childRect);
  }
  return rect;
}
function mergeRects(a, b) {
  if (!a.top || b.top < a.top)
    a.top = b.top;
  if (!a.bottom || b.bottom > a.bottom)
    a.bottom = b.bottom;
  if (!a.left || b.left < a.left)
    a.left = b.left;
  if (!a.right || b.right > a.right)
    a.right = b.right;
  return a;
}
var DEFAULT_RECT = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: 0,
  height: 0
};
function getComponentBoundingRect(instance) {
  const el = instance.subTree.el;
  if (typeof window === "undefined") {
    return DEFAULT_RECT;
  }
  if (isFragment(instance))
    return getFragmentRect(instance.subTree);
  else if ((el == null ? void 0 : el.nodeType) === 1)
    return el == null ? void 0 : el.getBoundingClientRect();
  else if (instance.subTree.component)
    return getComponentBoundingRect(instance.subTree.component);
  else
    return DEFAULT_RECT;
}
init_esm_shims2();
function getRootElementsFromComponentInstance(instance) {
  if (isFragment(instance))
    return getFragmentRootElements(instance.subTree);
  if (!instance.subTree)
    return [];
  return [instance.subTree.el];
}
function getFragmentRootElements(vnode) {
  if (!vnode.children)
    return [];
  const list = [];
  vnode.children.forEach((childVnode) => {
    if (childVnode.component)
      list.push(...getRootElementsFromComponentInstance(childVnode.component));
    else if (childVnode == null ? void 0 : childVnode.el)
      list.push(childVnode.el);
  });
  return list;
}
var CONTAINER_ELEMENT_ID = "__vue-devtools-component-inspector__";
var CARD_ELEMENT_ID = "__vue-devtools-component-inspector__card__";
var COMPONENT_NAME_ELEMENT_ID = "__vue-devtools-component-inspector__name__";
var INDICATOR_ELEMENT_ID = "__vue-devtools-component-inspector__indicator__";
var containerStyles = {
  display: "block",
  zIndex: 2147483640,
  position: "fixed",
  backgroundColor: "#42b88325",
  border: "1px solid #42b88350",
  borderRadius: "5px",
  transition: "all 0.1s ease-in",
  pointerEvents: "none"
};
var cardStyles = {
  fontFamily: "Arial, Helvetica, sans-serif",
  padding: "5px 8px",
  borderRadius: "4px",
  textAlign: "left",
  position: "absolute",
  left: 0,
  color: "#e9e9e9",
  fontSize: "14px",
  fontWeight: 600,
  lineHeight: "24px",
  backgroundColor: "#42b883",
  boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
};
var indicatorStyles = {
  display: "inline-block",
  fontWeight: 400,
  fontStyle: "normal",
  fontSize: "12px",
  opacity: 0.7
};
function getContainerElement() {
  return document.getElementById(CONTAINER_ELEMENT_ID);
}
function getCardElement() {
  return document.getElementById(CARD_ELEMENT_ID);
}
function getIndicatorElement() {
  return document.getElementById(INDICATOR_ELEMENT_ID);
}
function getNameElement() {
  return document.getElementById(COMPONENT_NAME_ELEMENT_ID);
}
function getStyles(bounds) {
  return {
    left: `${Math.round(bounds.left * 100) / 100}px`,
    top: `${Math.round(bounds.top * 100) / 100}px`,
    width: `${Math.round(bounds.width * 100) / 100}px`,
    height: `${Math.round(bounds.height * 100) / 100}px`
  };
}
function create(options) {
  var _a25;
  const containerEl = document.createElement("div");
  containerEl.id = (_a25 = options.elementId) != null ? _a25 : CONTAINER_ELEMENT_ID;
  Object.assign(containerEl.style, {
    ...containerStyles,
    ...getStyles(options.bounds),
    ...options.style
  });
  const cardEl = document.createElement("span");
  cardEl.id = CARD_ELEMENT_ID;
  Object.assign(cardEl.style, {
    ...cardStyles,
    top: options.bounds.top < 35 ? 0 : "-35px"
  });
  const nameEl = document.createElement("span");
  nameEl.id = COMPONENT_NAME_ELEMENT_ID;
  nameEl.innerHTML = `&lt;${options.name}&gt;&nbsp;&nbsp;`;
  const indicatorEl = document.createElement("i");
  indicatorEl.id = INDICATOR_ELEMENT_ID;
  indicatorEl.innerHTML = `${Math.round(options.bounds.width * 100) / 100} x ${Math.round(options.bounds.height * 100) / 100}`;
  Object.assign(indicatorEl.style, indicatorStyles);
  cardEl.appendChild(nameEl);
  cardEl.appendChild(indicatorEl);
  containerEl.appendChild(cardEl);
  document.body.appendChild(containerEl);
  return containerEl;
}
function update(options) {
  const containerEl = getContainerElement();
  const cardEl = getCardElement();
  const nameEl = getNameElement();
  const indicatorEl = getIndicatorElement();
  if (containerEl) {
    Object.assign(containerEl.style, {
      ...containerStyles,
      ...getStyles(options.bounds)
    });
    Object.assign(cardEl.style, {
      top: options.bounds.top < 35 ? 0 : "-35px"
    });
    nameEl.innerHTML = `&lt;${options.name}&gt;&nbsp;&nbsp;`;
    indicatorEl.innerHTML = `${Math.round(options.bounds.width * 100) / 100} x ${Math.round(options.bounds.height * 100) / 100}`;
  }
}
function highlight(instance) {
  const bounds = getComponentBoundingRect(instance);
  if (!bounds.width && !bounds.height)
    return;
  const name = getInstanceName(instance);
  const container = getContainerElement();
  container ? update({ bounds, name }) : create({ bounds, name });
}
function unhighlight() {
  const el = getContainerElement();
  if (el)
    el.style.display = "none";
}
var inspectInstance = null;
function inspectFn(e) {
  const target22 = e.target;
  if (target22) {
    const instance = target22.__vueParentComponent;
    if (instance) {
      inspectInstance = instance;
      const el = instance.vnode.el;
      if (el) {
        const bounds = getComponentBoundingRect(instance);
        const name = getInstanceName(instance);
        const container = getContainerElement();
        container ? update({ bounds, name }) : create({ bounds, name });
      }
    }
  }
}
function selectComponentFn(e, cb) {
  e.preventDefault();
  e.stopPropagation();
  if (inspectInstance) {
    const uniqueComponentId = getUniqueComponentId(inspectInstance);
    cb(uniqueComponentId);
  }
}
var inspectComponentHighLighterSelectFn = null;
function cancelInspectComponentHighLighter() {
  unhighlight();
  window.removeEventListener("mouseover", inspectFn);
  window.removeEventListener("click", inspectComponentHighLighterSelectFn, true);
  inspectComponentHighLighterSelectFn = null;
}
function inspectComponentHighLighter() {
  window.addEventListener("mouseover", inspectFn);
  return new Promise((resolve2) => {
    function onSelect(e) {
      e.preventDefault();
      e.stopPropagation();
      selectComponentFn(e, (id) => {
        window.removeEventListener("click", onSelect, true);
        inspectComponentHighLighterSelectFn = null;
        window.removeEventListener("mouseover", inspectFn);
        const el = getContainerElement();
        if (el)
          el.style.display = "none";
        resolve2(JSON.stringify({ id }));
      });
    }
    inspectComponentHighLighterSelectFn = onSelect;
    window.addEventListener("click", onSelect, true);
  });
}
function scrollToComponent(options) {
  const instance = getComponentInstance(activeAppRecord.value, options.id);
  if (instance) {
    const [el] = getRootElementsFromComponentInstance(instance);
    if (typeof el.scrollIntoView === "function") {
      el.scrollIntoView({
        behavior: "smooth"
      });
    } else {
      const bounds = getComponentBoundingRect(instance);
      const scrollTarget = document.createElement("div");
      const styles = {
        ...getStyles(bounds),
        position: "absolute"
      };
      Object.assign(scrollTarget.style, styles);
      document.body.appendChild(scrollTarget);
      scrollTarget.scrollIntoView({
        behavior: "smooth"
      });
      setTimeout(() => {
        document.body.removeChild(scrollTarget);
      }, 2e3);
    }
    setTimeout(() => {
      const bounds = getComponentBoundingRect(instance);
      if (bounds.width || bounds.height) {
        const name = getInstanceName(instance);
        const el2 = getContainerElement();
        el2 ? update({ ...options, name, bounds }) : create({ ...options, name, bounds });
        setTimeout(() => {
          if (el2)
            el2.style.display = "none";
        }, 1500);
      }
    }, 1200);
  }
}
init_esm_shims2();
var _a2;
var _b;
(_b = (_a2 = target).__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__) != null ? _b : _a2.__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__ = true;
function waitForInspectorInit(cb) {
  let total = 0;
  const timer = setInterval(() => {
    if (target.__VUE_INSPECTOR__) {
      clearInterval(timer);
      total += 30;
      cb();
    }
    if (total >= /* 5s */
    5e3)
      clearInterval(timer);
  }, 30);
}
function setupInspector() {
  const inspector = target.__VUE_INSPECTOR__;
  const _openInEditor = inspector.openInEditor;
  inspector.openInEditor = async (...params) => {
    inspector.disable();
    _openInEditor(...params);
  };
}
function getComponentInspector() {
  return new Promise((resolve2) => {
    function setup() {
      setupInspector();
      resolve2(target.__VUE_INSPECTOR__);
    }
    if (!target.__VUE_INSPECTOR__) {
      waitForInspectorInit(() => {
        setup();
      });
    } else {
      setup();
    }
  });
}
init_esm_shims2();
init_esm_shims2();
function isReadonly2(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* IS_READONLY */
  ]);
}
function isReactive2(value) {
  if (isReadonly2(value)) {
    return isReactive2(value[
      "__v_raw"
      /* RAW */
    ]);
  }
  return !!(value && value[
    "__v_isReactive"
    /* IS_REACTIVE */
  ]);
}
function isRef3(r) {
  return !!(r && r.__v_isRef === true);
}
function toRaw2(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* RAW */
  ];
  return raw ? toRaw2(raw) : observed;
}
var StateEditor = class {
  constructor() {
    this.refEditor = new RefStateEditor();
  }
  set(object, path, value, cb) {
    const sections = Array.isArray(path) ? path : path.split(".");
    const markRef = false;
    while (sections.length > 1) {
      const section = sections.shift();
      if (object instanceof Map)
        object = object.get(section);
      else if (object instanceof Set)
        object = Array.from(object.values())[section];
      else object = object[section];
      if (this.refEditor.isRef(object))
        object = this.refEditor.get(object);
    }
    const field = sections[0];
    const item = this.refEditor.get(object)[field];
    if (cb) {
      cb(object, field, value);
    } else {
      if (this.refEditor.isRef(item))
        this.refEditor.set(item, value);
      else if (markRef)
        object[field] = value;
      else
        object[field] = value;
    }
  }
  get(object, path) {
    const sections = Array.isArray(path) ? path : path.split(".");
    for (let i = 0; i < sections.length; i++) {
      if (object instanceof Map)
        object = object.get(sections[i]);
      else
        object = object[sections[i]];
      if (this.refEditor.isRef(object))
        object = this.refEditor.get(object);
      if (!object)
        return void 0;
    }
    return object;
  }
  has(object, path, parent = false) {
    if (typeof object === "undefined")
      return false;
    const sections = Array.isArray(path) ? path.slice() : path.split(".");
    const size = !parent ? 1 : 2;
    while (object && sections.length > size) {
      const section = sections.shift();
      object = object[section];
      if (this.refEditor.isRef(object))
        object = this.refEditor.get(object);
    }
    return object != null && Object.prototype.hasOwnProperty.call(object, sections[0]);
  }
  createDefaultSetCallback(state) {
    return (object, field, value) => {
      if (state.remove || state.newKey) {
        if (Array.isArray(object))
          object.splice(field, 1);
        else if (toRaw2(object) instanceof Map)
          object.delete(field);
        else if (toRaw2(object) instanceof Set)
          object.delete(Array.from(object.values())[field]);
        else Reflect.deleteProperty(object, field);
      }
      if (!state.remove) {
        const target22 = object[state.newKey || field];
        if (this.refEditor.isRef(target22))
          this.refEditor.set(target22, value);
        else if (toRaw2(object) instanceof Map)
          object.set(state.newKey || field, value);
        else if (toRaw2(object) instanceof Set)
          object.add(value);
        else
          object[state.newKey || field] = value;
      }
    };
  }
};
var RefStateEditor = class {
  set(ref4, value) {
    if (isRef3(ref4)) {
      ref4.value = value;
    } else {
      if (ref4 instanceof Set && Array.isArray(value)) {
        ref4.clear();
        value.forEach((v) => ref4.add(v));
        return;
      }
      const currentKeys = Object.keys(value);
      if (ref4 instanceof Map) {
        const previousKeysSet2 = new Set(ref4.keys());
        currentKeys.forEach((key) => {
          ref4.set(key, Reflect.get(value, key));
          previousKeysSet2.delete(key);
        });
        previousKeysSet2.forEach((key) => ref4.delete(key));
        return;
      }
      const previousKeysSet = new Set(Object.keys(ref4));
      currentKeys.forEach((key) => {
        Reflect.set(ref4, key, Reflect.get(value, key));
        previousKeysSet.delete(key);
      });
      previousKeysSet.forEach((key) => Reflect.deleteProperty(ref4, key));
    }
  }
  get(ref4) {
    return isRef3(ref4) ? ref4.value : ref4;
  }
  isRef(ref4) {
    return isRef3(ref4) || isReactive2(ref4);
  }
};
var stateEditor = new StateEditor();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var TIMELINE_LAYERS_STATE_STORAGE_ID = "__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS_STATE__";
function getTimelineLayersStateFromStorage() {
  if (typeof window === "undefined" || !isBrowser || typeof localStorage === "undefined" || localStorage === null) {
    return {
      recordingState: false,
      mouseEventEnabled: false,
      keyboardEventEnabled: false,
      componentEventEnabled: false,
      performanceEventEnabled: false,
      selected: ""
    };
  }
  const state = typeof localStorage.getItem !== "undefined" ? localStorage.getItem(TIMELINE_LAYERS_STATE_STORAGE_ID) : null;
  return state ? JSON.parse(state) : {
    recordingState: false,
    mouseEventEnabled: false,
    keyboardEventEnabled: false,
    componentEventEnabled: false,
    performanceEventEnabled: false,
    selected: ""
  };
}
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var _a22;
var _b2;
(_b2 = (_a22 = target).__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS) != null ? _b2 : _a22.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS = [];
var devtoolsTimelineLayers = new Proxy(target.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS, {
  get(target22, prop, receiver) {
    return Reflect.get(target22, prop, receiver);
  }
});
function addTimelineLayer(options, descriptor) {
  devtoolsState.timelineLayersState[descriptor.id] = false;
  devtoolsTimelineLayers.push({
    ...options,
    descriptorId: descriptor.id,
    appRecord: getAppRecord(descriptor.app)
  });
}
var _a3;
var _b3;
(_b3 = (_a3 = target).__VUE_DEVTOOLS_KIT_INSPECTOR__) != null ? _b3 : _a3.__VUE_DEVTOOLS_KIT_INSPECTOR__ = [];
var devtoolsInspector = new Proxy(target.__VUE_DEVTOOLS_KIT_INSPECTOR__, {
  get(target22, prop, receiver) {
    return Reflect.get(target22, prop, receiver);
  }
});
var callInspectorUpdatedHook = debounce(() => {
  devtoolsContext.hooks.callHook("sendInspectorToClient", getActiveInspectors());
});
function addInspector(inspector, descriptor) {
  var _a25, _b25;
  devtoolsInspector.push({
    options: inspector,
    descriptor,
    treeFilterPlaceholder: (_a25 = inspector.treeFilterPlaceholder) != null ? _a25 : "Search tree...",
    stateFilterPlaceholder: (_b25 = inspector.stateFilterPlaceholder) != null ? _b25 : "Search state...",
    treeFilter: "",
    selectedNodeId: "",
    appRecord: getAppRecord(descriptor.app)
  });
  callInspectorUpdatedHook();
}
function getActiveInspectors() {
  return devtoolsInspector.filter((inspector) => inspector.descriptor.app === activeAppRecord.value.app).filter((inspector) => inspector.descriptor.id !== "components").map((inspector) => {
    var _a25;
    const descriptor = inspector.descriptor;
    const options = inspector.options;
    return {
      id: options.id,
      label: options.label,
      logo: descriptor.logo,
      icon: `custom-ic-baseline-${(_a25 = options == null ? void 0 : options.icon) == null ? void 0 : _a25.replace(/_/g, "-")}`,
      packageName: descriptor.packageName,
      homepage: descriptor.homepage,
      pluginId: descriptor.id
    };
  });
}
function getInspector(id, app) {
  return devtoolsInspector.find((inspector) => inspector.options.id === id && (app ? inspector.descriptor.app === app : true));
}
var DevToolsV6PluginAPIHookKeys = ((DevToolsV6PluginAPIHookKeys2) => {
  DevToolsV6PluginAPIHookKeys2["VISIT_COMPONENT_TREE"] = "visitComponentTree";
  DevToolsV6PluginAPIHookKeys2["INSPECT_COMPONENT"] = "inspectComponent";
  DevToolsV6PluginAPIHookKeys2["EDIT_COMPONENT_STATE"] = "editComponentState";
  DevToolsV6PluginAPIHookKeys2["GET_INSPECTOR_TREE"] = "getInspectorTree";
  DevToolsV6PluginAPIHookKeys2["GET_INSPECTOR_STATE"] = "getInspectorState";
  DevToolsV6PluginAPIHookKeys2["EDIT_INSPECTOR_STATE"] = "editInspectorState";
  DevToolsV6PluginAPIHookKeys2["INSPECT_TIMELINE_EVENT"] = "inspectTimelineEvent";
  DevToolsV6PluginAPIHookKeys2["TIMELINE_CLEARED"] = "timelineCleared";
  DevToolsV6PluginAPIHookKeys2["SET_PLUGIN_SETTINGS"] = "setPluginSettings";
  return DevToolsV6PluginAPIHookKeys2;
})(DevToolsV6PluginAPIHookKeys || {});
var DevToolsContextHookKeys = ((DevToolsContextHookKeys2) => {
  DevToolsContextHookKeys2["ADD_INSPECTOR"] = "addInspector";
  DevToolsContextHookKeys2["SEND_INSPECTOR_TREE"] = "sendInspectorTree";
  DevToolsContextHookKeys2["SEND_INSPECTOR_STATE"] = "sendInspectorState";
  DevToolsContextHookKeys2["CUSTOM_INSPECTOR_SELECT_NODE"] = "customInspectorSelectNode";
  DevToolsContextHookKeys2["TIMELINE_LAYER_ADDED"] = "timelineLayerAdded";
  DevToolsContextHookKeys2["TIMELINE_EVENT_ADDED"] = "timelineEventAdded";
  DevToolsContextHookKeys2["GET_COMPONENT_INSTANCES"] = "getComponentInstances";
  DevToolsContextHookKeys2["GET_COMPONENT_BOUNDS"] = "getComponentBounds";
  DevToolsContextHookKeys2["GET_COMPONENT_NAME"] = "getComponentName";
  DevToolsContextHookKeys2["COMPONENT_HIGHLIGHT"] = "componentHighlight";
  DevToolsContextHookKeys2["COMPONENT_UNHIGHLIGHT"] = "componentUnhighlight";
  return DevToolsContextHookKeys2;
})(DevToolsContextHookKeys || {});
var DevToolsMessagingHookKeys = ((DevToolsMessagingHookKeys2) => {
  DevToolsMessagingHookKeys2["SEND_INSPECTOR_TREE_TO_CLIENT"] = "sendInspectorTreeToClient";
  DevToolsMessagingHookKeys2["SEND_INSPECTOR_STATE_TO_CLIENT"] = "sendInspectorStateToClient";
  DevToolsMessagingHookKeys2["SEND_TIMELINE_EVENT_TO_CLIENT"] = "sendTimelineEventToClient";
  DevToolsMessagingHookKeys2["SEND_INSPECTOR_TO_CLIENT"] = "sendInspectorToClient";
  DevToolsMessagingHookKeys2["SEND_ACTIVE_APP_UNMOUNTED_TO_CLIENT"] = "sendActiveAppUpdatedToClient";
  DevToolsMessagingHookKeys2["DEVTOOLS_STATE_UPDATED"] = "devtoolsStateUpdated";
  DevToolsMessagingHookKeys2["DEVTOOLS_CONNECTED_UPDATED"] = "devtoolsConnectedUpdated";
  DevToolsMessagingHookKeys2["ROUTER_INFO_UPDATED"] = "routerInfoUpdated";
  return DevToolsMessagingHookKeys2;
})(DevToolsMessagingHookKeys || {});
function createDevToolsCtxHooks() {
  const hooks2 = createHooks();
  hooks2.hook("addInspector", ({ inspector, plugin: plugin2 }) => {
    addInspector(inspector, plugin2.descriptor);
  });
  const debounceSendInspectorTree = debounce(async ({ inspectorId, plugin: plugin2 }) => {
    var _a25;
    if (!inspectorId || !((_a25 = plugin2 == null ? void 0 : plugin2.descriptor) == null ? void 0 : _a25.app) || devtoolsState.highPerfModeEnabled)
      return;
    const inspector = getInspector(inspectorId, plugin2.descriptor.app);
    const _payload = {
      app: plugin2.descriptor.app,
      inspectorId,
      filter: (inspector == null ? void 0 : inspector.treeFilter) || "",
      rootNodes: []
    };
    await new Promise((resolve2) => {
      hooks2.callHookWith(
        async (callbacks) => {
          await Promise.all(callbacks.map((cb) => cb(_payload)));
          resolve2();
        },
        "getInspectorTree"
        /* GET_INSPECTOR_TREE */
      );
    });
    hooks2.callHookWith(
      async (callbacks) => {
        await Promise.all(callbacks.map((cb) => cb({
          inspectorId,
          rootNodes: _payload.rootNodes
        })));
      },
      "sendInspectorTreeToClient"
      /* SEND_INSPECTOR_TREE_TO_CLIENT */
    );
  }, 120);
  hooks2.hook("sendInspectorTree", debounceSendInspectorTree);
  const debounceSendInspectorState = debounce(async ({ inspectorId, plugin: plugin2 }) => {
    var _a25;
    if (!inspectorId || !((_a25 = plugin2 == null ? void 0 : plugin2.descriptor) == null ? void 0 : _a25.app) || devtoolsState.highPerfModeEnabled)
      return;
    const inspector = getInspector(inspectorId, plugin2.descriptor.app);
    const _payload = {
      app: plugin2.descriptor.app,
      inspectorId,
      nodeId: (inspector == null ? void 0 : inspector.selectedNodeId) || "",
      state: null
    };
    const ctx = {
      currentTab: `custom-inspector:${inspectorId}`
    };
    if (_payload.nodeId) {
      await new Promise((resolve2) => {
        hooks2.callHookWith(
          async (callbacks) => {
            await Promise.all(callbacks.map((cb) => cb(_payload, ctx)));
            resolve2();
          },
          "getInspectorState"
          /* GET_INSPECTOR_STATE */
        );
      });
    }
    hooks2.callHookWith(
      async (callbacks) => {
        await Promise.all(callbacks.map((cb) => cb({
          inspectorId,
          nodeId: _payload.nodeId,
          state: _payload.state
        })));
      },
      "sendInspectorStateToClient"
      /* SEND_INSPECTOR_STATE_TO_CLIENT */
    );
  }, 120);
  hooks2.hook("sendInspectorState", debounceSendInspectorState);
  hooks2.hook("customInspectorSelectNode", ({ inspectorId, nodeId, plugin: plugin2 }) => {
    const inspector = getInspector(inspectorId, plugin2.descriptor.app);
    if (!inspector)
      return;
    inspector.selectedNodeId = nodeId;
  });
  hooks2.hook("timelineLayerAdded", ({ options, plugin: plugin2 }) => {
    addTimelineLayer(options, plugin2.descriptor);
  });
  hooks2.hook("timelineEventAdded", ({ options, plugin: plugin2 }) => {
    var _a25;
    const internalLayerIds = ["performance", "component-event", "keyboard", "mouse"];
    if (devtoolsState.highPerfModeEnabled || !((_a25 = devtoolsState.timelineLayersState) == null ? void 0 : _a25[plugin2.descriptor.id]) && !internalLayerIds.includes(options.layerId))
      return;
    hooks2.callHookWith(
      async (callbacks) => {
        await Promise.all(callbacks.map((cb) => cb(options)));
      },
      "sendTimelineEventToClient"
      /* SEND_TIMELINE_EVENT_TO_CLIENT */
    );
  });
  hooks2.hook("getComponentInstances", async ({ app }) => {
    const appRecord = app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
    if (!appRecord)
      return null;
    const appId = appRecord.id.toString();
    const instances = [...appRecord.instanceMap].filter(([key]) => key.split(":")[0] === appId).map(([, instance]) => instance);
    return instances;
  });
  hooks2.hook("getComponentBounds", async ({ instance }) => {
    const bounds = getComponentBoundingRect(instance);
    return bounds;
  });
  hooks2.hook("getComponentName", ({ instance }) => {
    const name = getInstanceName(instance);
    return name;
  });
  hooks2.hook("componentHighlight", ({ uid }) => {
    const instance = activeAppRecord.value.instanceMap.get(uid);
    if (instance) {
      highlight(instance);
    }
  });
  hooks2.hook("componentUnhighlight", () => {
    unhighlight();
  });
  return hooks2;
}
var _a4;
var _b4;
(_b4 = (_a4 = target).__VUE_DEVTOOLS_KIT_APP_RECORDS__) != null ? _b4 : _a4.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = [];
var _a5;
var _b5;
(_b5 = (_a5 = target).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__) != null ? _b5 : _a5.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = {};
var _a6;
var _b6;
(_b6 = (_a6 = target).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__) != null ? _b6 : _a6.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = "";
var _a7;
var _b7;
(_b7 = (_a7 = target).__VUE_DEVTOOLS_KIT_CUSTOM_TABS__) != null ? _b7 : _a7.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ = [];
var _a8;
var _b8;
(_b8 = (_a8 = target).__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__) != null ? _b8 : _a8.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ = [];
var STATE_KEY = "__VUE_DEVTOOLS_KIT_GLOBAL_STATE__";
function initStateFactory() {
  return {
    connected: false,
    clientConnected: false,
    vitePluginDetected: true,
    appRecords: [],
    activeAppRecordId: "",
    tabs: [],
    commands: [],
    highPerfModeEnabled: true,
    devtoolsClientDetected: {},
    perfUniqueGroupId: 0,
    timelineLayersState: getTimelineLayersStateFromStorage()
  };
}
var _a9;
var _b9;
(_b9 = (_a9 = target)[STATE_KEY]) != null ? _b9 : _a9[STATE_KEY] = initStateFactory();
var callStateUpdatedHook = debounce((state) => {
  devtoolsContext.hooks.callHook("devtoolsStateUpdated", { state });
});
var callConnectedUpdatedHook = debounce((state, oldState) => {
  devtoolsContext.hooks.callHook("devtoolsConnectedUpdated", { state, oldState });
});
var devtoolsAppRecords = new Proxy(target.__VUE_DEVTOOLS_KIT_APP_RECORDS__, {
  get(_target, prop, receiver) {
    if (prop === "value")
      return target.__VUE_DEVTOOLS_KIT_APP_RECORDS__;
    return target.__VUE_DEVTOOLS_KIT_APP_RECORDS__[prop];
  }
});
var activeAppRecord = new Proxy(target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__, {
  get(_target, prop, receiver) {
    if (prop === "value")
      return target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__;
    else if (prop === "id")
      return target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__;
    return target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__[prop];
  }
});
function updateAllStates() {
  callStateUpdatedHook({
    ...target[STATE_KEY],
    appRecords: devtoolsAppRecords.value,
    activeAppRecordId: activeAppRecord.id,
    tabs: target.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__,
    commands: target.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__
  });
}
function setActiveAppRecord(app) {
  target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = app;
  updateAllStates();
}
function setActiveAppRecordId(id) {
  target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = id;
  updateAllStates();
}
var devtoolsState = new Proxy(target[STATE_KEY], {
  get(target22, property) {
    if (property === "appRecords") {
      return devtoolsAppRecords;
    } else if (property === "activeAppRecordId") {
      return activeAppRecord.id;
    } else if (property === "tabs") {
      return target.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__;
    } else if (property === "commands") {
      return target.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__;
    }
    return target[STATE_KEY][property];
  },
  deleteProperty(target22, property) {
    delete target22[property];
    return true;
  },
  set(target22, property, value) {
    const oldState = { ...target[STATE_KEY] };
    target22[property] = value;
    target[STATE_KEY][property] = value;
    return true;
  }
});
function openInEditor(options = {}) {
  var _a25, _b25, _c;
  const { file, host, baseUrl = window.location.origin, line = 0, column = 0 } = options;
  if (file) {
    if (host === "chrome-extension") {
      const fileName = file.replace(/\\/g, "\\\\");
      const _baseUrl = (_b25 = (_a25 = window.VUE_DEVTOOLS_CONFIG) == null ? void 0 : _a25.openInEditorHost) != null ? _b25 : "/";
      fetch(`${_baseUrl}__open-in-editor?file=${encodeURI(file)}`).then((response) => {
        if (!response.ok) {
          const msg = `Opening component ${fileName} failed`;
          console.log(`%c${msg}`, "color:red");
        }
      });
    } else if (devtoolsState.vitePluginDetected) {
      const _baseUrl = (_c = target.__VUE_DEVTOOLS_OPEN_IN_EDITOR_BASE_URL__) != null ? _c : baseUrl;
      target.__VUE_INSPECTOR__.openInEditor(_baseUrl, file, line, column);
    }
  }
}
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var _a10;
var _b10;
(_b10 = (_a10 = target).__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__) != null ? _b10 : _a10.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__ = [];
var devtoolsPluginBuffer = new Proxy(target.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__, {
  get(target22, prop, receiver) {
    return Reflect.get(target22, prop, receiver);
  }
});
function _getSettings(settings) {
  const _settings = {};
  Object.keys(settings).forEach((key) => {
    _settings[key] = settings[key].defaultValue;
  });
  return _settings;
}
function getPluginLocalKey(pluginId) {
  return `__VUE_DEVTOOLS_NEXT_PLUGIN_SETTINGS__${pluginId}__`;
}
function getPluginSettingsOptions(pluginId) {
  var _a25, _b25, _c;
  const item = (_b25 = (_a25 = devtoolsPluginBuffer.find((item2) => {
    var _a26;
    return item2[0].id === pluginId && !!((_a26 = item2[0]) == null ? void 0 : _a26.settings);
  })) == null ? void 0 : _a25[0]) != null ? _b25 : null;
  return (_c = item == null ? void 0 : item.settings) != null ? _c : null;
}
function getPluginSettings(pluginId, fallbackValue) {
  var _a25, _b25, _c;
  const localKey = getPluginLocalKey(pluginId);
  if (localKey) {
    const localSettings = localStorage.getItem(localKey);
    if (localSettings) {
      return JSON.parse(localSettings);
    }
  }
  if (pluginId) {
    const item = (_b25 = (_a25 = devtoolsPluginBuffer.find((item2) => item2[0].id === pluginId)) == null ? void 0 : _a25[0]) != null ? _b25 : null;
    return _getSettings((_c = item == null ? void 0 : item.settings) != null ? _c : {});
  }
  return _getSettings(fallbackValue);
}
function initPluginSettings(pluginId, settings) {
  const localKey = getPluginLocalKey(pluginId);
  const localSettings = localStorage.getItem(localKey);
  if (!localSettings) {
    localStorage.setItem(localKey, JSON.stringify(_getSettings(settings)));
  }
}
function setPluginSettings(pluginId, key, value) {
  const localKey = getPluginLocalKey(pluginId);
  const localSettings = localStorage.getItem(localKey);
  const parsedLocalSettings = JSON.parse(localSettings || "{}");
  const updated = {
    ...parsedLocalSettings,
    [key]: value
  };
  localStorage.setItem(localKey, JSON.stringify(updated));
  devtoolsContext.hooks.callHookWith(
    (callbacks) => {
      callbacks.forEach((cb) => cb({
        pluginId,
        key,
        oldValue: parsedLocalSettings[key],
        newValue: value,
        settings: updated
      }));
    },
    "setPluginSettings"
    /* SET_PLUGIN_SETTINGS */
  );
}
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var _a11;
var _b11;
var devtoolsHooks = (_b11 = (_a11 = target).__VUE_DEVTOOLS_HOOK) != null ? _b11 : _a11.__VUE_DEVTOOLS_HOOK = createHooks();
var on = {
  vueAppInit(fn) {
    devtoolsHooks.hook("app:init", fn);
  },
  vueAppUnmount(fn) {
    devtoolsHooks.hook("app:unmount", fn);
  },
  vueAppConnected(fn) {
    devtoolsHooks.hook("app:connected", fn);
  },
  componentAdded(fn) {
    return devtoolsHooks.hook("component:added", fn);
  },
  componentEmit(fn) {
    return devtoolsHooks.hook("component:emit", fn);
  },
  componentUpdated(fn) {
    return devtoolsHooks.hook("component:updated", fn);
  },
  componentRemoved(fn) {
    return devtoolsHooks.hook("component:removed", fn);
  },
  setupDevtoolsPlugin(fn) {
    devtoolsHooks.hook("devtools-plugin:setup", fn);
  },
  perfStart(fn) {
    return devtoolsHooks.hook("perf:start", fn);
  },
  perfEnd(fn) {
    return devtoolsHooks.hook("perf:end", fn);
  }
};
var hook = {
  on,
  setupDevToolsPlugin(pluginDescriptor, setupFn) {
    return devtoolsHooks.callHook("devtools-plugin:setup", pluginDescriptor, setupFn);
  }
};
var DevToolsV6PluginAPI = class {
  constructor({ plugin: plugin2, ctx }) {
    this.hooks = ctx.hooks;
    this.plugin = plugin2;
  }
  get on() {
    return {
      // component inspector
      visitComponentTree: (handler) => {
        this.hooks.hook("visitComponentTree", handler);
      },
      inspectComponent: (handler) => {
        this.hooks.hook("inspectComponent", handler);
      },
      editComponentState: (handler) => {
        this.hooks.hook("editComponentState", handler);
      },
      // custom inspector
      getInspectorTree: (handler) => {
        this.hooks.hook("getInspectorTree", handler);
      },
      getInspectorState: (handler) => {
        this.hooks.hook("getInspectorState", handler);
      },
      editInspectorState: (handler) => {
        this.hooks.hook("editInspectorState", handler);
      },
      // timeline
      inspectTimelineEvent: (handler) => {
        this.hooks.hook("inspectTimelineEvent", handler);
      },
      timelineCleared: (handler) => {
        this.hooks.hook("timelineCleared", handler);
      },
      // settings
      setPluginSettings: (handler) => {
        this.hooks.hook("setPluginSettings", handler);
      }
    };
  }
  // component inspector
  notifyComponentUpdate(instance) {
    var _a25;
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    const inspector = getActiveInspectors().find((i) => i.packageName === this.plugin.descriptor.packageName);
    if (inspector == null ? void 0 : inspector.id) {
      if (instance) {
        const args = [
          instance.appContext.app,
          instance.uid,
          (_a25 = instance.parent) == null ? void 0 : _a25.uid,
          instance
        ];
        devtoolsHooks.callHook("component:updated", ...args);
      } else {
        devtoolsHooks.callHook(
          "component:updated"
          /* COMPONENT_UPDATED */
        );
      }
      this.hooks.callHook("sendInspectorState", { inspectorId: inspector.id, plugin: this.plugin });
    }
  }
  // custom inspector
  addInspector(options) {
    this.hooks.callHook("addInspector", { inspector: options, plugin: this.plugin });
    if (this.plugin.descriptor.settings) {
      initPluginSettings(options.id, this.plugin.descriptor.settings);
    }
  }
  sendInspectorTree(inspectorId) {
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    this.hooks.callHook("sendInspectorTree", { inspectorId, plugin: this.plugin });
  }
  sendInspectorState(inspectorId) {
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    this.hooks.callHook("sendInspectorState", { inspectorId, plugin: this.plugin });
  }
  selectInspectorNode(inspectorId, nodeId) {
    this.hooks.callHook("customInspectorSelectNode", { inspectorId, nodeId, plugin: this.plugin });
  }
  visitComponentTree(payload) {
    return this.hooks.callHook("visitComponentTree", payload);
  }
  // timeline
  now() {
    if (devtoolsState.highPerfModeEnabled) {
      return 0;
    }
    return Date.now();
  }
  addTimelineLayer(options) {
    this.hooks.callHook("timelineLayerAdded", { options, plugin: this.plugin });
  }
  addTimelineEvent(options) {
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    this.hooks.callHook("timelineEventAdded", { options, plugin: this.plugin });
  }
  // settings
  getSettings(pluginId) {
    return getPluginSettings(pluginId != null ? pluginId : this.plugin.descriptor.id, this.plugin.descriptor.settings);
  }
  // utilities
  getComponentInstances(app) {
    return this.hooks.callHook("getComponentInstances", { app });
  }
  getComponentBounds(instance) {
    return this.hooks.callHook("getComponentBounds", { instance });
  }
  getComponentName(instance) {
    return this.hooks.callHook("getComponentName", { instance });
  }
  highlightElement(instance) {
    const uid = instance.__VUE_DEVTOOLS_NEXT_UID__;
    return this.hooks.callHook("componentHighlight", { uid });
  }
  unhighlightElement() {
    return this.hooks.callHook(
      "componentUnhighlight"
      /* COMPONENT_UNHIGHLIGHT */
    );
  }
};
var DevToolsPluginAPI = DevToolsV6PluginAPI;
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var UNDEFINED = "__vue_devtool_undefined__";
var INFINITY = "__vue_devtool_infinity__";
var NEGATIVE_INFINITY = "__vue_devtool_negative_infinity__";
var NAN = "__vue_devtool_nan__";
init_esm_shims2();
init_esm_shims2();
var tokenMap = {
  [UNDEFINED]: "undefined",
  [NAN]: "NaN",
  [INFINITY]: "Infinity",
  [NEGATIVE_INFINITY]: "-Infinity"
};
var reversedTokenMap = Object.entries(tokenMap).reduce((acc, [key, value]) => {
  acc[value] = key;
  return acc;
}, {});
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var _a12;
var _b12;
(_b12 = (_a12 = target).__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__) != null ? _b12 : _a12.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__ = /* @__PURE__ */ new Set();
function setupDevToolsPlugin(pluginDescriptor, setupFn) {
  return hook.setupDevToolsPlugin(pluginDescriptor, setupFn);
}
function callDevToolsPluginSetupFn(plugin2, app) {
  const [pluginDescriptor, setupFn] = plugin2;
  if (pluginDescriptor.app !== app)
    return;
  const api = new DevToolsPluginAPI({
    plugin: {
      setupFn,
      descriptor: pluginDescriptor
    },
    ctx: devtoolsContext
  });
  if (pluginDescriptor.packageName === "vuex") {
    api.on.editInspectorState((payload) => {
      api.sendInspectorState(payload.inspectorId);
    });
  }
  setupFn(api);
}
function registerDevToolsPlugin(app, options) {
  if (target.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.has(app)) {
    return;
  }
  if (devtoolsState.highPerfModeEnabled && !(options == null ? void 0 : options.inspectingComponent)) {
    return;
  }
  target.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.add(app);
  devtoolsPluginBuffer.forEach((plugin2) => {
    callDevToolsPluginSetupFn(plugin2, app);
  });
}
init_esm_shims2();
init_esm_shims2();
var ROUTER_KEY = "__VUE_DEVTOOLS_ROUTER__";
var ROUTER_INFO_KEY = "__VUE_DEVTOOLS_ROUTER_INFO__";
var _a13;
var _b13;
(_b13 = (_a13 = target)[ROUTER_INFO_KEY]) != null ? _b13 : _a13[ROUTER_INFO_KEY] = {
  currentRoute: null,
  routes: []
};
var _a14;
var _b14;
(_b14 = (_a14 = target)[ROUTER_KEY]) != null ? _b14 : _a14[ROUTER_KEY] = {};
var devtoolsRouterInfo = new Proxy(target[ROUTER_INFO_KEY], {
  get(target22, property) {
    return target[ROUTER_INFO_KEY][property];
  }
});
var devtoolsRouter = new Proxy(target[ROUTER_KEY], {
  get(target22, property) {
    if (property === "value") {
      return target[ROUTER_KEY];
    }
  }
});
function getRoutes(router) {
  const routesMap = /* @__PURE__ */ new Map();
  return ((router == null ? void 0 : router.getRoutes()) || []).filter((i) => !routesMap.has(i.path) && routesMap.set(i.path, 1));
}
function filterRoutes(routes) {
  return routes.map((item) => {
    let { path, name, children, meta } = item;
    if (children == null ? void 0 : children.length)
      children = filterRoutes(children);
    return {
      path,
      name,
      children,
      meta
    };
  });
}
function filterCurrentRoute(route) {
  if (route) {
    const { fullPath, hash, href, path, name, matched, params, query } = route;
    return {
      fullPath,
      hash,
      href,
      path,
      name,
      params,
      query,
      matched: filterRoutes(matched)
    };
  }
  return route;
}
function normalizeRouterInfo(appRecord, activeAppRecord2) {
  function init() {
    var _a25;
    const router = (_a25 = appRecord.app) == null ? void 0 : _a25.config.globalProperties.$router;
    const currentRoute = filterCurrentRoute(router == null ? void 0 : router.currentRoute.value);
    const routes = filterRoutes(getRoutes(router));
    const c = console.warn;
    console.warn = () => {
    };
    target[ROUTER_INFO_KEY] = {
      currentRoute: currentRoute ? deepClone(currentRoute) : {},
      routes: deepClone(routes)
    };
    target[ROUTER_KEY] = router;
    console.warn = c;
  }
  init();
  hook.on.componentUpdated(debounce(() => {
    var _a25;
    if (((_a25 = activeAppRecord2.value) == null ? void 0 : _a25.app) !== appRecord.app)
      return;
    init();
    if (devtoolsState.highPerfModeEnabled)
      return;
    devtoolsContext.hooks.callHook("routerInfoUpdated", { state: target[ROUTER_INFO_KEY] });
  }, 200));
}
function createDevToolsApi(hooks2) {
  return {
    // get inspector tree
    async getInspectorTree(payload) {
      const _payload = {
        ...payload,
        app: activeAppRecord.value.app,
        rootNodes: []
      };
      await new Promise((resolve2) => {
        hooks2.callHookWith(
          async (callbacks) => {
            await Promise.all(callbacks.map((cb) => cb(_payload)));
            resolve2();
          },
          "getInspectorTree"
          /* GET_INSPECTOR_TREE */
        );
      });
      return _payload.rootNodes;
    },
    // get inspector state
    async getInspectorState(payload) {
      const _payload = {
        ...payload,
        app: activeAppRecord.value.app,
        state: null
      };
      const ctx = {
        currentTab: `custom-inspector:${payload.inspectorId}`
      };
      await new Promise((resolve2) => {
        hooks2.callHookWith(
          async (callbacks) => {
            await Promise.all(callbacks.map((cb) => cb(_payload, ctx)));
            resolve2();
          },
          "getInspectorState"
          /* GET_INSPECTOR_STATE */
        );
      });
      return _payload.state;
    },
    // edit inspector state
    editInspectorState(payload) {
      const stateEditor2 = new StateEditor();
      const _payload = {
        ...payload,
        app: activeAppRecord.value.app,
        set: (obj, path = payload.path, value = payload.state.value, cb) => {
          stateEditor2.set(obj, path, value, cb || stateEditor2.createDefaultSetCallback(payload.state));
        }
      };
      hooks2.callHookWith(
        (callbacks) => {
          callbacks.forEach((cb) => cb(_payload));
        },
        "editInspectorState"
        /* EDIT_INSPECTOR_STATE */
      );
    },
    // send inspector state
    sendInspectorState(inspectorId) {
      const inspector = getInspector(inspectorId);
      hooks2.callHook("sendInspectorState", { inspectorId, plugin: {
        descriptor: inspector.descriptor,
        setupFn: () => ({})
      } });
    },
    // inspect component inspector
    inspectComponentInspector() {
      return inspectComponentHighLighter();
    },
    // cancel inspect component inspector
    cancelInspectComponentInspector() {
      return cancelInspectComponentHighLighter();
    },
    // get component render code
    getComponentRenderCode(id) {
      const instance = getComponentInstance(activeAppRecord.value, id);
      if (instance)
        return !(typeof (instance == null ? void 0 : instance.type) === "function") ? instance.render.toString() : instance.type.toString();
    },
    // scroll to component
    scrollToComponent(id) {
      return scrollToComponent({ id });
    },
    // open in editor
    openInEditor,
    // get vue inspector
    getVueInspector: getComponentInspector,
    // toggle app
    toggleApp(id, options) {
      const appRecord = devtoolsAppRecords.value.find((record) => record.id === id);
      if (appRecord) {
        setActiveAppRecordId(id);
        setActiveAppRecord(appRecord);
        normalizeRouterInfo(appRecord, activeAppRecord);
        callInspectorUpdatedHook();
        registerDevToolsPlugin(appRecord.app, options);
      }
    },
    // inspect dom
    inspectDOM(instanceId) {
      const instance = getComponentInstance(activeAppRecord.value, instanceId);
      if (instance) {
        const [el] = getRootElementsFromComponentInstance(instance);
        if (el) {
          target.__VUE_DEVTOOLS_INSPECT_DOM_TARGET__ = el;
        }
      }
    },
    updatePluginSettings(pluginId, key, value) {
      setPluginSettings(pluginId, key, value);
    },
    getPluginSettings(pluginId) {
      return {
        options: getPluginSettingsOptions(pluginId),
        values: getPluginSettings(pluginId)
      };
    }
  };
}
init_esm_shims2();
var _a15;
var _b15;
(_b15 = (_a15 = target).__VUE_DEVTOOLS_ENV__) != null ? _b15 : _a15.__VUE_DEVTOOLS_ENV__ = {
  vitePluginDetected: false
};
var hooks = createDevToolsCtxHooks();
var _a16;
var _b16;
(_b16 = (_a16 = target).__VUE_DEVTOOLS_KIT_CONTEXT__) != null ? _b16 : _a16.__VUE_DEVTOOLS_KIT_CONTEXT__ = {
  hooks,
  get state() {
    return {
      ...devtoolsState,
      activeAppRecordId: activeAppRecord.id,
      activeAppRecord: activeAppRecord.value,
      appRecords: devtoolsAppRecords.value
    };
  },
  api: createDevToolsApi(hooks)
};
var devtoolsContext = target.__VUE_DEVTOOLS_KIT_CONTEXT__;
init_esm_shims2();
var import_speakingurl = __toESM2(require_speakingurl2(), 1);
var _a17;
var _b17;
var appRecordInfo = (_b17 = (_a17 = target).__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__) != null ? _b17 : _a17.__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__ = {
  id: 0,
  appIds: /* @__PURE__ */ new Set()
};
init_esm_shims2();
init_esm_shims2();
function toggleHighPerfMode(state) {
  devtoolsState.highPerfModeEnabled = state != null ? state : !devtoolsState.highPerfModeEnabled;
  if (!state && activeAppRecord.value) {
    registerDevToolsPlugin(activeAppRecord.value.app);
  }
}
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
function updateDevToolsClientDetected(params) {
  devtoolsState.devtoolsClientDetected = {
    ...devtoolsState.devtoolsClientDetected,
    ...params
  };
  const devtoolsClientVisible = Object.values(devtoolsState.devtoolsClientDetected).some(Boolean);
  toggleHighPerfMode(!devtoolsClientVisible);
}
var _a18;
var _b18;
(_b18 = (_a18 = target).__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__) != null ? _b18 : _a18.__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__ = updateDevToolsClientDetected;
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var DoubleIndexedKV = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
};
var Registry = class {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
};
var ClassRegistry = class extends Registry {
  constructor() {
    super((c) => c.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
};
init_esm_shims2();
init_esm_shims2();
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  const values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (let i = 0; i < valuesNotNever.length; i++) {
    const value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (let i = 0; i < record.length; i++) {
    const value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
var CustomTransformerRegistry = class {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name) {
    return this.transfomers[name];
  }
};
init_esm_shims2();
init_esm_shims2();
var getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
var isUndefined2 = (payload) => typeof payload === "undefined";
var isNull = (payload) => payload === null;
var isPlainObject2 = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = (payload) => isPlainObject2(payload) && Object.keys(payload).length === 0;
var isArray = (payload) => Array.isArray(payload);
var isString2 = (payload) => typeof payload === "string";
var isNumber2 = (payload) => typeof payload === "number" && !isNaN(payload);
var isBoolean = (payload) => typeof payload === "boolean";
var isRegExp = (payload) => payload instanceof RegExp;
var isMap = (payload) => payload instanceof Map;
var isSet = (payload) => payload instanceof Set;
var isSymbol = (payload) => getType(payload) === "Symbol";
var isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
var isError = (payload) => payload instanceof Error;
var isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
var isPrimitive2 = (payload) => isBoolean(payload) || isNull(payload) || isUndefined2(payload) || isNumber2(payload) || isString2(payload) || isSymbol(payload);
var isBigint = (payload) => typeof payload === "bigint";
var isInfinite = (payload) => payload === Infinity || payload === -Infinity;
var isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
var isURL = (payload) => payload instanceof URL;
init_esm_shims2();
var escapeKey = (key) => key.replace(/\./g, "\\.");
var stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
var parsePath = (string) => {
  const result = [];
  let segment = "";
  for (let i = 0; i < string.length; i++) {
    let char = string.charAt(i);
    const isEscapedDot = char === "\\" && string.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};
init_esm_shims2();
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined2, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, (v, superJson) => {
    const e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v) => [...v.values()],
    (v) => new Set(v)
  ),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation((s, superJson) => {
  if (isSymbol(s)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, (s, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass == null ? void 0 : potentialClass.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result = {};
  allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  });
  return result;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation((value, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = (json, type, superJson) => {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};
init_esm_shims2();
var getNthKey = (value, n) => {
  if (n > value.size)
    throw new Error("index out of bounds");
  const keys2 = value.keys();
  while (n > 0) {
    keys2.next();
    n--;
  }
  return keys2.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = (object, path) => {
  validatePath(path);
  for (let i = 0; i < path.length; i++) {
    const key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
var setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (isArray(parent)) {
      const index = +key;
      parent = parent[index];
    } else if (isPlainObject2(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject2(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};
function traverse(tree, walker2, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, [...origin, ...parsePath(key)]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = (object, superJson) => isPlainObject2(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths) => {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  var _a25;
  const primitive = isPrimitive2(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = (_a25 = transformationResult == null ? void 0 : transformationResult.value) != null ? _a25 : object;
  const transformedValue = isArray(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index) => {
    if (index === "__proto__" || index === "constructor" || index === "prototype") {
      throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject2(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};
init_esm_shims2();
init_esm_shims2();
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject3(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}
function isUndefined22(payload) {
  return getType2(payload) === "Undefined";
}
var isNullOrUndefined = isOneOf(isNull2, isUndefined22);
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target22, options = {}) {
  if (isArray2(target22)) {
    return target22.map((item) => copy(item, options));
  }
  if (!isPlainObject3(target22)) {
    return target22;
  }
  const props = Object.getOwnPropertyNames(target22);
  const symbols = Object.getOwnPropertySymbols(target22);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target22[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target22, options.nonenumerable);
    return carry;
  }, {});
}
var SuperJSON = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s) => {
      var _a25;
      return (_a25 = s.description) != null ? _a25 : "";
    });
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta == null ? void 0 : meta.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta == null ? void 0 : meta.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string));
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
};
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
var serialize = SuperJSON.serialize;
var deserialize = SuperJSON.deserialize;
var stringify = SuperJSON.stringify;
var parse = SuperJSON.parse;
var registerClass = SuperJSON.registerClass;
var registerCustom = SuperJSON.registerCustom;
var registerSymbol = SuperJSON.registerSymbol;
var allowErrorProps = SuperJSON.allowErrorProps;
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var _a19;
var _b19;
(_b19 = (_a19 = target).__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__) != null ? _b19 : _a19.__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__ = [];
var _a20;
var _b20;
(_b20 = (_a20 = target).__VUE_DEVTOOLS_KIT_RPC_CLIENT__) != null ? _b20 : _a20.__VUE_DEVTOOLS_KIT_RPC_CLIENT__ = null;
var _a21;
var _b21;
(_b21 = (_a21 = target).__VUE_DEVTOOLS_KIT_RPC_SERVER__) != null ? _b21 : _a21.__VUE_DEVTOOLS_KIT_RPC_SERVER__ = null;
var _a222;
var _b22;
(_b22 = (_a222 = target).__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__) != null ? _b22 : _a222.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__ = null;
var _a23;
var _b23;
(_b23 = (_a23 = target).__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__) != null ? _b23 : _a23.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__ = null;
var _a24;
var _b24;
(_b24 = (_a24 = target).__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__) != null ? _b24 : _a24.__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__ = null;
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
init_esm_shims2();
var MAX_SERIALIZED_SIZE = 2 * 1024 * 1024;

// node_modules/@tresjs/core/dist/tres.js
var version = "5.3.1";
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var isHTMLTag = makeMap(HTML_TAGS);
var createTypeGuard = (property) => (value) => isObject2(value) && property in value && !!value[property];
var isObject3D = createTypeGuard("isObject3D");
var isMesh = createTypeGuard("isMesh");
var isCamera = createTypeGuard("isCamera");
var isOrthographicCamera = createTypeGuard("isOrthographicCamera");
var isPerspectiveCamera = createTypeGuard("isPerspectiveCamera");
var isColor = createTypeGuard("isColor");
var isColorRepresentation = (value) => isString(value) || isNumber(value) || isColor(value);
var isLayers = (value) => value instanceof Layers;
var isBufferGeometry = createTypeGuard("isBufferGeometry");
var isMaterial = createTypeGuard("isMaterial");
var isLight = createTypeGuard("isLight");
var isFog = createTypeGuard("isFog");
var isScene = createTypeGuard("isScene");
var isGroup = createTypeGuard("isGroup");
var isVectorLike = (value) => value !== null && typeof value === "object" && "set" in value && typeof value.set === "function";
var isCopyable = (value) => isVectorLike(value) && "copy" in value && typeof value.copy === "function";
var isClassInstance = (object) => !!object?.constructor;
var isTresCamera = (value) => isCamera(value) || isOrthographicCamera(value) || isPerspectiveCamera(value);
var isTresObject = (value) => isObject3D(value) || isBufferGeometry(value) || isMaterial(value) || isFog(value);
var isTresPrimitive = createTypeGuard("isPrimitive");
var isTresInstance = (value) => isTresObject(value) && "__tres" in value;
var filterInPlace = (array, callbackFn) => {
  let i = 0;
  for (let ii = 0; ii < array.length; ii++) if (callbackFn(array[ii], ii)) {
    array[i] = array[ii];
    i++;
  }
  array.length = i;
  return array;
};
function resolveRuntimeMode() {
  try {
    const modeFromImportMeta = import.meta?.env?.MODE;
    if (modeFromImportMeta) return modeFromImportMeta;
  } catch {
  }
  return typeof process !== "undefined" && process.env && "development" ? "development" : "production";
}
var isProd = resolveRuntimeMode() === "production";
var logPrefix = "[TresJS   ] ";
function logError(...args) {
  if (typeof args[0] === "string") args[0] = logPrefix + args[0];
  else args.unshift(logPrefix);
  console.error(...args);
}
function logWarning(...args) {
  if (typeof args[0] === "string") args[0] = logPrefix + args[0];
  else args.unshift(logPrefix);
  console.warn(...args);
}
function logMessage(name, value) {
  if (!isProd) console.log(`${logPrefix} - ${name}:`, value);
}
function disposeMaterial(material) {
  const hasMap = (material$1) => "map" in material$1 && !!material$1.map;
  if (hasMap(material)) material.map.dispose();
  material.dispose();
}
function disposeObject3D(object) {
  if (object.parent) object.removeFromParent?.();
  delete object.__tres;
  [...object.children].forEach((child) => disposeObject3D(child));
  if (object instanceof Scene) {
  } else {
    const mesh = object;
    if (object) object.dispose?.();
    if (mesh.geometry) mesh.geometry.dispose();
    if (Array.isArray(mesh.material)) mesh.material.forEach((material) => disposeMaterial(material));
    else if (mesh.material) disposeMaterial(mesh.material);
  }
}
function resolve(obj, key) {
  let target2 = obj;
  if (key.includes("-")) {
    const entries = key.split("-");
    let currKey = entries.shift();
    while (target2 && entries.length) if (!(currKey in target2)) currKey = joinAsCamelCase(currKey, entries.shift());
    else {
      target2 = target2[currKey];
      currKey = entries.shift();
    }
    return {
      target: target2,
      key: joinAsCamelCase(currKey, ...entries)
    };
  } else return {
    target: target2,
    key
  };
}
function joinAsCamelCase(...strings) {
  return strings.map((s, i) => i === 0 ? s : s.charAt(0).toUpperCase() + s.slice(1)).join("");
}
function attach(parent, child, type) {
  const INDEX_REGEX = /-\d+$/;
  if (isString(type)) {
    if (INDEX_REGEX.test(type)) {
      const { target: target$1, key: key$1 } = resolve(parent, type.replace(INDEX_REGEX, ""));
      if (!Array.isArray(target$1[key$1])) {
        const previousAttach = target$1[key$1];
        const augmentedArray = [];
        augmentedArray.__tresDetach = () => {
          if (augmentedArray.every((v) => isUndefined(v))) target$1[key$1] = previousAttach;
        };
        target$1[key$1] = augmentedArray;
      }
    }
    const { target: target2, key } = resolve(parent, type);
    child.__tres.previousAttach = target2[key];
    target2[key] = unboxTresPrimitive(child);
  } else child.__tres.previousAttach = type(parent, child);
}
function detach(parent, child, type) {
  if (isString(type)) {
    const { target: target2, key } = resolve(parent, type);
    const previous = child.__tres.previousAttach;
    if (previous === void 0) delete target2[key];
    else target2[key] = previous;
    if ("__tresDetach" in target2) target2.__tresDetach();
  } else child.__tres?.previousAttach?.(parent, child);
  delete child.__tres?.previousAttach;
}
function prepareTresInstance(obj, state, context) {
  const instance = obj;
  instance.__tres = {
    type: "unknown",
    root: context,
    memoizedProps: {},
    objects: [],
    parent: null,
    previousAttach: null,
    ...state
  };
  if (!instance.__tres.attach) {
    if (isMaterial(instance)) instance.__tres.attach = "material";
    else if (isBufferGeometry(instance)) instance.__tres.attach = "geometry";
    else if (isFog(instance)) instance.__tres.attach = "fog";
  }
  return instance;
}
function invalidateInstance(instance) {
  const ctx = instance?.__tres?.root;
  if (!ctx?.renderer) return;
  if (ctx.renderer.canBeInvalidated.value) ctx.renderer.invalidate();
}
function setPrimitiveObject(newObject, primitive, setTarget, nodeOpsFns, context) {
  const objectsToAttach = [...primitive.__tres.objects];
  const oldObject = unboxTresPrimitive(primitive);
  newObject = unboxTresPrimitive(newObject);
  if (oldObject === newObject) return true;
  const newInstance = prepareTresInstance(newObject, primitive.__tres ?? {}, context);
  const parent = primitive.parent ?? primitive.__tres.parent ?? null;
  const propsToPatch = { ...primitive.__tres.memoizedProps };
  delete propsToPatch.object;
  for (const obj of objectsToAttach) {
    doRemoveDetach(obj, context);
    doRemoveDeregister(obj, context);
  }
  oldObject.__tres.objects = [];
  nodeOpsFns.remove(primitive);
  for (const [key, value] of Object.entries(propsToPatch)) nodeOpsFns.patchProp(newInstance, key, newInstance[key], value);
  setTarget(newObject);
  nodeOpsFns.insert(primitive, parent);
  for (const obj of objectsToAttach) nodeOpsFns.insert(obj, primitive);
  return true;
}
function unboxTresPrimitive(maybePrimitive) {
  if (isTresPrimitive(maybePrimitive)) {
    const primitive = maybePrimitive;
    primitive.object.__tres = primitive.__tres;
    return primitive.object;
  } else return maybePrimitive;
}
function doRemoveDetach(node, context) {
  const parent = node.__tres?.parent || context.scene.value;
  if (node.__tres) node.__tres.parent = null;
  if (parent && parent.__tres && "objects" in parent.__tres) filterInPlace(parent.__tres.objects, (obj) => obj !== node);
  if (node.__tres?.attach) detach(parent, node, node.__tres.attach);
  else {
    node.parent?.remove?.(unboxTresPrimitive(node));
    node.parent = null;
  }
}
function doRemoveDeregister(node, context) {
  node.traverse?.((child) => {
    if (isTresCamera(child)) context.camera.deregisterCamera(child);
  });
  if (isTresCamera(node)) context.camera.deregisterCamera(node);
  invalidateInstance(node);
}
function useLoader(Loader$1, path, options) {
  const proto = new Loader$1(options?.manager);
  const progress = reactive3({
    loaded: 0,
    total: 0,
    percentage: 0
  });
  if (options?.extensions) options.extensions(proto);
  const initialPath = toValue2(path);
  const result = useAsyncState((path$1) => new Promise((resolve$1, reject) => {
    const assetPath = path$1 || initialPath || "";
    proto.load(assetPath, (result$1) => {
      resolve$1(result$1);
    }, (event) => {
      progress.loaded = event.loaded;
      progress.total = event.total;
      progress.percentage = progress.loaded / progress.total * 100;
    }, (err) => {
      reject(err);
    });
  }), options?.initialValue ?? null, {
    ...options?.asyncOptions,
    immediate: options?.asyncOptions?.immediate ?? true
  });
  const unsub = watch3(() => toValue2(path), (newPath) => {
    if (newPath) {
      const value = result.state.value;
      if (value && typeof value === "object" && "scene" in value && value.scene) disposeObject3D(value.scene);
      result.execute(0, newPath);
    }
  });
  onUnmounted2(() => {
    unsub();
    const value = result.state.value;
    if (value && typeof value === "object" && "scene" in value && value.scene) disposeObject3D(value.scene);
  });
  return {
    ...result,
    load: (path$1) => {
      result.execute(0, path$1);
    },
    progress
  };
}
var component_vue_vue_type_script_setup_true_lang_default = defineComponent2({
  __name: "component",
  props: {
    loader: {
      type: null,
      required: true
    },
    path: {
      type: String,
      required: true
    },
    manager: {
      type: Object,
      required: false
    }
  },
  emits: ["loaded", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { state, isLoading, error } = useLoader(props.loader, props.path, { manager: props.manager });
    whenever(error, (err) => {
      if (err) emit("error", err);
    });
    whenever(state, (value) => {
      if (value) emit("loaded", value);
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default", {
        state: unref3(state),
        isLoading: unref3(isLoading),
        error: unref3(error)
      });
    };
  }
});
var component_default = component_vue_vue_type_script_setup_true_lang_default;
var useCameraManager = ({ sizes }) => {
  const cameras = ref3([]);
  const activeCamera = computed3(() => cameras.value[0]);
  const setActiveCamera = (cameraOrUuid) => {
    const camera = isCamera(cameraOrUuid) ? cameraOrUuid : cameras.value.find((camera$1) => camera$1.uuid === cameraOrUuid);
    if (!camera) return;
    cameras.value = [camera, ...cameras.value.filter(({ uuid }) => uuid !== camera.uuid)];
  };
  const registerCamera = (camera, active = false) => {
    if (cameras.value.some(({ uuid }) => uuid === camera.uuid)) return;
    cameras.value.push(camera);
    if (active) setActiveCamera(camera.uuid);
  };
  const deregisterCamera = (camera) => {
    cameras.value = cameras.value.filter(({ uuid }) => uuid !== camera.uuid);
  };
  watchEffect3(() => {
    if (sizes.aspectRatio.value) cameras.value.forEach((camera) => {
      if (isPerspectiveCamera(camera)) {
        camera.aspect = sizes.aspectRatio.value;
        camera.updateProjectionMatrix();
      }
    });
  });
  return {
    activeCamera,
    cameras,
    registerCamera,
    deregisterCamera,
    setActiveCamera
  };
};
function buildGraph(object) {
  const data = {
    nodes: {},
    materials: {},
    meshes: {}
  };
  if (object) object.traverse((obj) => {
    if (obj.name) data.nodes[obj.name] = obj;
    if (isMesh(obj)) {
      if (!data.meshes[obj.name]) data.meshes[obj.name] = obj;
      (Array.isArray(obj.material) ? obj.material : [obj.material]).forEach((material) => {
        if (material.name && !data.materials[material.name]) data.materials[material.name] = material;
      });
    }
  });
  return data;
}
var useGraph = (object) => {
  return computed3(() => {
    const obj = toValue2(object);
    if (!obj) return;
    return buildGraph(obj);
  });
};
function createPriorityEventHook() {
  const eventToPriority = /* @__PURE__ */ new Map();
  const ascending = /* @__PURE__ */ new Set();
  let ADD_COUNT = 0;
  let dirty = false;
  const sort = () => {
    const sorted = Array.from(eventToPriority.entries()).sort((a, b) => {
      const priorityDiff = a[1].priority - b[1].priority;
      return priorityDiff === 0 ? a[1].addI - b[1].addI : priorityDiff;
    });
    ascending.clear();
    sorted.forEach((entry) => ascending.add(entry[0]));
  };
  const off = (fn) => {
    eventToPriority.delete(fn);
    ascending.delete(fn);
  };
  const on2 = (fn, priority = 0) => {
    eventToPriority.set(fn, {
      priority,
      addI: ADD_COUNT++
    });
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    dirty = true;
    return { off: offFn };
  };
  const trigger = (...args) => {
    if (dirty) {
      sort();
      dirty = false;
    }
    return Promise.all(Array.from(ascending).map((fn) => fn(...args)));
  };
  const dispose = () => {
    eventToPriority.clear();
    ascending.clear();
  };
  return {
    on: on2,
    off,
    trigger,
    dispose,
    get count() {
      return eventToPriority.size;
    }
  };
}
var catalogue = ref3({});
var extend = (objects) => Object.assign(catalogue.value, objects);
var setPixelRatio = (renderer, systemDpr, userDpr) => {
  if (!isFunction(renderer.setPixelRatio)) return;
  let newDpr = 0;
  if (userDpr && Array.isArray(userDpr) && userDpr.length >= 2) {
    const [min, max] = userDpr;
    newDpr = MathUtils.clamp(systemDpr, min, max);
  } else if (isNumber(userDpr)) newDpr = userDpr;
  else newDpr = systemDpr;
  if (newDpr !== renderer.getPixelRatio?.()) renderer.setPixelRatio(newDpr);
};
var useCreateRafLoop = (cycleFn) => {
  const clock = new Clock();
  const eventHooks = {
    before: createEventHook(),
    after: createEventHook()
  };
  const { pause, resume, isActive } = useRafFn(() => {
    const getContextWithClock = () => ({
      delta: clock.getDelta(),
      elapsed: clock.elapsedTime
    });
    eventHooks.before.trigger(getContextWithClock());
    cycleFn();
    eventHooks.after.trigger(getContextWithClock());
  }, { immediate: false });
  const start = () => {
    clock.start();
    resume();
  };
  const stop = () => {
    clock.stop();
    pause();
  };
  return {
    start,
    stop,
    isActive,
    onBeforeLoop: eventHooks.before.on,
    onLoop: eventHooks.after.on
  };
};
function useRendererManager({ scene, canvas, options, contextParts: { sizes, camera } }) {
  const getRenderer = () => {
    if (isFunction(options.renderer)) return options.renderer({
      sizes,
      scene,
      camera,
      canvas
    });
    return new WebGLRenderer({
      ...options,
      canvas: unrefElement(canvas)
    });
  };
  const renderer = getRenderer();
  const frames = ref3(toValue2(options.renderMode) === "manual" ? 0 : 1);
  const maxFrames = 60;
  const canBeInvalidated = computed3(() => toValue2(options.renderMode) === "on-demand" && frames.value === 0);
  const forceMaterialUpdate = () => scene.value.traverse((child) => {
    if (child instanceof Mesh6 && child.material instanceof Material) child.material.needsUpdate = true;
  });
  const invalidate = (amountOfFramesToInvalidate = 1) => {
    if (!canBeInvalidated.value) return;
    frames.value = Math.min(maxFrames, frames.value + amountOfFramesToInvalidate);
  };
  const advance = () => {
    if (toValue2(options.renderMode) !== "manual") throw new Error("advance can only be called in manual render mode.");
    frames.value = 1;
  };
  const invalidateOnDemand = () => {
    if (toValue2(options.renderMode) === "on-demand") invalidate();
  };
  const isModeAlways = computed3(() => toValue2(options.renderMode) === "always");
  const isRenderer = (value) => isObject2(value) && "isRenderer" in value && Boolean(value.isRenderer);
  const readyEventHook = createEventHook();
  let hasTriggeredReady = false;
  if (isRenderer(renderer)) {
    renderer.init();
    readyEventHook.trigger(renderer);
  }
  const renderEventHook = createEventHook();
  const notifyFrameRendered = () => {
    frames.value = isModeAlways.value ? 1 : Math.max(0, frames.value - 1);
    renderEventHook.trigger(renderer);
  };
  let renderFunction = (_notifyFrameRendered) => {
    if (camera.activeCamera.value) {
      renderer.render(scene.value, camera.activeCamera.value);
      _notifyFrameRendered();
    }
  };
  const replaceRenderFunction = (fn) => {
    renderFunction = fn;
  };
  const loop = useCreateRafLoop(() => {
    if (frames.value) renderFunction(notifyFrameRendered);
  });
  readyEventHook.on(loop.start);
  watch3([sizes.width, sizes.height], () => {
    renderer.setSize(sizes.width.value, sizes.height.value);
    if (!hasTriggeredReady && renderer.domElement.width && renderer.domElement.height) {
      readyEventHook.trigger(renderer);
      hasTriggeredReady = true;
    }
    invalidateOnDemand();
  }, { immediate: true });
  watchEffect3(() => {
    setPixelRatio(renderer, sizes.pixelRatio.value, toValue2(options.dpr));
  });
  if (toValue2(options.renderMode) === "on-demand") invalidate();
  if (toValue2(options.renderMode) === "manual") useTimeout(100, { callback: advance });
  const clearColorAndAlpha = computed3(() => {
    const clearColor = toValue2(options.clearColor);
    const clearAlpha = toValue2(options.clearAlpha);
    const isClearColorWithAlpha = typeof clearColor === "string" && clearColor.length === 9 && clearColor.startsWith("#");
    if (isClearColorWithAlpha && clearAlpha !== void 0) logWarning(`clearColor with alpha (e.g. ${clearColor}) and clearAlpha cannot both be set, using clearColor as source of truth`);
    if (isClearColorWithAlpha) return {
      alpha: Number.parseInt(clearColor.slice(7, 9), 16) / 255,
      color: clearColor.slice(0, 7)
    };
    return {
      alpha: clearAlpha,
      color: clearColor
    };
  });
  watchEffect3(() => {
    const value = clearColorAndAlpha.value;
    if (value.color === void 0 || value.alpha === void 0) return;
    renderer.setClearColor(value.color, value.alpha);
  });
  watchEffect3(() => {
    const value = options.toneMapping;
    if (value) renderer.toneMapping = value;
  });
  watchEffect3(() => {
    const value = options.toneMappingExposure;
    if (value) renderer.toneMappingExposure = value;
  });
  watchEffect3(() => {
    const value = options.outputColorSpace;
    if (value) renderer.outputColorSpace = value;
  });
  watchEffect3(() => {
    const value = options.shadows;
    if (value === void 0) return;
    renderer.shadowMap.enabled = value;
    forceMaterialUpdate();
  });
  watchEffect3(() => {
    const value = options.shadowMapType;
    if (value === void 0) return;
    renderer.shadowMap.type = value;
    forceMaterialUpdate();
  });
  onUnmounted2(() => {
    renderer.dispose();
    if ("forceContextLoss" in renderer) renderer.forceContextLoss();
  });
  return {
    loop,
    instance: renderer,
    advance,
    onReady: readyEventHook.on,
    onRender: renderEventHook.on,
    invalidate,
    canBeInvalidated,
    mode: toValue2(options.renderMode),
    replaceRenderFunction
  };
}
function useSizes(windowSize, canvas, debounceMs = 10) {
  const { pixelRatio } = useDevicePixelRatio();
  const reactiveSize = toValue2(windowSize) ? useWindowSize() : useElementSize(computed3(() => toValue2(canvas).parentElement));
  const debouncedReactiveWidth = readonly3(refDebounced(reactiveSize.width, debounceMs));
  const debouncedReactiveHeight = readonly3(refDebounced(reactiveSize.height, debounceMs));
  return {
    width: debouncedReactiveWidth,
    height: debouncedReactiveHeight,
    pixelRatio,
    aspectRatio: computed3(() => debouncedReactiveWidth.value / debouncedReactiveHeight.value)
  };
}
function useEventManager({ canvas, contextParts: { scene, camera, renderer } }) {
  const { update: update2, destroy } = forwardHtmlEvents(toValue2(canvas), () => toValue2(camera.activeCamera), scene.value);
  const { off } = renderer.loop.onLoop(update2);
  onUnmounted2(destroy);
  onUnmounted2(off);
  const voidObject = getVoidObject(scene.value);
  const pointerMissedEventHook = createEventHook();
  voidObject.addEventListener("click", pointerMissedEventHook.trigger);
  return { onPointerMissed: pointerMissedEventHook.on };
}
var INJECTION_KEY = "useTres";
var [useTresContextProvider, _useTresContext] = createInjectionState(({ scene, canvas, windowSize, rendererOptions }) => {
  const localScene = shallowRef3(scene);
  const sizes = useSizes(windowSize, canvas);
  const camera = useCameraManager({ sizes });
  const renderer = useRendererManager({
    scene: localScene,
    canvas,
    options: rendererOptions,
    contextParts: {
      sizes,
      camera
    }
  });
  const events = useEventManager({
    canvas,
    contextParts: {
      scene: localScene,
      camera,
      renderer
    }
  });
  const ctx = {
    sizes,
    scene: localScene,
    camera,
    renderer,
    controls: ref3(null),
    extend,
    events
  };
  ctx.scene.value.__tres = { root: ctx };
  return ctx;
}, { injectionKey: "useTres" });
var useTresContext = () => {
  const ctx = _useTresContext();
  if (!ctx) throw new Error("useTresContext must be used together with useTresContextProvider.\n You probably tried to use it above or on the same level as a TresCanvas component.\n It should be used in child components of a TresCanvas instance.");
  return ctx;
};
function useTres() {
  const { scene, renderer, camera, sizes, controls, extend: extend$1, events } = useTresContext();
  return {
    scene,
    renderer: renderer.instance,
    camera: camera.activeCamera,
    sizes,
    controls,
    extend: extend$1,
    events,
    invalidate: renderer.invalidate,
    advance: renderer.advance
  };
}
var useLoop = () => {
  const tresContext = useTres();
  const { renderer: rendererManager } = useTresContext();
  const eventHookBeforeRender = createPriorityEventHook();
  const eventHookAfterRender = createPriorityEventHook();
  rendererManager.loop.onBeforeLoop((loopContext) => {
    eventHookBeforeRender.trigger({
      ...tresContext,
      ...loopContext
    });
  });
  rendererManager.loop.onLoop((loopContext) => {
    eventHookAfterRender.trigger({
      ...tresContext,
      ...loopContext
    });
  });
  const render = rendererManager.replaceRenderFunction;
  return {
    stop: rendererManager.loop.stop,
    start: rendererManager.loop.start,
    isActive: rendererManager.loop.isActive,
    onBeforeRender: eventHookBeforeRender.on,
    onRender: eventHookAfterRender.on,
    render
  };
};
function createRetargetingProxy(target2, getters = {}, setters = {}) {
  let _target = target2;
  const setTarget = (newTarget) => {
    _target = newTarget;
  };
  let proxy = new Proxy({}, {});
  proxy = new Proxy({}, {
    has(_, key) {
      return key in getters || key in _target;
    },
    get(_, prop, __) {
      if (prop in getters) return getters[prop](_target);
      return _target[prop];
    },
    set(_, prop, val) {
      if (setters[prop]) setters[prop](val, _target, proxy, setTarget);
      else _target[prop] = val;
      return true;
    }
  });
  return proxy;
}
var supportedPointerEvents = [
  "onClick",
  "onContextmenu",
  "onPointermove",
  "onPointerenter",
  "onPointerleave",
  "onPointerover",
  "onPointerout",
  "onDblclick",
  "onPointerdown",
  "onPointerup",
  "onPointercancel",
  "onLostpointercapture",
  "onWheel"
];
var pointerEventsMapVueToThree = {
  onClick: "click",
  onContextmenu: "contextmenu",
  onPointermove: "pointermove",
  onPointerenter: "pointerenter",
  onPointerleave: "pointerleave",
  onPointerover: "pointerover",
  onPointerout: "pointerout",
  onDblclick: "dblclick",
  onPointerdown: "pointerdown",
  onPointerup: "pointerup",
  onPointercancel: "pointercancel",
  onLostpointercapture: "lostpointercapture",
  onWheel: "wheel"
};
var isSupportedPointerEvent = (event) => supportedPointerEvents.includes(event);
var nodeOps = ({ context, options = { primitivePrefix: "" } }) => {
  const scene = context.scene.value;
  function createElement(tag, _isSVG, _anchor, props) {
    if (!props) props = {};
    if (!props.args) props.args = [];
    if (isHTMLTag(tag)) return null;
    if (tag.includes("-")) tag = tag.replace(/-([a-z])/g, (_, c) => c.toUpperCase()).replace(/^[a-z]/, (c) => c.toUpperCase());
    let name = tag.replace("Tres", "");
    let obj;
    if (tag === `${options?.primitivePrefix ?? ""}primitive`) {
      if (!isObject2(props.object) || isRef4(props.object)) logError("Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>");
      name = props.object.type;
      const __tres = {};
      obj = createRetargetingProxy(props.object, {
        object: (t) => t,
        isPrimitive: () => true,
        __tres: () => __tres
      }, {
        object: (object, _, primitive, setTarget) => {
          setPrimitiveObject(object, primitive, setTarget, {
            patchProp,
            remove,
            insert
          }, context);
        },
        __tres: (t) => {
          Object.assign(__tres, t);
        }
      });
    } else {
      const target2 = catalogue.value[name];
      if (!target2) logError(`${name} is not defined on the THREE namespace. Use extend to add it to the catalog.`);
      obj = new target2(...props.args);
    }
    if (!obj) return null;
    if (isTresCamera(obj)) {
      if (!props?.position) obj.position.set(3, 3, 3);
      if (!props?.lookAt) obj.lookAt(0, 0, 0);
    }
    obj = prepareTresInstance(obj, {
      ...isTresInstance(obj) ? obj.__tres : {},
      type: name,
      memoizedProps: props,
      primitive: tag === "primitive",
      attach: props.attach
    }, context);
    return obj;
  }
  function insert(child, parent) {
    if (!child) return;
    parent = parent || scene;
    const childInstance = child.__tres ? child : prepareTresInstance(child, {}, context);
    const parentInstance = parent.__tres ? parent : prepareTresInstance(parent, {}, context);
    child = unboxTresPrimitive(childInstance);
    parent = unboxTresPrimitive(parentInstance);
    if (isTresCamera(child)) context.camera?.registerCamera(child);
    if (childInstance.__tres.attach) attach(parentInstance, childInstance, childInstance.__tres.attach);
    else if (isObject3D(child) && isObject3D(parentInstance)) {
      parentInstance.add(child);
      child.dispatchEvent({ type: "added" });
    }
    childInstance.__tres.parent = parentInstance;
    if (parentInstance.__tres.objects && !parentInstance.__tres.objects.includes(childInstance)) parentInstance.__tres.objects.push(childInstance);
  }
  function remove(node, dispose) {
    if (!node) return;
    dispose = isUndefined(dispose) ? "default" : dispose;
    const userDispose = node.__tres?.dispose;
    if (!isUndefined(userDispose)) if (userDispose === null) dispose = false;
    else dispose = userDispose;
    const isPrimitive = node.__tres?.primitive;
    const shouldDispose = dispose === "default" ? !isPrimitive : !!dispose;
    if (node.__tres && "objects" in node.__tres) [...node.__tres.objects].forEach((obj) => remove(obj, dispose));
    if (shouldDispose) {
      if (node.children) [...node.children].forEach((child) => remove(child, dispose));
    }
    doRemoveDetach(node, context);
    doRemoveDeregister(node, context);
    if (shouldDispose && !isScene(node)) {
      if (isFunction(dispose)) dispose(node);
      else if (isFunction(node.dispose)) try {
        node.dispose();
      } catch (e) {
      }
    }
    if ("__tres" in node) delete node.__tres;
  }
  function patchProp(node, prop, prevValue, nextValue) {
    if (!node) return;
    let root = node;
    const key = prop;
    if (node.__tres) node.__tres.memoizedProps[prop] = nextValue;
    if (prop === "attach") {
      const maybeParent = node.__tres?.parent || node.parent;
      remove(node);
      prepareTresInstance(node, { attach: nextValue }, context);
      if (maybeParent) insert(node, maybeParent);
      return;
    }
    if (prop === "dispose") {
      if (!node.__tres) node = prepareTresInstance(node, {}, context);
      node.__tres.dispose = nextValue;
      return;
    }
    if (isSupportedPointerEvent(prop) && isFunction(nextValue)) node.addEventListener(pointerEventsMapVueToThree[prop], nextValue);
    let finalKey = camel(key);
    let target2 = root?.[finalKey];
    if (key === "args") {
      const prevNode = node;
      const prevArgs = prevValue ?? [];
      const args = nextValue ?? [];
      const instanceName = node.__tres?.type || node.type;
      if (instanceName && prevArgs.length && !isEqual(prevArgs, args)) {
        const newInstance = new catalogue.value[instanceName](...nextValue);
        const descriptors = Object.getOwnPropertyDescriptors(newInstance);
        Object.entries(descriptors).forEach(([key$1, descriptor]) => {
          if (!descriptor.writable && !descriptor.set) return;
          if (key$1 in prevNode) try {
            prevNode[key$1] = newInstance[key$1];
          } catch (e) {
            console.warn(`Could not set property ${key$1} on ${instanceName}:`, e);
          }
        });
        root = prevNode;
      }
      return;
    }
    if (root.type === "BufferGeometry") {
      if (key === "args") return;
      root.setAttribute(camel(key), new BufferAttribute2(...nextValue));
      return;
    }
    if (key.includes("-") && target2 === void 0) {
      const resolved = resolve(root, key);
      target2 = resolved.target;
      root = resolved.target;
      finalKey = resolved.key;
      if (target2 && finalKey) {
        target2[finalKey] = nextValue;
        if (isTresCamera(node)) node.updateProjectionMatrix();
        invalidateInstance(node);
        return;
      }
    }
    let value = nextValue;
    if (value === "") value = true;
    if (isFunction(target2)) {
      if (!isSupportedPointerEvent(prop)) if (Array.isArray(value)) node[finalKey](...value);
      else node[finalKey](value);
      if (finalKey.startsWith("on") && isFunction(value)) root[finalKey] = value;
      return;
    }
    if (isLayers(target2) && isLayers(value)) target2.mask = value.mask;
    else if (isColor(target2) && isColorRepresentation(value)) target2.set(value);
    else if (isCopyable(target2) && isClassInstance(value) && target2.constructor === value.constructor) target2.copy(value);
    else if (isVectorLike(target2) && Array.isArray(value)) if ("fromArray" in target2 && typeof target2.fromArray === "function") target2.fromArray(value);
    else target2.set(...value);
    else if (isVectorLike(target2) && typeof value === "number") if ("setScalar" in target2 && typeof target2.setScalar === "function") target2.setScalar(value);
    else target2.set(value);
    else root[finalKey] = value;
    if (isTresCamera(node)) node.updateProjectionMatrix();
    invalidateInstance(node);
  }
  function parentNode(node) {
    return node?.__tres?.parent || null;
  }
  function createComment(comment) {
    const commentObj = prepareTresInstance(new Object3D2(), { type: "Comment" }, context);
    commentObj.name = comment;
    return commentObj;
  }
  function nextSibling(node) {
    const siblings = parentNode(node)?.__tres?.objects || [];
    const index = siblings.indexOf(node);
    if (index < 0 || index >= siblings.length - 1) return null;
    return siblings[index + 1];
  }
  const noop2 = () => {
  };
  return {
    insert,
    remove,
    createElement,
    patchProp,
    parentNode,
    createText: noop2,
    createComment,
    setText: noop2,
    setElementText: noop2,
    nextSibling,
    querySelector: noop2,
    setScopeId: noop2,
    cloneNode: noop2,
    insertStaticContent: noop2
  };
};
var QUEUEABLE_MESSAGE_TYPES = ["asset-load"];
var DevtoolsMessenger = class {
  subscribers = /* @__PURE__ */ new Set();
  messageQueue = [];
  maxQueueSize = 100;
  /**
  * Send a message to devtools subscribers
  * If no subscribers are available, only queueable message types are queued
  */
  send(type, data) {
    const message = {
      type,
      data,
      timestamp: Date.now()
    };
    if (this.subscribers.size > 0) this.subscribers.forEach((subscriber) => subscriber(message));
    else if (QUEUEABLE_MESSAGE_TYPES.includes(type)) this.queueMessage(message);
  }
  /**
  * Queue a message for later delivery
  */
  queueMessage(message) {
    this.messageQueue.push(message);
    if (this.messageQueue.length > this.maxQueueSize) this.messageQueue.shift();
  }
  /**
  * Flush all queued messages to current subscribers
  */
  flushQueue() {
    if (this.messageQueue.length === 0 || this.subscribers.size === 0) return;
    this.messageQueue.forEach((message) => {
      this.subscribers.forEach((subscriber) => subscriber(message));
    });
    this.messageQueue = [];
  }
  /**
  * Subscribe to devtools messages
  * When a new subscriber is added, all queued messages (asset-load events) are immediately delivered
  */
  subscribe(subscriber) {
    this.subscribers.add(subscriber);
    this.flushQueue();
    return () => {
      this.subscribers.delete(subscriber);
    };
  }
  /**
  * Check if there are any subscribers
  */
  get hasSubscribers() {
    return this.subscribers.size > 0;
  }
  /**
  * Get the current queue size
  */
  get queueSize() {
    return this.messageQueue.length;
  }
  /**
  * Clear all queued messages
  */
  clearQueue() {
    this.messageQueue = [];
  }
};
function toastMessage(message, type) {
  const tresMessage = `  ${message}`;
  if (typeof __VUE_DEVTOOLS_TOAST__ === "function") __VUE_DEVTOOLS_TOAST__(tresMessage, type);
  else if (type === "error") console.error(tresMessage);
  else if (type === "warn") console.warn(tresMessage);
  else console.log(tresMessage);
}
function __VUE_DEVTOOLS_TOAST__(tresMessage, type) {
  throw new Error(tresMessage + type);
}
function calculateMemoryUsage(object) {
  let totalMemory = 0;
  object.traverse((node) => {
    if (isMesh(node) && node.type !== "HightlightMesh") {
      const geometry = node.geometry;
      const verticesMemory = geometry.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT;
      const facesMemory = geometry.index ? geometry.index.count * Uint32Array.BYTES_PER_ELEMENT : 0;
      const normalsMemory = geometry.attributes.normal ? geometry.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0;
      const uvsMemory = geometry.attributes.uv ? geometry.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0;
      const geometryMemory = verticesMemory + facesMemory + normalsMemory + uvsMemory;
      totalMemory += geometryMemory;
    }
  });
  return totalMemory;
}
function boundedPush(arr, value, max) {
  arr.push(value);
  if (arr.length > max) arr.shift();
}
function bytesToKB(bytes) {
  return (bytes / 1024).toFixed(2);
}
function setupTresDevtools(ctx) {
  if (!ctx) return;
  if (typeof window !== "undefined" && !window.__TRES__DEVTOOLS__) window.__TRES__DEVTOOLS__ = new DevtoolsMessenger();
  const performanceState = {
    maxFrames: 160,
    fps: {
      value: 0,
      accumulator: []
    },
    memory: {
      currentMem: 0,
      allocatedMem: 0,
      accumulator: []
    }
  };
  const updateInterval = 100;
  const fps = useFps({ every: updateInterval });
  const { isSupported, memory } = useMemory({ interval: updateInterval });
  const maxFrames = 160;
  let lastUpdateTime = performance.now();
  let accumulatedTime = 0;
  const interval = 1;
  const updatePerformanceData = ({ timestamp: timestamp2 }) => {
    if (ctx.scene.value) performanceState.memory.allocatedMem = calculateMemoryUsage(ctx.scene.value);
    if (timestamp2 - lastUpdateTime >= updateInterval) {
      lastUpdateTime = timestamp2;
      boundedPush(performanceState.fps.accumulator, fps.value, maxFrames);
      performanceState.fps.value = fps.value;
      if (isSupported.value && memory.value?.usedJSHeapSize) {
        boundedPush(performanceState.memory.accumulator, memory.value.usedJSHeapSize / 1024 / 1024, maxFrames);
        if (performanceState.memory.accumulator.length > 0) performanceState.memory.currentMem = performanceState.memory.accumulator.reduce((a, b) => a + b, 0) / performanceState.memory.accumulator.length;
      }
    }
  };
  const { pause } = useRafFn(({ delta }) => {
    if (!window.__TRES__DEVTOOLS__) return;
    updatePerformanceData({ timestamp: performance.now() });
    accumulatedTime += delta;
    if (accumulatedTime >= interval) {
      window.__TRES__DEVTOOLS__.send("context", ctx);
      window.__TRES__DEVTOOLS__.send("performance", performanceState);
      accumulatedTime = 0;
    }
  }, { immediate: true });
  onUnmounted2(() => {
    pause();
  });
}
var getObjectByUuid = (node, uuid) => {
  if (node.uuid === uuid) return node;
  for (const child of node.children) {
    const found = getObjectByUuid(child, uuid);
    if (found) return found;
  }
};
var HightlightMesh = class extends THREE.Mesh {
  type = "HightlightMesh";
  createTime;
  constructor(...args) {
    super(...args);
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const time = (Date.now() - this.createTime) / 1e3;
    const scaleFactor = 1 + 0.07 * Math.sin(2.5 * time);
    this.scale.set(scaleFactor, scaleFactor, scaleFactor);
  }
};
var createNode = (object) => {
  const node = {
    id: `scene-${object.uuid}`,
    label: object.type,
    children: [],
    tags: []
  };
  if (object.name !== "") node.tags.push({
    label: object.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const memory = calculateMemoryUsage(object);
  if (memory > 0) node.tags.push({
    label: `${bytesToKB(memory)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  });
  if (object.type.includes("Light")) {
    if (isLight(object)) node.tags.push({
      label: `${object.intensity}`,
      textColor: 9738662,
      backgroundColor: 16316922,
      tooltip: "Intensity"
    });
    node.tags.push({
      label: `#${new Color(object.color).getHexString()}`,
      textColor: 9738662,
      backgroundColor: 16316922,
      tooltip: "Color"
    });
  }
  if (object.type.includes("Camera")) {
    node.tags.push({
      label: `${object.fov}`,
      textColor: 9738662,
      backgroundColor: 16316922,
      tooltip: "Field of view"
    });
    node.tags.push({
      label: `x: ${Math.round(object.position.x)} y: ${Math.round(object.position.y)} z: ${Math.round(object.position.z)}`,
      textColor: 9738662,
      backgroundColor: 16316922,
      tooltip: "Position"
    });
  }
  return node;
};
function createContextNode(key, uuid, parentKey = "") {
  return {
    id: `context-${uuid}-${parentKey ? `${parentKey}.${key}` : key}`,
    label: key,
    children: [],
    tags: []
  };
}
function buildGraph$1(object, node, filter = "") {
  object.children.forEach((child) => {
    if (child.type === "HightlightMesh") return;
    if (filter && !child.type.includes(filter) && !child.name.includes(filter)) return;
    const childNode = createNode(child);
    node.children.push(childNode);
    buildGraph$1(child, childNode, filter);
  });
}
function buildContextGraph(object, node, visited = /* @__PURE__ */ new WeakSet(), depth = 0, maxDepth = 4, contextUuid, parentKey = "") {
  if (depth >= maxDepth || !object || visited.has(object)) return;
  const uuid = depth === 0 ? object?.scene?.value?.uuid || Math.random().toString(36).slice(2, 11) : contextUuid;
  visited.add(object);
  Object.entries(object).forEach(([key, value]) => {
    if (key.startsWith("_") || typeof value === "function") return;
    const chainedKey = parentKey ? `${parentKey}.${key}` : key;
    const childNode = createContextNode(key, uuid, parentKey);
    if (key === "scene") return;
    if (isRef4(value)) {
      childNode.tags.push({
        label: `Ref<${typeof value.value}>`,
        textColor: 4372611,
        backgroundColor: 15793395
      });
      if (value.value && typeof value.value === "object") buildContextGraph(value.value, childNode, visited, depth + 1, maxDepth, uuid, chainedKey);
      else childNode.label = `${key}: ${JSON.stringify(value.value)}`;
    } else if (value && typeof value === "object" && !Array.isArray(value)) if (Object.keys(value).length > 0) if (visited.has(value)) childNode.tags.push({
      label: "Circular",
      textColor: 16711680,
      backgroundColor: 16773360
    });
    else buildContextGraph(value, childNode, visited, depth + 1, maxDepth, uuid, chainedKey);
    else childNode.label = `${key}: {}`;
    else if (Array.isArray(value)) {
      childNode.label = `${key}: Array(${value.length})`;
      childNode.tags.push({
        label: `length: ${value.length}`,
        textColor: 9738662,
        backgroundColor: 16316922
      });
    } else childNode.label = `${key}: ${JSON.stringify(value)}`;
    node.children.push(childNode);
  });
}
var inspectorTreeHandler = (tres) => (payload) => {
  if (payload.inspectorId === INSPECTOR_ID) {
    const root = createNode(tres.scene.value);
    buildGraph$1(tres.scene.value, root, payload.filter);
    const rootContext = {
      id: "context-root",
      label: "Context",
      children: [],
      tags: []
    };
    buildContextGraph(tres, rootContext);
    payload.rootNodes = [root, rootContext];
  }
};
var inspectorStateHandler = (tres, { highlightMesh, prevInstance }) => (payload) => {
  if (payload.inspectorId !== INSPECTOR_ID) return;
  const highlightMaterial = new MeshBasicMaterial({
    color: 11003607,
    transparent: true,
    opacity: 0.2,
    depthTest: false,
    side: DoubleSide
  });
  if (payload.nodeId.includes("scene")) {
    const match = payload.nodeId.match(/^scene-(.+)$/);
    const uuid = match ? match[1] : null;
    if (!uuid) return;
    const [instance] = tres.scene.value.getObjectsByProperty("uuid", uuid);
    if (!instance) return;
    if (prevInstance && highlightMesh && highlightMesh.parent) prevInstance.remove(highlightMesh);
    if (isMesh(instance)) {
      const newHighlightMesh = new HightlightMesh(instance.geometry.clone(), highlightMaterial);
      instance.add(newHighlightMesh);
      highlightMesh = newHighlightMesh;
      prevInstance = instance;
    }
    payload.state = { object: Object.entries(instance).map(([key, value]) => {
      if (key === "children") return {
        key,
        value: value.filter((child) => child.type !== "HightlightMesh")
      };
      return {
        key,
        value,
        editable: true
      };
    }).filter(({ key }) => {
      return key !== "parent";
    }) };
    if (isScene(instance)) {
      const sceneState = {
        ...payload.state,
        state: [{
          key: "Scene Info",
          value: {
            objects: instance.children.length,
            memory: calculateMemoryUsage(instance),
            calls: tres.renderer.instance.info.render.calls,
            triangles: tres.renderer.instance.info.render.triangles,
            points: tres.renderer.instance.info.render.points,
            lines: tres.renderer.instance.info.render.lines
          }
        }]
      };
      if ("programs" in tres.renderer.instance.info) sceneState.state.push({
        key: "Programs",
        value: tres.renderer.instance.info.programs?.map((program) => ({
          ...program,
          programName: program.name
        }))
      });
      payload.state = sceneState;
    }
  } else if (payload.nodeId.includes("context")) {
    const match = payload.nodeId.match(/^context-([^-]+(?:-[^-]+)*)-(.+)$/);
    const chainedKey = match ? match[2] : "context";
    if (!chainedKey || chainedKey === "context") {
      payload.state = { object: Object.entries(tres).filter(([key]) => !key.startsWith("_") && key !== "parent").map(([key, value$1]) => ({
        key,
        value: isRef4(value$1) ? value$1.value : value$1,
        editable: false
      })) };
      return;
    }
    const parts = chainedKey.split(".");
    let value = tres;
    for (const part of parts) {
      if (!value || typeof value !== "object") break;
      value = isRef4(value[part]) ? value[part].value : value[part];
    }
    if (value !== void 0) payload.state = { object: Object.entries(value).filter(([key]) => !key.startsWith("_") && key !== "parent").map(([key, val]) => {
      if (isRef4(val)) return {
        key,
        value: val.value,
        editable: false
      };
      if (typeof val === "function") return {
        key,
        value: "()",
        editable: false
      };
      if (val && typeof val === "object") return {
        key,
        value: Array.isArray(val) ? `Array(${val.length})` : "Object",
        editable: false
      };
      return {
        key,
        value: val,
        editable: false
      };
    }) };
  }
};
var editSceneObject = (scene, objectUuid, propertyPath, value) => {
  const targetObject = getObjectByUuid(scene, objectUuid);
  if (!targetObject) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let currentProperty = targetObject;
  for (let i = 0; i < propertyPath.length - 1; i++) if (currentProperty[propertyPath[i]] !== void 0) currentProperty = currentProperty[propertyPath[i]];
  else {
    console.warn(`Property path is not valid: ${propertyPath.join(".")}`);
    return;
  }
  const lastProperty = propertyPath[propertyPath.length - 1];
  if (currentProperty[lastProperty] !== void 0) currentProperty[lastProperty] = value;
  else console.warn(`Property path is not valid: ${propertyPath.join(".")}`);
};
var inspectorEditStateHandler = (tres) => (payload) => {
  if (payload.inspectorId === INSPECTOR_ID) {
    if (payload.nodeId.includes("scene")) {
      const match = payload.nodeId.match(/^scene-(.+)$/);
      const uuid = match ? match[1] : null;
      if (!uuid) return;
      editSceneObject(tres.scene.value, uuid, payload.path, payload.state.value);
    }
  }
};
var INSPECTOR_ID = "tres:inspector";
function registerTresDevtools(app, tres) {
  const pluginDescriptor = {
    id: "dev.esm.tres",
    label: "TresJS ",
    logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
    packageName: "tresjs",
    homepage: "https://docs.tresjs.org",
    app
  };
  const highlightMesh = null;
  const prevInstance = null;
  setupTresDevtools(tres);
  setupDevToolsPlugin(pluginDescriptor, (api) => {
    if (typeof api.now !== "function") toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
    api.addInspector({
      id: INSPECTOR_ID,
      label: "TresJS ",
      icon: "account_tree",
      treeFilterPlaceholder: "Search instances"
    });
    setInterval(() => {
      api.sendInspectorTree(INSPECTOR_ID);
    }, 1e3);
    setInterval(() => {
      api.notifyComponentUpdate();
    }, 5e3);
    api.on.getInspectorTree(inspectorTreeHandler(tres));
    api.on.getInspectorState(inspectorStateHandler(tres, {
      highlightMesh,
      prevInstance
    }));
    api.on.editInspectorState(inspectorEditStateHandler(tres));
  });
}
var Context_vue_vue_type_script_setup_true_lang_default = defineComponent2({
  __name: "Context",
  props: {
    camera: {
      type: null,
      required: false
    },
    windowSize: {
      type: Boolean,
      required: false
    },
    enableProvideBridge: {
      type: Boolean,
      required: false
    },
    customRendererOptions: {
      type: Object,
      required: false
    },
    antialias: {
      type: Boolean,
      required: false
    },
    stencil: {
      type: Boolean,
      required: false
    },
    depth: {
      type: Boolean,
      required: false
    },
    precision: {
      type: String,
      required: false
    },
    logarithmicDepthBuffer: {
      type: Boolean,
      required: false
    },
    preserveDrawingBuffer: {
      type: Boolean,
      required: false
    },
    powerPreference: {
      type: null,
      required: false
    },
    alpha: {
      type: Boolean,
      required: false
    },
    premultipliedAlpha: {
      type: Boolean,
      required: false
    },
    failIfMajorPerformanceCaveat: {
      type: Boolean,
      required: false
    },
    clearColor: {
      type: [
        Object,
        String,
        Number
      ],
      required: false
    },
    clearAlpha: {
      type: Number,
      required: false
    },
    shadows: {
      type: Boolean,
      required: false
    },
    toneMapping: {
      type: null,
      required: false
    },
    shadowMapType: {
      type: null,
      required: false
    },
    useLegacyLights: {
      type: Boolean,
      required: false
    },
    outputColorSpace: {
      type: null,
      required: false
    },
    toneMappingExposure: {
      type: Number,
      required: false
    },
    renderMode: {
      type: String,
      required: false
    },
    dpr: {
      type: [Number, Array],
      required: false
    },
    renderer: {
      type: Function,
      required: false
    },
    canvas: {
      type: null,
      required: true
    }
  },
  emits: [
    "ready",
    "pointermissed",
    "render",
    "beforeLoop",
    "loop",
    "click",
    "contextmenu",
    "pointermove",
    "pointerenter",
    "pointerleave",
    "pointerover",
    "pointerout",
    "dblclick",
    "pointerdown",
    "pointerup",
    "pointercancel",
    "lostpointercapture",
    "wheel"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const slots = useSlots();
    const scene = shallowRef3(new Scene());
    const instance = getCurrentInstance3();
    extend(THREE);
    const createInternalComponent = (context$1, empty = false) => defineComponent2({ setup() {
      const ctx = getCurrentInstance3()?.appContext;
      if (ctx) ctx.app = instance?.appContext.app;
      const provides = {};
      function mergeProvides(currentInstance$1) {
        if (!currentInstance$1) return;
        if (currentInstance$1.parent) mergeProvides(currentInstance$1.parent);
        if (currentInstance$1.provides) Object.assign(provides, currentInstance$1.provides);
      }
      if (instance?.parent && props.enableProvideBridge) {
        mergeProvides(instance.parent);
        Reflect.ownKeys(provides).forEach((key) => {
          provide2(key, provides[key]);
        });
      }
      provide2(INJECTION_KEY, context$1);
      provide2("extend", extend);
      if (typeof window !== "undefined" && ctx?.app) registerTresDevtools(ctx?.app, context$1);
      return () => h2(Fragment2, null, !empty ? slots.default() : []);
    } });
    const mountCustomRenderer = (context$1, empty = false) => {
      const InternalComponent = createInternalComponent(context$1, empty);
      const { render } = createRenderer(nodeOps({
        context: context$1,
        options: props.customRendererOptions
      }));
      render(h2(InternalComponent), scene.value);
    };
    const dispose = (context$1, force = false) => {
      disposeObject3D(context$1.scene.value);
      if (force) {
        context$1.renderer.instance.dispose();
        if (context$1.renderer.instance instanceof WebGLRenderer) {
          context$1.renderer.instance.renderLists.dispose();
          context$1.renderer.instance.forceContextLoss();
        }
      }
      scene.value.__tres = { root: context$1 };
    };
    const context = shallowRef3(useTresContextProvider({
      scene: scene.value,
      canvas: props.canvas,
      windowSize: props.windowSize ?? false,
      rendererOptions: props
    }));
    __expose({
      context,
      dispose: () => dispose(context.value, true)
    });
    const handleHMR = (context$1) => {
      dispose(context$1);
      mountCustomRenderer(context$1);
    };
    const unmountCanvas = () => {
      dispose(context.value);
      mountCustomRenderer(context.value, true);
    };
    const { camera, renderer } = context.value;
    const { registerCamera, cameras, activeCamera, deregisterCamera } = camera;
    mountCustomRenderer(context.value);
    const addDefaultCamera = () => {
      const camera$1 = new PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1e3);
      camera$1.position.set(3, 3, 3);
      camera$1.lookAt(0, 0, 0);
      registerCamera(camera$1);
      const unwatch = watchEffect3(() => {
        if (cameras.value.length >= 2) {
          camera$1.removeFromParent();
          deregisterCamera(camera$1);
          unwatch?.();
        }
      });
    };
    context.value.events.onPointerMissed((event) => {
      emit("pointermissed", event);
    });
    watch3(() => props.camera, (newCamera, oldCamera) => {
      if (newCamera) registerCamera(toValue2(newCamera), true);
      if (oldCamera) {
        toValue2(oldCamera).removeFromParent();
        deregisterCamera(toValue2(oldCamera));
      }
    }, { immediate: true });
    if (!activeCamera.value) addDefaultCamera();
    renderer.onRender(() => {
      if (context.value) emit("render", context.value);
    });
    renderer.loop.onLoop((loopContext) => {
      if (context.value) emit("loop", {
        ...context.value,
        ...loopContext
      });
    });
    renderer.loop.onBeforeLoop((loopContext) => {
      if (context.value) emit("beforeLoop", {
        ...context.value,
        ...loopContext
      });
    });
    renderer.onReady(() => {
      emit("ready", context.value);
    });
    if (import.meta.hot) import.meta.hot.on("vite:afterUpdate", () => handleHMR(context.value));
    onMounted3(async () => {
      await promiseTimeout(3e3);
      if (!context.value.sizes.width || !context.value.sizes.height.value) console.warn(`TresCanvas: The canvas has no area, so nothing can be rendered. Set it manually on the parent element or use the prop windowSize.`);
    });
    onUnmounted2(unmountCanvas);
    return () => {
    };
  }
});
var Context_default = Context_vue_vue_type_script_setup_true_lang_default;
var _hoisted_1 = ["data-scene", "data-tres"];
var TresCanvas_vue_vue_type_script_setup_true_lang_default = defineComponent2({
  __name: "TresCanvas",
  props: {
    camera: {
      type: null,
      required: false
    },
    windowSize: {
      type: Boolean,
      required: false,
      default: void 0
    },
    enableProvideBridge: {
      type: Boolean,
      required: false,
      default: true
    },
    customRendererOptions: {
      type: Object,
      required: false
    },
    antialias: {
      type: Boolean,
      required: false,
      default: true
    },
    stencil: {
      type: Boolean,
      required: false,
      default: void 0
    },
    depth: {
      type: Boolean,
      required: false,
      default: void 0
    },
    precision: {
      type: String,
      required: false
    },
    logarithmicDepthBuffer: {
      type: Boolean,
      required: false,
      default: void 0
    },
    preserveDrawingBuffer: {
      type: Boolean,
      required: false,
      default: void 0
    },
    powerPreference: {
      type: null,
      required: false
    },
    alpha: {
      type: Boolean,
      required: false,
      default: void 0
    },
    premultipliedAlpha: {
      type: Boolean,
      required: false
    },
    failIfMajorPerformanceCaveat: {
      type: Boolean,
      required: false,
      default: void 0
    },
    clearColor: {
      type: [
        Object,
        String,
        Number
      ],
      required: false,
      default: "#000000"
    },
    clearAlpha: {
      type: Number,
      required: false,
      default: 1
    },
    shadows: {
      type: Boolean,
      required: false,
      default: void 0
    },
    toneMapping: {
      type: null,
      required: false,
      default: ACESFilmicToneMapping
    },
    shadowMapType: {
      type: null,
      required: false,
      default: PCFSoftShadowMap
    },
    useLegacyLights: {
      type: Boolean,
      required: false,
      default: void 0
    },
    outputColorSpace: {
      type: null,
      required: false
    },
    toneMappingExposure: {
      type: Number,
      required: false
    },
    renderMode: {
      type: String,
      required: false,
      default: "always"
    },
    dpr: {
      type: [Number, Array],
      required: false
    },
    renderer: {
      type: Function,
      required: false
    }
  },
  emits: [
    "ready",
    "pointermissed",
    "render",
    "beforeLoop",
    "loop",
    "click",
    "contextmenu",
    "pointermove",
    "pointerenter",
    "pointerleave",
    "pointerover",
    "pointerout",
    "dblclick",
    "pointerdown",
    "pointerup",
    "pointercancel",
    "lostpointercapture",
    "wheel"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const canvasRef = ref3();
    const contextRef = shallowRef3();
    __expose({
      get context() {
        return contextRef.value?.context;
      },
      dispose: () => contextRef.value?.dispose()
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("canvas", {
        ref_key: "canvasRef",
        ref: canvasRef,
        "data-scene": contextRef.value?.context?.scene.value.uuid,
        class: normalizeClass(_ctx.$attrs.class),
        "data-tres": `tresjs ${unref3(version)}`,
        style: normalizeStyle({
          display: "block",
          width: "100%",
          height: "100%",
          position: __props.windowSize ? "fixed" : "relative",
          top: 0,
          left: 0,
          pointerEvents: "auto",
          touchAction: "none",
          ..._ctx.$attrs.style
        })
      }, [canvasRef.value ? (openBlock(), createBlock(Context_default, mergeProps({
        key: 0,
        ref_key: "contextRef",
        ref: contextRef,
        canvas: canvasRef.value
      }, props, {
        onReady: _cache[0] || (_cache[0] = ($event) => emit("ready", $event)),
        onPointermissed: _cache[1] || (_cache[1] = ($event) => emit("pointermissed", $event)),
        onRender: _cache[2] || (_cache[2] = ($event) => emit("render", $event)),
        onBeforeLoop: _cache[3] || (_cache[3] = ($event) => emit("beforeLoop", $event)),
        onLoop: _cache[4] || (_cache[4] = ($event) => emit("loop", $event)),
        onClick: _cache[5] || (_cache[5] = ($event) => emit("click", $event)),
        onContextmenu: _cache[6] || (_cache[6] = ($event) => emit("contextmenu", $event)),
        onPointermove: _cache[7] || (_cache[7] = ($event) => emit("pointermove", $event)),
        onPointerenter: _cache[8] || (_cache[8] = ($event) => emit("pointerenter", $event)),
        onPointerleave: _cache[9] || (_cache[9] = ($event) => emit("pointerleave", $event)),
        onPointerover: _cache[10] || (_cache[10] = ($event) => emit("pointerover", $event)),
        onPointerout: _cache[11] || (_cache[11] = ($event) => emit("pointerout", $event)),
        onDblclick: _cache[12] || (_cache[12] = ($event) => emit("dblclick", $event)),
        onPointerdown: _cache[13] || (_cache[13] = ($event) => emit("pointerdown", $event)),
        onPointerup: _cache[14] || (_cache[14] = ($event) => emit("pointerup", $event)),
        onPointercancel: _cache[15] || (_cache[15] = ($event) => emit("pointercancel", $event)),
        onLostpointercapture: _cache[16] || (_cache[16] = ($event) => emit("lostpointercapture", $event)),
        onWheel: _cache[17] || (_cache[17] = ($event) => emit("wheel", $event))
      }), {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["canvas"])) : createCommentVNode("v-if", true)], 14, _hoisted_1);
    };
  }
});
var TresCanvas_default = TresCanvas_vue_vue_type_script_setup_true_lang_default;
function normalizeVectorFlexibleParam(value) {
  if (typeof value === "number") return [
    value,
    value,
    value
  ];
  if (value instanceof Vector36) return [
    value.x,
    value.y,
    value.z
  ];
  return value;
}
function normalizeColor(value) {
  if (value instanceof Color) return value;
  if (Array.isArray(value)) return new Color(...value);
  return new Color(value);
}
var whitelist = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var templateCompilerOptions = { template: { compilerOptions: { isCustomElement: (tag) => (/^Tres[A-Z]/.test(tag) || tag.startsWith("tres-")) && !whitelist.includes(tag) || tag === "primitive" } } };
var template_compiler_options_default = templateCompilerOptions;
var arrowHelper = null;
var vDistanceTo = {
  updated: (el, binding) => {
    const extractBindingPosition = (binding$1) => {
      let observer$1 = binding$1.value;
      if (binding$1.value && isMesh(binding$1.value)) observer$1 = binding$1.value.position;
      if (Array.isArray(binding$1.value)) observer$1 = new Vector36(...observer$1);
      return observer$1;
    };
    const observer = extractBindingPosition(binding);
    if (!observer) {
      logWarning(`v-distance-to: problem with binding value: ${binding.value}`);
      return;
    }
    if (arrowHelper) {
      arrowHelper.dispose();
      el.parent.remove(arrowHelper);
    }
    const dir = observer.clone().sub(el.position);
    dir.normalize();
    arrowHelper = new ArrowHelper(dir, el.position, el.position.distanceTo(observer), 16776960);
    el.parent.add(arrowHelper);
    console.table([
      ["Distance:", el.position.distanceTo(observer)],
      [`origin: ${el.name || el.type}`, `x:${el.position.x}, y:${el.position.y}, z:${el.position?.z}`],
      [`Destiny: ${el.name || el.type}`, `x:${observer.x}, y:${observer.y}, z:${observer?.z}`]
    ]);
  },
  unmounted: (el) => {
    arrowHelper?.dispose();
    if (el.parent) el.parent.remove(arrowHelper);
  }
};
var RectAreaLightHelper = class extends Line {
  constructor(light, color) {
    const positions = [
      1,
      1,
      0,
      -1,
      1,
      0,
      -1,
      -1,
      0,
      1,
      -1,
      0,
      1,
      1,
      0
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    const material = new LineBasicMaterial({ fog: false });
    super(geometry, material);
    this.light = light;
    this.color = color;
    this.type = "RectAreaLightHelper";
    const positions2 = [
      1,
      1,
      0,
      -1,
      1,
      0,
      -1,
      -1,
      0,
      1,
      1,
      0,
      -1,
      -1,
      0,
      1,
      -1,
      0
    ];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh6(geometry2, new MeshBasicMaterial({
      side: BackSide,
      fog: false
    })));
  }
  updateMatrixWorld() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
      this.children[0].material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const c = this.material.color;
      const max = Math.max(c.r, c.g, c.b);
      if (max > 1) c.multiplyScalar(1 / max);
      this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);
    this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
};
var CurrentHelper;
var currentInstance;
var helpers = {
  DirectionalLight: DirectionalLightHelper,
  PointLight: PointLightHelper,
  SpotLight: SpotLightHelper,
  HemisphereLight: HemisphereLightHelper,
  RectAreaLight: RectAreaLightHelper
};
var vLightHelper = {
  mounted: (el) => {
    if (!isLight(el)) {
      logWarning(`${el.type} is not a light`);
      return;
    }
    CurrentHelper = helpers[el.type];
    el.parent?.add(new CurrentHelper(el, 1, el.color.getHex()));
  },
  updated: (el) => {
    currentInstance = el.parent.children.find((child) => child instanceof CurrentHelper);
    if (currentInstance instanceof RectAreaLightHelper) return;
    currentInstance.update();
  },
  unmounted: (el) => {
    if (!el.isLight) {
      logWarning(`${el.type} is not a light`);
      return;
    }
    currentInstance = el.parent.children.find((child) => child instanceof CurrentHelper);
    if (currentInstance && currentInstance.dispose) currentInstance.dispose();
    if (el.parent) el.parent.remove(currentInstance);
  }
};
var vLog = { mounted: (el, binding) => {
  if (binding.arg) {
    console.log(`v-log:${binding.arg}`, el[binding.arg]);
    return;
  }
  console.log("v-log", el);
} };
var plugin = { install(app) {
  app.component("TresCanvas", TresCanvas_default);
} };
var src_default = plugin;
export {
  DevtoolsMessenger,
  TresCanvas_default as TresCanvas,
  component_default as UseLoader,
  buildGraph,
  catalogue,
  src_default as default,
  disposeObject3D as dispose,
  extend,
  isBufferGeometry,
  isCamera,
  isClassInstance,
  isColor,
  isColorRepresentation,
  isCopyable,
  isFog,
  isGroup,
  isLayers,
  isLight,
  isMaterial,
  isMesh,
  isObject3D,
  isOrthographicCamera,
  isPerspectiveCamera,
  isProd,
  isScene,
  isTresCamera,
  isTresInstance,
  isTresObject,
  isTresPrimitive,
  isVectorLike,
  logError,
  logMessage,
  logWarning,
  normalizeColor,
  normalizeVectorFlexibleParam,
  registerTresDevtools,
  template_compiler_options_default as templateCompilerOptions,
  useCameraManager,
  useGraph,
  useLoader,
  useLoop,
  useRendererManager,
  useTres,
  useTresContext,
  useTresContextProvider,
  vDistanceTo,
  vLightHelper,
  vLog
};
//# sourceMappingURL=@tresjs_core.js.map
