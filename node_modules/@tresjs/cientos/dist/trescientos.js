/**
  * name: @tresjs/cientos
  * version: v5.2.3
  * (c) 2026
  * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
import { Fragment, Suspense, computed, createBlock, createCommentVNode, createElementBlock, createElementVNode, createVNode, defineComponent, inject, isReactive, isRef, mergeProps, nextTick, normalizeProps, onBeforeUnmount, onMounted, onUnmounted, openBlock, provide, reactive, ref, render, renderList, renderSlot, shallowReactive, shallowRef, toRaw, toRefs, toValue, triggerRef, unref, useAttrs, useSlots, watch, watchEffect, withAsyncContext, withCtx } from "vue";
import { buildGraph, extend, logError, logWarning, normalizeColor, normalizeVectorFlexibleParam, useLoader, useLoop, useTres, useTresContext } from "@tresjs/core";
import * as THREE from "three";
import { AdditiveBlending, AlwaysStencilFunc, AnimationMixer, Audio, AudioListener, AudioLoader, BackSide, Box2, Box3, BoxGeometry, BufferAttribute, BufferGeometry, Camera, CatmullRomCurve3, ClampToEdgeWrapping, Clock, Color, CubeCamera, CubeReflectionMapping, CubeTextureLoader, CubicBezierCurve3, DataTexture, DefaultLoadingManager, DepthTexture, DirectionalLight, DoubleSide, EdgesGeometry, EqualStencilFunc, EquirectangularReflectionMapping, Euler, FloatType, FramebufferTexture, FrontSide, Group, HalfFloatType, IcosahedronGeometry, InstancedMesh, InterleavedBuffer, InterleavedBufferAttribute, KeepStencilOp, LOD, LinearFilter, MOUSE, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshLambertMaterial, MeshStandardMaterial, NearestFilter, NoBlending, NotEqualStencilFunc, Object3D, OrthographicCamera, PerspectiveCamera, Plane, PlaneGeometry, Points, PointsMaterial, QuadraticBezierCurve3, Quaternion, REVISION, RGBAFormat, RawShaderMaterial, Raycaster, RepeatWrapping, ReplaceStencilOp, Scene, ShaderChunk, ShaderMaterial, ShapeGeometry, SkinnedMesh, Sphere, Spherical, TOUCH, TangentSpaceNormalMap, Texture, TextureLoader, UVMapping, Uniform, UniformsUtils, UnsignedByteType, Vector2, Vector3, Vector4, VideoTexture, WebGLCubeRenderTarget, WebGLRenderTarget, WebGLRenderer } from "three";
import { tryOnScopeDispose, useDebounceFn, useElementSize, useEventListener, useMagicKeys, useMouse, useScroll, useWindowScroll, useWindowSize, watchThrottled, whenever } from "@vueuse/core";
import { DRACOLoader, FBXLoader, FontLoader, GLTFExporter, GLTFLoader, HorizontalBlurShader, Line2, LineGeometry, LineMaterial, MapControls, MarchingCubes, MeshSurfaceSampler, OrbitControls, PointerLockControls, PositionalAudioHelper, RGBELoader, Reflector, RoundedBoxGeometry, SVGLoader, SimplexNoise, Sky, TextGeometry, TransformControls, VerticalBlurShader, Water, toCreasedNormals } from "three-stdlib";
import BaseCameraControls, { default as CameraControls } from "camera-controls";
import CustomShaderMaterial from "three-custom-shader-material/vanilla";
import StatsImpl from "stats.js";
import StatsGlImpl from "stats-gl";

//#region src/core/abstractions/AnimatedSprite/AtlasAnimationDefinitionParser.ts
/**
* Expand an animation definition string into an array of numbers.
* @param definitionStr - A comma-separated string of frame numbers with optional parentheses-surrounded durations.
* @example - expand("0,2") === [0,2]
* @example - expand("2(10)") === [2,2,2,2,2,2,2,2,2,2]
* @example - expand("1-4") === [1,2,3,4]
* @example - expand("10-5(2)") === [10,10,9,9,8,8,7,7,6,6,5,5]
* @example - expand("1-4(3),10(2)") === [1,1,1,2,2,2,3,3,3,4,4,4,10,10]
*/
function expand(definitionStr) {
	const parsed = parse(definitionStr);
	const result = [];
	for (const { startFrame, endFrame, duration } of parsed) if (duration <= 0) continue;
	else if (endFrame < 0 || startFrame === endFrame) {
		for (let _ = 0; _ < duration; _++) result.push(startFrame);
		continue;
	} else {
		const sign = Math.sign(endFrame - startFrame);
		for (let frame = startFrame; frame !== endFrame + sign; frame += sign) for (let _ = 0; _ < duration; _++) result.push(frame);
	}
	return result;
}
/**
* Parse an animation defintion string into an array of AnimationDefinition.
* @param definitionStr - A comma-separated string of frame numbers with optional parentheses-surrounded durations.
* @example - parse("0,2") === [{startFrame:0, endFrame:0, duration:1}, {startFrame:2, endFrame:2, duration:1}]
* @example - parse("2(10)") === [{startFrame:2, endFrame:2, duration:10}]
* @example - parse("1-4") === [{startFrame:1, endFrame:4, duration:1}]
* @example - parse("10-5(2)") === [{startFrame:10, endFrame:5, duration:2}]
* @example - parse("1-4(3),10(2)") === [{startFrame:1, endFrame:4, duration:3}, {startFrame:10, endFrame:10, duration:2}]
*/
function parse(definitionStr) {
	let transition = "START_FRAME_IN";
	const result = [];
	for (const { name, value, startI } of tokenize(definitionStr)) if (transition === "START_FRAME_IN") if (name === "NUMBER") {
		result.push({
			startFrame: value,
			endFrame: value,
			duration: 1
		});
		transition = "START_FRAME_OUT";
	} else logDefinitionSyntaxError("number", name, definitionStr, startI);
	else if (transition === "START_FRAME_OUT") if (name === "COMMA") transition = "START_FRAME_IN";
	else if (name === "HYPHEN") transition = "END_FRAME_IN";
	else if (name === "OPEN_PAREN") transition = "DURATION_IN";
	else logDefinitionSyntaxError("\",\", \"-\", \"(\"", name, definitionStr, startI);
	else if (transition === "END_FRAME_IN") if (name === "NUMBER") {
		result[result.length - 1].endFrame = value;
		transition = "END_FRAME_OUT";
	} else logDefinitionSyntaxError("number", name, definitionStr, startI);
	else if (transition === "END_FRAME_OUT") if (name === "COMMA") transition = "START_FRAME_IN";
	else if (name === "OPEN_PAREN") transition = "DURATION_IN";
	else logDefinitionSyntaxError("',' or '('", name, definitionStr, startI);
	else if (transition === "DURATION_IN") if (name === "NUMBER") {
		result[result.length - 1].duration = value;
		transition = "DURATION_OUT";
	} else logDefinitionSyntaxError("number", name, definitionStr, startI);
	else if (transition === "DURATION_OUT") if (name === "CLOSE_PAREN") transition = "NEXT_OR_DONE";
	else logDefinitionSyntaxError("\"(\"", name, definitionStr, startI);
	else if (transition === "NEXT_OR_DONE") if (name === "COMMA") transition = "START_FRAME_IN";
	else logDefinitionSyntaxError("\",\"", name, definitionStr, startI);
	return result;
}
function tokenize(definition) {
	const result = [];
	for (let ii = 0; ii < definition.length; ii++) {
		const c = definition[ii];
		if ("0123456789".includes(c)) if (result.length && result[result.length - 1].name === "NUMBER") {
			result[result.length - 1].value *= 10;
			result[result.length - 1].value += Number.parseInt(c);
		} else result.push({
			name: "NUMBER",
			value: Number.parseInt(c),
			startI: ii
		});
		else if (c === " ") continue;
		else if (c === ",") result.push({
			name: "COMMA",
			value: -1,
			startI: ii
		});
		else if (c === "(") result.push({
			name: "OPEN_PAREN",
			value: -1,
			startI: ii
		});
		else if (c === ")") result.push({
			name: "CLOSE_PAREN",
			value: -1,
			startI: ii
		});
		else if (c === "-") result.push({
			name: "HYPHEN",
			value: -1,
			startI: ii
		});
		else logDefinitionBadCharacter("0123456789,-()", c, definition, ii);
	}
	return result;
}
function logDefinitionBadCharacter(expected, found, definition, index) {
	logError(`Cientos AnimationDefinitionParser: Unexpected character while processing animation definition: expected ${expected}, got ${found}.
${definition}
${Array.from({ length: index + 1 }).join(" ")}^`);
}
function logDefinitionSyntaxError(expected, found, definition, index) {
	logError(`Cientos AnimationDefinitionParser: Syntax error while processing animation definition: expected ${expected}, got ${found}.
${definition}
${Array.from({ length: index + 1 }).join(" ")}^`);
}

//#endregion
//#region src/core/abstractions/AnimatedSprite/StringOps.ts
const numbersAtEnd = /\d*$/;
const underscoresNumbersAtEnd = /_*\d*$/;
function stripUnderscoresNumbersFromEnd(str) {
	return str.replace(underscoresNumbersAtEnd, "");
}
function getNumbersFromEnd(str) {
	const matches = str.match(numbersAtEnd);
	if (matches) return Number.parseInt(matches[matches.length - 1]);
	return null;
}

//#endregion
//#region src/core/abstractions/AnimatedSprite/Atlas.ts
async function getTextureAndAtlasAsync(imagePathOrImageData, atlasPathOrAtlasish) {
	const loader = new TextureLoader();
	const texturePromise = new Promise((resolve, reject) => {
		loader.load(imagePathOrImageData, resolve, void 0, reject);
	});
	const atlasishPromise = typeof atlasPathOrAtlasish !== "string" ? new Promise((resolve) => resolve(atlasPathOrAtlasish)) : fetch(atlasPathOrAtlasish).then((response) => response.json()).catch((e) => logError(`Cientos Atlas - ${e}`));
	return Promise.all([texturePromise, atlasishPromise]).then(([texture$1, atlasish]) => {
		return [texture$1, getAtlas(atlasish, texture$1.image.width, texture$1.image.height)];
	});
}
function getAtlas(atlasish, textureWidth, textureHeight) {
	const frames = typeof atlasish === "number" || Array.isArray(atlasish) ? getAtlasFramesFromNumColsNumRows(atlasish, textureWidth, textureHeight) : getAtlasFramesFromTexturePackerData(atlasish, textureWidth, textureHeight);
	return {
		frames,
		animations: groupAtlasFramesByKey(frames)
	};
}
function getAtlasFrames(atlas, animationNameOrFrameNumber, reversed) {
	let frames;
	if (typeof animationNameOrFrameNumber === "string") frames = getAtlasFramesByAnimationName(atlas, animationNameOrFrameNumber);
	else if (typeof animationNameOrFrameNumber === "number") frames = getAtlasFramesByIndices(atlas, animationNameOrFrameNumber, animationNameOrFrameNumber);
	else frames = getAtlasFramesByIndices(atlas, animationNameOrFrameNumber[0], animationNameOrFrameNumber[1]);
	return reversed ? frames.toReversed() : frames;
}
function getNullAtlasFrame() {
	return {
		name: "null",
		width: 0,
		height: 0,
		offsetX: 0,
		offsetY: 0,
		repeatX: 0,
		repeatY: 0
	};
}
function getAtlasFramesFromTexturePackerData(data, width, height) {
	return Array.isArray(data.frames) ? getAtlasFramesFromTexturePackerDataArray(data, width, height) : getAtlasFramesFromTexturePackerDataObject(data, width, height);
}
function getAtlasFramesFromTexturePackerDataArray(data, width, height) {
	const invWidth = 1 / width;
	const invHeight = 1 / height;
	return data.frames.map((d) => ({
		name: d.filename,
		offsetX: d.frame.x * invWidth,
		offsetY: 1 - (d.frame.y + d.frame.h) * invHeight,
		repeatX: d.frame.w * invWidth,
		repeatY: d.frame.h * invHeight,
		width: d.frame.w,
		height: d.frame.h
	}));
}
function getAtlasFramesFromTexturePackerDataObject(data, width, height) {
	const invWidth = 1 / width;
	const invHeight = 1 / height;
	return Object.entries(data.frames).map(([k, v]) => ({
		name: k,
		offsetX: v.frame.x * invWidth,
		offsetY: 1 - (v.frame.y + v.frame.h) * invHeight,
		repeatX: v.frame.w * invWidth,
		repeatY: v.frame.h * invHeight,
		width: v.frame.w,
		height: v.frame.h
	}));
}
function getAtlasFramesFromNumColsNumRows(numColsOrNumColsNumRows, width, height, name = "default") {
	const [numCols, numRows] = Array.isArray(numColsOrNumColsNumRows) ? numColsOrNumColsNumRows : [numColsOrNumColsNumRows, 1];
	const frameWidth = width / numCols;
	const frameHeight = height / numRows;
	const padAmount = (numCols * numRows).toString().length;
	const repeatX = 1 / numCols;
	const repeatY = 1 / numRows;
	const result = [];
	let i = 0;
	for (let row = numRows - 1; row >= 0; row--) for (let col = 0; col < numCols; col++) {
		i++;
		result.push({
			name: name + String(i).padStart(padAmount, "0"),
			offsetX: col * repeatX,
			offsetY: row * repeatY,
			repeatX,
			repeatY,
			width: frameWidth,
			height: frameHeight
		});
	}
	return result;
}
function setAtlasDefinitions(atlas, definitions = {}) {
	const animations = groupAtlasFramesByKey(atlas.frames);
	for (const [animationName, definitionStr] of Object.entries(definitions)) {
		const frames = getAtlasFrames(atlas, animationName, false);
		const expandedFrameIndices = expand(definitionStr);
		for (const frameIndex of expandedFrameIndices) if (frameIndex < 0 || frames.length <= frameIndex) logError(`Cientos Atlas: Attempting to access frame index ${frameIndex} in animation ${animationName}, but it does not exist.`);
		animations[animationName] = expandedFrameIndices.map((frameIndex) => frames[frameIndex]);
	}
	atlas.animations = animations;
}
function getAtlasFramesByAnimationName(atlas, name) {
	if (!(name in atlas.animations)) {
		logError(`Cientos Atlas: getAtlasFramesByAnimationName
The animation name "${name}" does not exist in this atlas.
Available names:
${Object.keys(atlas.animations).map((n) => `* ${n}\n`).join("")}`);
		return [getNullAtlasFrame()];
	}
	return atlas.animations[name];
}
function getAtlasFramesByIndices(atlas, startI, endI) {
	if (startI < 0 || atlas.frames.length <= startI || endI < 0 || atlas.frames.length <= endI) {
		logError(`Cientos Atlas: getFramesByIndex â€“ [${startI}, ${endI}] is out of bounds.`);
		return [getNullAtlasFrame()];
	}
	const result = [];
	const sign = Math.sign(endI - startI);
	if (sign === 0) return [atlas.frames[startI]];
	for (let i = startI; i !== endI + sign; i += sign) result.push(atlas.frames[i]);
	return result;
}
/**
* @returns An object where all AtlasFrames with the same key are grouped in an ordered array by name in ascending value.
* A key is defined as an alphanumeric string preceding a trailing numeric string.
* E.g.:
* "hero0Idle" has no key as it does not have trailing numeric string.
* "heroIdle0" has the key "heroIdle".
* @example ```
* groupFramesByKey([{name: hero, ...}, {name: heroJump3, ...}, {name: heroJump0, ...}, {name: heroIdle0, ...}, {name: heroIdle1, ...}]) returns
* {
* heroJump: [{name: heroJump0, ...}, {name: heroJump3, ...}],
* heroIdle: [{name: heroIdle0, ...}, {name: heroIdle1, ...}]
* }
* ```
*/
function groupAtlasFramesByKey(frames) {
	const result = {};
	for (const frame of frames) if (getNumbersFromEnd(frame.name) !== null) {
		const key = stripUnderscoresNumbersFromEnd(frame.name);
		if (Object.prototype.hasOwnProperty.call(result, key)) result[key].push(frame);
		else result[key] = [frame];
	}
	for (const entry of Object.values(result)) entry.sort((a, b) => a.name.localeCompare(b.name));
	return result;
}

//#endregion
//#region src/core/abstractions/AnimatedSprite/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$57 = ["scale", "position"];
const _hoisted_2$27 = ["map", "alphaTest"];
const _hoisted_3$5 = ["scale", "position"];
const _hoisted_4$3 = [
	"side",
	"map",
	"alphaTest",
	"depthWrite",
	"depthTest"
];
const TEXTURE_PX_TO_WORLD_UNITS = .01;
var component_vue_vue_type_script_setup_true_lang_default$18 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		image: {
			type: String,
			required: true
		},
		atlas: {
			type: [
				String,
				Object,
				Array,
				Number
			],
			required: true
		},
		definitions: {
			type: Object,
			required: false
		},
		fps: {
			type: Number,
			required: false,
			default: 30
		},
		loop: {
			type: Boolean,
			required: false,
			default: true
		},
		animation: {
			type: [
				String,
				Array,
				Number
			],
			required: false,
			default: 0
		},
		paused: {
			type: Boolean,
			required: false,
			default: false
		},
		reversed: {
			type: Boolean,
			required: false,
			default: false
		},
		flipX: {
			type: Boolean,
			required: false,
			default: false
		},
		resetOnEnd: {
			type: Boolean,
			required: false,
			default: false
		},
		asSprite: {
			type: Boolean,
			required: false,
			default: true
		},
		center: {
			type: null,
			required: false,
			default: () => [.5, .5]
		},
		alphaTest: {
			type: Number,
			required: false,
			default: 0
		},
		depthTest: {
			type: Boolean,
			required: false,
			default: true
		},
		depthWrite: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	emits: [
		"frame",
		"end",
		"loop"
	],
	async setup(__props, { expose: __expose, emit: __emit }) {
		let __temp, __restore;
		const props = __props;
		const emit = __emit;
		const { invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const positionX = ref(0);
		const positionY = ref(0);
		const scaleX = ref(0);
		const scaleY = ref(0);
		const groupRef = shallowRef();
		__expose({ instance: groupRef });
		const [textureResult, atlas] = ([__temp, __restore] = withAsyncContext(() => getTextureAndAtlasAsync(props.image, props.atlas)), __temp = await __temp, __restore(), __temp);
		const texture$1 = Array.isArray(textureResult) ? textureResult[0] : textureResult;
		texture$1.matrixAutoUpdate = false;
		let animation = getAtlasFrames(atlas, props.animation, props.reversed);
		let centerX = .5;
		let centerY = .5;
		let cooldown = 1;
		let frame = getNullAtlasFrame();
		let frameNameToEmit = null;
		let frameNum = 0;
		let frameHeldOnLoopEnd = false;
		let dirtyFlag = true;
		useLoop().onBeforeRender(({ delta }) => {
			if (!props.paused && !frameHeldOnLoopEnd) cooldown -= delta * props.fps;
			while (cooldown <= 0) {
				cooldown++;
				frameNum++;
				if (props.loop) {
					if (frameNum >= animation.length) emit("loop", animation[animation.length - 1].name);
					frameNum %= animation.length;
				} else if (frameNum >= animation.length) {
					frameHeldOnLoopEnd = true;
					frameNum = props.resetOnEnd ? 0 : animation.length - 1;
					emit("end", animation[animation.length - 1].name);
				}
			}
			if (animation[frameNum] !== frame) {
				frame = animation[frameNum];
				frameNameToEmit = frame.name;
				render$1();
			}
			if (dirtyFlag) {
				dirtyFlag = false;
				texture$1.offset.x = frame.offsetX + (props.flipX ? frame.repeatX : 0);
				texture$1.offset.y = frame.offsetY;
				texture$1.repeat.x = frame.repeatX * (props.flipX ? -1 : 1);
				texture$1.repeat.y = frame.repeatY;
				texture$1.updateMatrix();
				scaleX.value = frame.width * TEXTURE_PX_TO_WORLD_UNITS;
				scaleY.value = frame.height * TEXTURE_PX_TO_WORLD_UNITS;
				positionX.value = (.5 - centerX) * frame.width * TEXTURE_PX_TO_WORLD_UNITS;
				positionY.value = (.5 - centerY) * frame.height * TEXTURE_PX_TO_WORLD_UNITS;
			}
			if (frameNameToEmit) {
				emit("frame", frameNameToEmit);
				frameNameToEmit = null;
			}
		});
		function render$1() {
			dirtyFlag = true;
		}
		watch(() => props.animation, (newValue, oldValue) => {
			if (JSON.stringify(newValue) === JSON.stringify(oldValue)) return;
			animation = getAtlasFrames(atlas, props.animation, props.reversed);
			frameNum = 0;
			cooldown = 1;
			frameHeldOnLoopEnd = false;
			render$1();
		}, { immediate: true });
		watch(() => props.reversed, () => {
			frameNum = (animation.length - frameNum - 1) % animation.length;
			animation = getAtlasFrames(atlas, props.animation, props.reversed);
			if (frameHeldOnLoopEnd) frameNum = props.resetOnEnd ? 0 : animation.length - 1;
			render$1();
		});
		watch(() => props.paused, () => {
			frameHeldOnLoopEnd = false;
		});
		watch(() => props.loop, () => {
			if (frameHeldOnLoopEnd && props.loop) frameHeldOnLoopEnd = false;
		});
		watch(() => props.resetOnEnd, () => {
			if (frameHeldOnLoopEnd) {
				frameNum = props.resetOnEnd ? 0 : animation.length - 1;
				render$1();
			}
		});
		watch(() => props.flipX, render$1);
		watch(() => [props.center], () => {
			[centerX, centerY] = normalizeVectorFlexibleParam(props.center);
			render$1();
		}, { immediate: true });
		watch(() => [props.definitions], () => {
			setAtlasDefinitions(atlas, props.definitions);
			animation = getAtlasFrames(atlas, props.animation, props.reversed);
			cooldown = 1;
			frameNum = 0;
			render$1();
		}, { immediate: true });
		onUnmounted(() => {
			texture$1.dispose();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "groupRef",
				ref: groupRef
			}, [props.asSprite ? (openBlock(), createElementBlock("TresSprite", {
				key: 0,
				scale: [
					scaleX.value,
					scaleY.value,
					1
				],
				position: [
					positionX.value,
					positionY.value,
					0
				]
			}, [createElementVNode("TresSpriteMaterial", {
				toneMapped: false,
				map: unref(texture$1),
				transparent: true,
				alphaTest: props.alphaTest
			}, null, 8, _hoisted_2$27)], 8, _hoisted_1$57)) : (openBlock(), createElementBlock("TresMesh", {
				key: 1,
				scale: [
					scaleX.value,
					scaleY.value,
					1
				],
				position: [
					positionX.value,
					positionY.value,
					0
				]
			}, [_cache[0] || (_cache[0] = createElementVNode("TresPlaneGeometry", { args: [1, 1] }, null, -1)), createElementVNode("TresMeshBasicMaterial", {
				toneMapped: false,
				side: unref(DoubleSide),
				map: unref(texture$1),
				transparent: true,
				alphaTest: props.alphaTest,
				depthWrite: props.depthWrite,
				depthTest: props.depthTest
			}, null, 8, _hoisted_4$3)], 8, _hoisted_3$5)), renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/AnimatedSprite/component.vue
var component_default$1 = component_vue_vue_type_script_setup_true_lang_default$18;

//#endregion
//#region src/core/abstractions/CubeCamera/useCubeCamera.ts
function useCubeCamera(props) {
	let { resolution, renderer, scene, envMap, fog, near, far } = props;
	renderer = renderer ?? useTres().renderer;
	scene = scene ?? useTres().scene;
	const updateProps = () => {
		resolution = toValue(props.resolution) ?? 255;
		near = toValue(props.near) ?? .1;
		far = toValue(props.far) ?? 1e3;
		envMap = toValue(props.envMap) ?? void 0;
		fog = toValue(props.fog) ?? void 0;
		renderer = toValue(props.renderer) ?? renderer;
		scene = toValue(props.scene) ?? scene;
	};
	watchEffect(updateProps);
	const fbo = computed(() => new WebGLCubeRenderTarget(toValue(resolution)));
	fbo.value.texture.type = HalfFloatType;
	tryOnScopeDispose(() => {
		fbo.value.dispose();
	});
	const camera = computed(() => new CubeCamera(toValue(near), toValue(far), toValue(fbo)));
	const update = () => {
		const s = toValue(scene);
		const originalFog = s.fog;
		const originalBackground = s.background;
		s.background = toValue(envMap) || originalBackground;
		s.fog = toValue(fog) || originalFog;
		camera.value.update(toValue(renderer), s);
		s.fog = originalFog;
		s.background = originalBackground;
	};
	watchEffect(update);
	return {
		fbo,
		camera,
		update
	};
}

//#endregion
//#region src/core/abstractions/CubeCamera/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$56 = ["object"];
var component_vue_vue_type_script_setup_true_lang_default$17 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		frames: {
			type: null,
			required: false,
			default: Infinity
		},
		resolution: {
			type: null,
			required: false
		},
		near: {
			type: null,
			required: false
		},
		far: {
			type: null,
			required: false
		},
		envMap: {
			type: null,
			required: false
		},
		fog: {
			type: null,
			required: false
		},
		renderer: {
			type: null,
			required: false
		},
		scene: {
			type: null,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const groupRef = shallowRef();
		const { fbo, camera, update } = useCubeCamera(props);
		let count = 0;
		useLoop().onBeforeRender(() => {
			if (groupRef.value && (props.frames === Infinity || count < toValue(props.frames))) {
				groupRef.value.visible = false;
				update();
				groupRef.value.visible = true;
				if (groupRef.value) groupRef.value.traverse((obj) => {
					if ("material" in obj && typeof obj.material === "object" && obj.material && "envMap" in obj.material) obj.material.envMap = fbo.value.texture;
				});
				count++;
			}
		});
		__expose({
			instance: groupRef,
			fbo,
			camera,
			update
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "groupRef",
				ref: groupRef
			}, [createElementVNode("primitive", { object: unref(camera) }, null, 8, _hoisted_1$56), renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/CubeCamera/component.vue
var component_default$3 = component_vue_vue_type_script_setup_true_lang_default$17;

//#endregion
//#region src/core/abstractions/Billboard.vue?vue&type=script&setup=true&lang.ts
var Billboard_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Billboard",
	props: {
		autoUpdate: {
			type: Boolean,
			required: false,
			default: true
		},
		lockX: {
			type: Boolean,
			required: false,
			default: false
		},
		lockY: {
			type: Boolean,
			required: false,
			default: false
		},
		lockZ: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const outerRef = shallowRef(new Group());
		const innerRef = shallowRef(new Group());
		const q = new Quaternion();
		const r = new Euler();
		function update(camera) {
			if (!outerRef.value) return;
			if (!camera) {
				const { camera: ctxCamera } = useTresContext();
				camera = ctxCamera.activeCamera.value;
				if (!camera) return;
			}
			innerRef.value.rotation.copy(r);
			outerRef.value.updateMatrix();
			outerRef.value.updateWorldMatrix(false, false);
			outerRef.value.getWorldQuaternion(q);
			camera.getWorldQuaternion(innerRef.value.quaternion).premultiply(q.invert());
			if (props.lockX) innerRef.value.rotation.x = r.x;
			if (props.lockY) innerRef.value.rotation.y = r.y;
			if (props.lockZ) innerRef.value.rotation.z = r.z;
		}
		useLoop().onBeforeRender(({ camera }) => {
			if (props.autoUpdate) update(camera.value);
		});
		__expose({
			instance: outerRef,
			update
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "outerRef",
				ref: outerRef
			}, [createElementVNode("TresGroup", {
				ref_key: "innerRef",
				ref: innerRef
			}, [renderSlot(_ctx.$slots, "default")], 512)], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/Billboard.vue
var Billboard_default = Billboard_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/GlobalAudio.ts
const GlobalAudio = defineComponent({
	name: "GlobalAudio",
	props: [
		"src",
		"loop",
		"volume",
		"playbackRate",
		"playTrigger",
		"stopTrigger"
	],
	async setup(props, { expose, emit }) {
		const { camera, renderer } = useTresContext();
		const listener = new AudioListener();
		camera.activeCamera.value?.add(listener);
		const sound = new Audio(listener);
		const audioLoader = new AudioLoader();
		expose({ instance: sound });
		onUnmounted(() => {
			if (sound) sound.disconnect();
		});
		watch(() => [props.playbackRate], () => sound.setPlaybackRate(props.playbackRate ?? 1), { immediate: true });
		watch(() => [props.volume], () => sound.setVolume(props.volume ?? .5), { immediate: true });
		watch(() => [props.loop], () => sound.setLoop(props.loop ?? false), { immediate: true });
		watch(() => [props.src], async () => {
			const buffer = await audioLoader.loadAsync(props.src);
			sound.setBuffer(buffer);
		}, { immediate: true });
		useEventListener(document.getElementById(props.playTrigger ?? "") || renderer.instance.domElement, "click", () => {
			if (sound.isPlaying) sound.pause();
			else sound.play();
			emit("isPlaying", sound.isPlaying);
		});
		const btnStop = document.getElementById(props.stopTrigger ?? "");
		if (btnStop) useEventListener(btnStop, "click", () => {
			sound.stop();
			emit("isPlaying", sound.isPlaying);
		});
		return null;
	}
});

//#endregion
//#region src/core/abstractions/GradientTexture.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$55 = [
	"color-space",
	"args",
	"attach"
];
var GradientTexture_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "GradientTexture",
	props: {
		stops: {
			type: Array,
			required: true
		},
		colors: {
			type: Array,
			required: true
		},
		attach: {
			type: String,
			required: false,
			default: "map"
		},
		height: {
			type: Number,
			required: false,
			default: 1024
		},
		width: {
			type: Number,
			required: false,
			default: 16
		},
		type: {
			type: String,
			required: false,
			default: "linear"
		},
		innerCircleRadius: {
			type: Number,
			required: false,
			default: 0
		},
		outerCircleRadius: {
			type: [String, Number],
			required: false,
			default: "auto"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const textureRef = shallowRef();
		const canvas = document.createElement("canvas");
		function update(canvas$1) {
			const context = canvas$1.getContext("2d");
			canvas$1.width = props.width;
			canvas$1.height = props.height;
			let gradient;
			if (props.type === "linear") gradient = context.createLinearGradient(0, 0, 0, props.height);
			else {
				const canvasCenterX = canvas$1.width / 2;
				const canvasCenterY = canvas$1.height / 2;
				const radius = props.outerCircleRadius !== "auto" ? Math.abs(Number(props.outerCircleRadius)) : Math.sqrt(canvasCenterX ** 2 + canvasCenterY ** 2);
				gradient = context.createRadialGradient(canvasCenterX, canvasCenterY, Math.abs(props.innerCircleRadius), canvasCenterX, canvasCenterY, radius);
			}
			const tempColor = new THREE.Color();
			let i = props.stops.length;
			while (i--) gradient.addColorStop(props.stops[i], tempColor.set(props.colors[i]).getStyle());
			context.save();
			context.fillStyle = gradient;
			context.fillRect(0, 0, props.width, props.height);
			context.restore();
			if (textureRef.value) textureRef.value.needsUpdate = true;
		}
		const renderer = useTres().renderer;
		watch(() => [
			props.colors,
			props.stops,
			props.height,
			props.width,
			props.type,
			props.innerCircleRadius,
			props.outerCircleRadius
		], () => {
			update(canvas);
		}, { immediate: true });
		if (isReactive(props.colors)) watch(props.colors, () => update(canvas));
		if (isReactive(props.stops)) watch(props.stops, () => update(canvas));
		__expose({ instance: textureRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresCanvasTexture", {
				ref_key: "textureRef",
				ref: textureRef,
				"color-space": unref(renderer).outputColorSpace,
				args: [unref(canvas)],
				attach: props.attach
			}, null, 8, _hoisted_1$55);
		};
	}
});

//#endregion
//#region src/core/abstractions/GradientTexture.vue
var GradientTexture_default = GradientTexture_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/utils/shaderMaterial.ts
function shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {
	const material = class extends ShaderMaterial {
		key = "";
		constructor(parameters = {}) {
			const entries = Object.entries(uniforms);
			super({
				uniforms: entries.reduce((acc, [name, value]) => {
					const uniform = UniformsUtils.clone({ [name]: { value } });
					return {
						...acc,
						...uniform
					};
				}, {}),
				vertexShader,
				fragmentShader
			});
			entries.forEach(([name]) => Object.defineProperty(this, name, {
				get: () => this.uniforms[name].value,
				set: (v) => this.uniforms[name].value = v
			}));
			Object.assign(this, parameters);
			if (onInit) onInit(this);
		}
	};
	material.key = MathUtils.generateUUID();
	return material;
}

//#endregion
//#region src/core/abstractions/Image/ImageMaterialImpl.ts
/**
* NOTE: Source:
* https://threejs.org/docs/?q=material#api/en/materials/Material.transparent
*/
const ImageMaterialImpl = /* @__PURE__ */ shaderMaterial({
	color: /* @__PURE__ */ new Color("white"),
	scale: /* @__PURE__ */ new Vector2(1, 1),
	imageBounds: /* @__PURE__ */ new Vector2(1, 1),
	resolution: 1024,
	map: null,
	zoom: 1,
	radius: 0,
	grayscale: 0,
	opacity: 1
}, `
    varying vec2 vUv;
    varying vec2 vPos;
    void main() {
      gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
      vUv = uv;
      vPos = position.xy;
    }
  `, `
    // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
    varying vec2 vUv;
    varying vec2 vPos;
    uniform vec2 scale;
    uniform vec2 imageBounds;
    uniform float resolution;
    uniform vec3 color;
    uniform sampler2D map;
    uniform float radius;
    uniform float zoom;
    uniform float grayscale;
    uniform float opacity;
    const vec3 luma = vec3(.299, 0.587, 0.114);
    vec4 toGrayscale(vec4 color, float intensity) {
      return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
    }
    vec2 aspect(vec2 size) {
      return size / min(size.x, size.y);
    }

    const float PI = 3.14159265;

    // from https://iquilezles.org/articles/distfunctions
    float udRoundBox( vec2 p, vec2 b, float r ) {
      return length(max(abs(p)-b+r,0.0))-r;
    }

    void main() {
      vec2 s = aspect(scale);
      vec2 i = aspect(imageBounds);
      float rs = s.x / s.y;
      float ri = i.x / i.y;
      vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
      vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
      vec2 uv = vUv * s / new + offset;
      vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

      vec2 res = vec2(scale * resolution);
      vec2 halfRes = 0.5 * res;
      float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
        vec3 a = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0, 1.0, b));
      gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity * a), grayscale);

      #include <tonemapping_fragment>
      #include <colorspace_fragment>
    }
  `);

//#endregion
//#region src/core/abstractions/Image/ImageMaterial.vue?vue&type=script&setup=true&lang.ts
var ImageMaterial_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ImageMaterial",
	setup(__props, { expose: __expose }) {
		extend({ ImageMaterial: ImageMaterialImpl });
		const materialRef = shallowRef();
		__expose({ instance: materialRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresImageMaterial", {
				ref_key: "materialRef",
				ref: materialRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/Image/ImageMaterial.vue
var ImageMaterial_default = ImageMaterial_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/loaders/useTexture/index.ts
function useTexture(path) {
	return useLoader(TextureLoader, path, { initialValue: new Texture() });
}

//#endregion
//#region src/core/abstractions/Image/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$54 = ["scale"];
const _hoisted_2$26 = ["args"];
var component_vue_vue_type_script_setup_true_lang_default$16 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		segments: {
			type: Number,
			required: false,
			default: 1
		},
		scale: {
			type: [Number, Array],
			required: false,
			default: 1
		},
		color: {
			type: null,
			required: false,
			default: () => new Color("white")
		},
		zoom: {
			type: Number,
			required: false,
			default: 1
		},
		radius: {
			type: Number,
			required: false,
			default: 0
		},
		grayscale: {
			type: Number,
			required: false,
			default: 0
		},
		toneMapped: {
			type: Boolean,
			required: false,
			default: true
		},
		transparent: {
			type: Boolean,
			required: false,
			default: false
		},
		opacity: {
			type: Number,
			required: false,
			default: 1
		},
		side: {
			type: null,
			required: false,
			default: FrontSide
		},
		texture: {
			type: null,
			required: false
		},
		url: {
			type: null,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const imageRef = shallowRef();
		const texture$1 = shallowRef(props.texture ?? null);
		const size = useTres().sizes;
		const planeBounds = computed(() => Array.isArray(props.scale) ? [props.scale[0], props.scale[1]] : [props.scale, props.scale]);
		const imageBounds = computed(() => [texture$1.value?.image?.width ?? 0, texture$1.value?.image?.height ?? 0]);
		const resolution = computed(() => Math.max(size.width.value, size.height.value));
		const { state, isLoading } = useTexture(props.url);
		watchEffect(() => {
			if (props.texture) texture$1.value = props.texture;
			if (!isLoading.value) texture$1.value = state.value;
		});
		const scale = computed(() => Array.isArray(props.scale) ? [...props.scale, 1] : props.scale);
		__expose({ instance: imageRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "imageRef",
				ref: imageRef,
				scale: scale.value
			}, [renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresPlaneGeometry", { args: [
				1,
				1,
				props.segments,
				props.segments
			] }, null, 8, _hoisted_2$26)]), createVNode(ImageMaterial_default, {
				color: props.color,
				map: texture$1.value,
				zoom: props.zoom,
				grayscale: props.grayscale,
				opacity: props.opacity,
				scale: planeBounds.value,
				imageBounds: imageBounds.value,
				resolution: resolution.value,
				radius: __props.radius,
				toneMapped: __props.toneMapped,
				transparent: __props.transparent,
				side: __props.side
			}, null, 8, [
				"color",
				"map",
				"zoom",
				"grayscale",
				"opacity",
				"scale",
				"imageBounds",
				"resolution",
				"radius",
				"toneMapped",
				"transparent",
				"side"
			])], 8, _hoisted_1$54);
		};
	}
});

//#endregion
//#region src/core/abstractions/Image/component.vue
var component_default$9 = component_vue_vue_type_script_setup_true_lang_default$16;

//#endregion
//#region src/core/abstractions/Lensflare/LensflareImpl.ts
var Lensflare = class Lensflare extends Mesh {
	static Geometry;
	isLensflare = true;
	type = "Lensflare";
	addElement(_) {}
	dispose() {}
	constructor() {
		super(Lensflare.Geometry, new MeshBasicMaterial({
			opacity: 0,
			transparent: true
		}));
		this.frustumCulled = false;
		this.renderOrder = Infinity;
		const positionScreen = new Vector3();
		const positionView = new Vector3();
		const tempMap = new FramebufferTexture(16, 16);
		const occlusionMap = new FramebufferTexture(16, 16);
		let currentType = UnsignedByteType;
		const geometry = Lensflare.Geometry;
		const material1a = new RawShaderMaterial({
			uniforms: {
				scale: { value: null },
				screenPosition: { value: null }
			},
			vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
			fragmentShader: `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,
			depthTest: true,
			depthWrite: false,
			transparent: false
		});
		const material1b = new RawShaderMaterial({
			uniforms: {
				map: { value: tempMap },
				scale: { value: null },
				screenPosition: { value: null }
			},
			vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
			fragmentShader: `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,
			depthTest: false,
			depthWrite: false,
			transparent: false
		});
		const mesh1 = new Mesh(geometry, material1a);
		const elements = [];
		const shader = LensflareElement.Shader;
		const material2 = new RawShaderMaterial({
			name: shader.name,
			uniforms: {
				map: { value: null },
				occlusionMap: { value: occlusionMap },
				color: { value: new Color(16777215) },
				scale: { value: new Vector2() },
				screenPosition: { value: new Vector3() }
			},
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			blending: AdditiveBlending,
			transparent: true,
			depthWrite: false
		});
		const mesh2 = new Mesh(geometry, material2);
		this.addElement = function(element) {
			elements.push(element);
		};
		const scale = new Vector2();
		const screenPositionPixels = new Vector2();
		const validArea = new Box2();
		const viewport = new Vector4();
		this.onBeforeRender = function(renderer, _scene, camera) {
			renderer.getCurrentViewport(viewport);
			const renderTarget = renderer.getRenderTarget();
			const type = renderTarget !== null ? renderTarget.texture.type : UnsignedByteType;
			if (currentType !== type) {
				tempMap.dispose();
				occlusionMap.dispose();
				tempMap.type = occlusionMap.type = type;
				currentType = type;
			}
			const invAspect = viewport.w / viewport.z;
			const halfViewportWidth = viewport.z / 2;
			const halfViewportHeight = viewport.w / 2;
			let size = 16 / viewport.w;
			scale.set(size * invAspect, size);
			validArea.min.set(viewport.x, viewport.y);
			validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
			positionView.setFromMatrixPosition(this.matrixWorld);
			positionView.applyMatrix4(camera.matrixWorldInverse);
			if (positionView.z > 0) return;
			positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);
			screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;
			if (validArea.containsPoint(screenPositionPixels)) {
				renderer.copyFramebufferToTexture(tempMap, screenPositionPixels);
				let uniforms = material1a.uniforms;
				uniforms.scale.value = scale;
				uniforms.screenPosition.value = positionScreen;
				renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);
				renderer.copyFramebufferToTexture(occlusionMap, screenPositionPixels);
				uniforms = material1b.uniforms;
				uniforms.scale.value = scale;
				uniforms.screenPosition.value = positionScreen;
				renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);
				const vecX = -positionScreen.x * 2;
				const vecY = -positionScreen.y * 2;
				for (let i = 0, l = elements.length; i < l; i++) {
					const element = elements[i];
					const uniforms$1 = material2.uniforms;
					uniforms$1.color.value.copy(element.color);
					uniforms$1.map.value = element.texture;
					uniforms$1.screenPosition.value.x = positionScreen.x + vecX * element.distance;
					uniforms$1.screenPosition.value.y = positionScreen.y + vecY * element.distance;
					size = element.size / viewport.w;
					const invAspect$1 = viewport.w / viewport.z;
					uniforms$1.scale.value.set(size * invAspect$1, size);
					material2.uniformsNeedUpdate = true;
					renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
				}
			}
		};
		this.dispose = function() {
			material1a.dispose();
			material1b.dispose();
			material2.dispose();
			tempMap.dispose();
			occlusionMap.dispose();
			for (let i = 0, l = elements.length; i < l; i++) elements[i].texture.dispose();
		};
	}
};
var LensflareElement = class {
	texture;
	size;
	distance;
	color;
	static Shader;
	constructor(texture$1, size = 1, distance = 0, color = new Color(16777215)) {
		this.texture = texture$1;
		this.size = size;
		this.distance = distance;
		this.color = color;
	}
};
LensflareElement.Shader = {
	name: "LensflareElementShader",
	uniforms: {
		map: { value: null },
		occlusionMap: { value: null },
		color: { value: null },
		scale: { value: null },
		screenPosition: { value: null }
	},
	vertexShader: `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`,
	fragmentShader: `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
};
Lensflare.Geometry = (function() {
	const geometry = new BufferGeometry();
	const interleavedBuffer = new InterleavedBuffer(new Float32Array([
		-1,
		-1,
		0,
		0,
		0,
		1,
		-1,
		0,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		-1,
		1,
		0,
		0,
		1
	]), 5);
	geometry.setIndex([
		0,
		1,
		2,
		0,
		2,
		3
	]);
	geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
	geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
	return geometry;
})();

//#endregion
//#region src/utils/easing.ts
function linear(x) {
	return x;
}
function easeInCubic(x) {
	return x * x * x;
}
function easeInOutCubic(x) {
	return x < .5 ? 4 * x * x * x : 1 - (-2 * x + 2) ** 3 / 2;
}
function easeInQuart(x) {
	return x * x * x * x;
}
function easeOutBounce(x) {
	const n1 = 7.5625;
	const d1 = 2.75;
	if (x < 1 / d1) return n1 * x * x;
	else if (x < 2 / d1) return n1 * (x -= 1.5 / d1) * x + .75;
	else if (x < 2.5 / d1) return n1 * (x -= 2.25 / d1) * x + .9375;
	else return n1 * (x -= 2.625 / d1) * x + .984375;
}

//#endregion
//#region src/core/abstractions/Lensflare/constants.ts
const TEXTURE_PATH = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/";
const circle = `${TEXTURE_PATH}circle.png`;
const circleBlur = `${TEXTURE_PATH}circleBlur.png`;
const circleRainbow = `${TEXTURE_PATH}circleRainbow.png`;
const line = `${TEXTURE_PATH}line.png`;
const poly6 = `${TEXTURE_PATH}poly6.png`;
const polyStroke6 = `${TEXTURE_PATH}polyStroke6.png`;
const rays = `${TEXTURE_PATH}rays.png`;
const ring = `${TEXTURE_PATH}ring.png`;
const starThin6 = `${TEXTURE_PATH}starThin6.png`;
const oversize = {
	texture: [line, ring],
	color: ["white"],
	distance: [0, 0],
	size: [750, 1024],
	length: [0, 2]
};
const bodyRequired0 = {
	texture: [circleBlur],
	color: ["white"],
	distance: [0, 0],
	size: [180, 512],
	length: [1, 1]
};
const bodyRequired1 = {
	texture: [rays],
	color: ["white"],
	distance: [0, 0],
	size: [180, 512],
	length: [1, 1]
};
const bodyOptional = {
	texture: [
		circle,
		circleRainbow,
		ring,
		starThin6
	],
	color: ["white"],
	distance: [0, 0],
	size: [180, 512],
	length: [2, 3]
};
const [darkPurple, darkBlue] = [3679071, 132442];
const front = {
	texture: [
		circleBlur,
		circle,
		ring,
		poly6,
		polyStroke6
	],
	color: [
		"dimgray",
		"gray",
		"darkgray",
		darkPurple,
		darkBlue
	],
	distance: [.5, 2.5],
	size: [20, 180],
	length: [5, 21]
};
const back = {
	texture: [
		circleBlur,
		circle,
		ring,
		poly6,
		polyStroke6
	],
	color: [
		"dimgray",
		"gray",
		"darkgray",
		darkPurple,
		darkBlue
	],
	distance: [-.6, -.1],
	size: [180, 360],
	length: [0, 5]
};
const defaultSeedProps = [
	oversize,
	bodyRequired0,
	bodyRequired1,
	bodyOptional,
	front,
	back
];
const defaultLensflareElementProps = {
	color: "white",
	distance: 0,
	size: 512,
	texture: circleBlur
};

//#endregion
//#region src/core/abstractions/Lensflare/RandUtils.ts
const clamp = MathUtils.clamp;
/**
* Seedable pseudorandom number tools
*/
var RandUtils = class {
	_getNext;
	_getGenerator;
	/**
	* Create a new seeded pseudorandom number generator.
	* @param [seed] - the seed for the generator
	* @param [getSeededRandomGenerator] - a function that returns a pseudorandom number generator
	* @constructor
	*/
	constructor(seed = 0, getSeededRandomGenerator) {
		this._getGenerator = getSeededRandomGenerator ?? this.getMulberry32;
		this._getNext = this._getGenerator(seed);
	}
	/**
	* Reseed the pseudorandom number generator
	*/
	seed(s) {
		this._getNext = this._getGenerator(s);
	}
	/**
	* Return the next pseudorandom number in the interval [0, 1]
	*/
	rand() {
		return this._getNext();
	}
	/**
	* Random float from <low, high> interval
	* @param low - Low value of the interval
	* @param high - High value of the interval
	*/
	float(low, high) {
		return low + this._getNext() * (high - low);
	}
	/**
	* Random float from <-range/2, range/2> interval
	* @param range - Interval range
	*/
	floatSpread(range) {
		return this.float(-.5 * range, .5 * range);
	}
	/**
	* Random integer from <low, high> interval
	* @param low Low value of the interval
	* @param high High value of the interval
	*/
	int(low, high) {
		return low + Math.floor(this._getNext() * (high - low + 1));
	}
	/**
	* Choose an element from an array.
	* @param array The array to choose from
	* @returns An element from the array or null if the array is empty
	*/
	choice(array) {
		if (!array.length) return null;
		return array[Math.floor(this._getNext() * array.length)];
	}
	/**
	* Choose an element from an array or return defaultValue if array is empty.
	* @param array The array to choose from
	* @param defaultValue The value to return if the array is empty
	* @returns An element from the array or defaultValue if the array is empty
	*/
	defaultChoice(array, defaultValue) {
		if (!array.length) return defaultValue;
		return array[Math.floor(this._getNext() * array.length)];
	}
	/**
	* Return n elements from an array.
	* @param array The array to sample
	* @param sampleSizeMin The minimum sample size
	* @param sampleSizeMax The maximum sample size
	*/
	sample(array, sampleSizeMin, sampleSizeMax) {
		const len = array.length;
		sampleSizeMin = clamp(sampleSizeMin, 0, len - 1);
		sampleSizeMax = clamp(sampleSizeMax ?? len - 1, 0, len - 1);
		const sampleSize = this.int(sampleSizeMin, sampleSizeMax);
		const indicies = this.shuffle(array.map((_, i) => i));
		const n = Math.min(array.length, sampleSize);
		return indicies.slice(0, n).sort().map((i) => array[i]);
	}
	/**
	* Shuffle an array. Not in-place.
	* @param array The array to shuffle
	*/
	shuffle(array) {
		return array.map((value) => ({
			value,
			sort: this._getNext()
		})).sort((a, b) => a.sort - b.sort).map(({ value }) => value);
	}
	/**
	* The default pseudorandom generator.
	*/
	getMulberry32(seed = 0) {
		if (seed > 0 && seed < 1) seed = Math.floor(seed * 2 ** 16);
		return () => {
			seed += 1831565813;
			let t = seed;
			t = Math.imul(t ^ t >>> 15, t | 1);
			t ^= t + Math.imul(t ^ t >>> 7, t | 61);
			return ((t ^ t >>> 14) >>> 0) / 4294967296;
		};
	}
};

//#endregion
//#region src/core/abstractions/Lensflare/index.ts
const easingFunctions = [
	linear,
	easeInCubic,
	easeInOutCubic,
	easeInQuart,
	easeOutBounce
];
const lerp = MathUtils.lerp;
const getSeededRandomProps = (seed = 0, seedProps = defaultSeedProps) => {
	const easingFn = new RandUtils(seed).choice(easingFunctions);
	return seedProps.map((preset, i) => {
		const rand = new RandUtils(seed * (i * 7907 + 1) + (typeof preset.seed === "number" ? preset.seed : 0));
		const numElements = rand.int(preset.length[0], preset.length[1]);
		return Array.from({ length: numElements }).fill(0).map(() => {
			const progress = easingFn(rand.rand());
			return {
				texture: rand.defaultChoice(preset.texture, defaultLensflareElementProps.texture),
				size: lerp(preset.size[0], preset.size[1], easingFn(1 - progress)),
				distance: lerp(preset.distance[0], preset.distance[1], progress),
				color: rand.defaultChoice(preset.color, defaultLensflareElementProps.color)
			};
		});
	}).flat();
};
/**
* To make creating a complex lensflare simpler, the component can generate some or all `LensflareElement` properties.
* The precendence in creating the final elements' props is as follows:
*
* 1. `elements`
* 2. `userDefaultElement` - `color`, `distance`, `size`, `texture` from component
* 3. seeded random props - if `seed` and/or `seedProps` is not `undefined`
* 4. system default
*
* @param elements - `undefined` or an array of (potentially) incomplete element props
* @param userDefaultElement - values to "fill in" missing partial elements fields â€“ or overwrite seeded props
* @param seed - `undefined` or a number to seed random prop generation
* @param seedProps - `undefined` or an array of SeedProps for generating random seeded properties
* @param systemDefaultElement - default values to "fill in" any remaining missing props
* @returns LensflareElementProps[] - An array of complete props
*/
const partialLensflarePropsArrayToLensflarePropsArray = (elements, userDefaultElement, seed = void 0, seedProps = void 0, systemDefaultElement = defaultLensflareElementProps) => {
	if (elements !== void 0 && elements.length > 0 && (typeof seed === "number" || typeof seedProps !== "undefined")) {
		const seeded = getSeededRandomProps(seed ?? 0, seedProps ?? defaultSeedProps);
		const seededLength = seeded.length;
		const elementsLength = elements.length;
		if (seededLength >= elementsLength) return seeded.map((_seededProps, i) => Object.assign(_seededProps, userDefaultElement, i < elementsLength ? elements[i] : {}));
		else return elements.map((_element, i) => Object.assign({}, systemDefaultElement, i < seededLength ? seeded[i] : {}, userDefaultElement, _element));
	}
	if (elements !== void 0 && elements.length > 0) {
		const fullDefaultProps = Object.assign({}, systemDefaultElement, userDefaultElement);
		return elements.map((element) => Object.assign({}, fullDefaultProps, element));
	}
	const _seedProps = seedProps === void 0 || seedProps.length === 0 ? defaultSeedProps : seedProps;
	return getSeededRandomProps(seed ?? 0, _seedProps).map((props) => Object.assign({}, props, userDefaultElement));
};
function filterLensflareElementProps(props) {
	return filter(props, (v, k) => k in defaultLensflareElementProps && v !== void 0);
}
function filter(obj, predicate) {
	const result = {};
	Object.keys(obj).forEach((name) => {
		if (predicate(obj[name], name)) result[name] = obj[name];
	});
	return result;
}

//#endregion
//#region src/core/abstractions/Lensflare/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default$15 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		scale: {
			type: Number,
			required: false,
			default: 1
		},
		elements: {
			type: Array,
			required: false,
			default: void 0
		},
		seed: {
			type: Number,
			required: false,
			default: void 0
		},
		seedProps: {
			type: Array,
			required: false,
			default: void 0
		},
		color: {
			type: null,
			required: false,
			default: void 0
		},
		distance: {
			type: Number,
			required: false,
			default: void 0
		},
		size: {
			type: Number,
			required: false,
			default: void 0
		},
		texture: {
			type: [Object, String],
			required: false,
			default: void 0
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const lensflareRef = shallowRef();
		const lensflareElementPropsArrayRef = shallowRef([]);
		const userDefaultLensflareElementPropsRef = shallowRef(filterLensflareElementProps(props));
		__expose({ instance: lensflareRef });
		const textureLoader = new TextureLoader();
		const threeLensflare = new Lensflare();
		const threeElements = [];
		const dispose = () => {
			while (threeElements.length) threeElements.pop();
			lensflareRef.value?.children.forEach((c) => {
				if ("dispose" in c) c.dispose();
			});
			lensflareRef.value?.remove(...lensflareRef.value.children);
			lensflareRef.value?.dispose();
		};
		const lensflareElementPropsToLensflareElement = (p) => {
			if (typeof p.texture === "string") {
				const path = p.texture;
				p.texture = textureLoader.load(path);
				p.texture.name = path;
			}
			p.color = normalizeColor(p.color);
			return p;
		};
		const scaleThreeElements = () => {
			for (let i = lensflareElementPropsArrayRef.value.length - 1; i < threeElements.length; i++) threeElements[i].size = 0;
			lensflareElementPropsArrayRef.value.forEach((elementProps, i) => {
				threeElements[i].size = elementProps.size * props.scale;
			});
		};
		const updateThreeElements = () => {
			while (lensflareElementPropsArrayRef.value.length > threeElements.length) {
				const copy = { ...lensflareElementPropsToLensflareElement(lensflareElementPropsArrayRef.value[threeElements.length]) };
				threeElements.push(copy);
				threeLensflare.addElement(copy);
			}
			lensflareElementPropsArrayRef.value.forEach((elementProps, i) => {
				const threeElement = threeElements[i];
				const { texture: texture$1, size, distance, color } = elementProps;
				if (typeof texture$1 === "string") {
					if (threeElement.texture.name !== texture$1) {
						threeElement.texture.dispose();
						const name = texture$1;
						threeElement.texture = textureLoader.load(name);
						threeElement.texture.name = name;
					}
				} else if (threeElement.texture !== texture$1) {
					threeElement.texture.dispose();
					threeElement.texture = texture$1;
				}
				threeElement.size = size;
				threeElement.distance = distance;
				threeElement.color = normalizeColor(color);
			});
			scaleThreeElements();
		};
		onUnmounted(() => {
			dispose();
		});
		onMounted(() => {
			lensflareRef.value?.add(threeLensflare);
			lensflareElementPropsArrayRef.value = partialLensflarePropsArrayToLensflarePropsArray(props.elements, userDefaultLensflareElementPropsRef.value, props.seed, props.seedProps);
		});
		watch(() => [
			props.color,
			props.distance,
			props.size,
			props.texture
		], () => {
			userDefaultLensflareElementPropsRef.value = {
				color: props.color,
				distance: props.distance,
				size: props.size,
				texture: props.texture
			};
		});
		watch(() => [
			userDefaultLensflareElementPropsRef.value,
			props.elements,
			props.seed,
			props.seedProps
		], () => {
			lensflareElementPropsArrayRef.value = partialLensflarePropsArrayToLensflarePropsArray(props.elements, userDefaultLensflareElementPropsRef.value, props.seed, props.seedProps);
		});
		watch(() => props.scale, () => {
			scaleThreeElements();
		});
		watch(() => lensflareElementPropsArrayRef.value, () => {
			updateThreeElements();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "lensflareRef",
				ref: lensflareRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/Lensflare/component.vue
var component_default$10 = component_vue_vue_type_script_setup_true_lang_default$15;

//#endregion
//#region src/core/abstractions/Levioso.vue?vue&type=script&setup=true&lang.ts
var Levioso_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Levioso",
	props: {
		speed: {
			type: Number,
			required: false,
			default: 1
		},
		rotationFactor: {
			type: Number,
			required: false,
			default: 1
		},
		floatFactor: {
			type: Number,
			required: false,
			default: 1
		},
		range: {
			type: Array,
			required: false,
			default: () => [-.1, .1]
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const groupRef = shallowRef();
		__expose({ instance: groupRef });
		{
			const PERIOD_SCALE = 1 / 4;
			const AMPLITUDE_ROTATION_X = 1 / 8;
			const AMPLITUDE_ROTATION_Y = 1 / 8;
			const AMPLITUDE_ROTATION_Z = 1 / 20;
			const START_OFFSET = Math.random() * 1e4;
			const { onBeforeRender } = useLoop();
			let elapsed = START_OFFSET;
			onBeforeRender(({ delta }) => {
				if (!groupRef.value) return;
				elapsed += delta * props.speed;
				const theta = elapsed * PERIOD_SCALE;
				const group = groupRef.value;
				group.rotation.x = Math.cos(theta) * AMPLITUDE_ROTATION_X * props.rotationFactor;
				group.rotation.y = Math.sin(theta) * AMPLITUDE_ROTATION_Y * props.rotationFactor;
				group.rotation.z = Math.sin(theta) * AMPLITUDE_ROTATION_Z * props.rotationFactor;
				group.position.y = MathUtils.mapLinear(Math.sin(theta), -1, 1, props.range[0], props.range[1]) * props.floatFactor;
			});
		}
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "groupRef",
				ref: groupRef
			}, [renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/Levioso.vue
var Levioso_default = Levioso_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/MarchingCubes/const.ts
const MARCHING_CUBES_PROVIDE_KEY = Symbol("marchingCubes");

//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingCube.vue?vue&type=script&setup=true&lang.ts
var MarchingCube_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MarchingCube",
	props: {
		strength: {
			type: Number,
			required: false,
			default: .5
		},
		subtract: {
			type: Number,
			required: false,
			default: 12
		},
		color: {
			type: [
				Object,
				String,
				Number
			],
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { parent } = inject(MARCHING_CUBES_PROVIDE_KEY);
		const cubeRef = shallowRef();
		const vec = new Vector3();
		const color = computed(() => new Color(props.color));
		useLoop().onBeforeRender(() => {
			if (!parent.value || !cubeRef.value) return;
			cubeRef.value.getWorldPosition(vec);
			parent.value.addBall(.5 + vec.x * .5, .5 + vec.y * .5, .5 + vec.z * .5, props.strength, props.subtract, color.value);
		});
		__expose({ instance: cubeRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "cubeRef",
				ref: cubeRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingCube.vue
var MarchingCube_default = MarchingCube_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingCubes.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$53 = ["object"];
var MarchingCubes_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MarchingCubes",
	props: {
		resolution: {
			type: Number,
			required: false,
			default: 28
		},
		maxPolyCount: {
			type: Number,
			required: false,
			default: 1e4
		},
		enableUvs: {
			type: Boolean,
			required: false,
			default: false
		},
		enableColors: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const defaultMaterial = new MeshBasicMaterial();
		const marchingCubes = computed(() => new MarchingCubes(props.resolution, defaultMaterial, props.enableUvs, props.enableColors, props.maxPolyCount));
		provide(MARCHING_CUBES_PROVIDE_KEY, { parent: marchingCubes });
		marchingCubes.value.reset();
		useLoop().onBeforeRender(() => {
			marchingCubes.value.update();
			marchingCubes.value.reset();
		});
		onUnmounted(() => {
			defaultMaterial.dispose();
		});
		__expose({ instance: marchingCubes });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", { object: marchingCubes.value }, [renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$53);
		};
	}
});

//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingCubes.vue
var MarchingCubes_default = MarchingCubes_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingPlane.vue?vue&type=script&setup=true&lang.ts
var MarchingPlane_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MarchingPlane",
	props: {
		planeType: {
			type: String,
			required: false,
			default: "x"
		},
		strength: {
			type: Number,
			required: false,
			default: .5
		},
		subtract: {
			type: Number,
			required: false,
			default: 12
		}
	},
	setup(__props) {
		const props = __props;
		const { parent } = inject(MARCHING_CUBES_PROVIDE_KEY);
		const wallRef = ref();
		const planeType = computed(() => props.planeType === "x" ? "addPlaneX" : props.planeType === "y" ? "addPlaneY" : "addPlaneZ");
		useLoop().onBeforeRender(() => {
			if (!parent.value || !wallRef.value) return;
			parent.value[planeType.value](props.strength, props.subtract);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "wallRef",
				ref: wallRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingPlane.vue
var MarchingPlane_default = MarchingPlane_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/Mask/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$52 = ["render-order"];
var component_vue_vue_type_script_setup_true_lang_default$14 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		id: {
			type: Number,
			required: true,
			default: 1
		},
		colorWrite: {
			type: Boolean,
			required: false,
			default: true
		},
		depthWrite: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const meshRef = shallowRef();
		function update() {
			const material = Array.isArray(meshRef.value?.material) ? meshRef.value.material[0] : meshRef.value?.material;
			if (!material) return;
			material.colorWrite = props.colorWrite;
			material.depthWrite = props.depthWrite;
			material.stencilWrite = true;
			material.stencilRef = props.id;
			material.stencilFunc = AlwaysStencilFunc;
			material.stencilFail = ReplaceStencilOp;
			material.stencilZFail = ReplaceStencilOp;
			material.stencilZPass = ReplaceStencilOp;
		}
		watchEffect(update);
		__expose({ instance: meshRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "meshRef",
				ref: meshRef,
				"render-order": -props.id
			}, [renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$52);
		};
	}
});

//#endregion
//#region src/core/abstractions/Mask/component.vue
var component_default$11 = component_vue_vue_type_script_setup_true_lang_default$14;

//#endregion
//#region src/core/abstractions/MouseParallax.vue?vue&type=script&setup=true&lang.ts
var MouseParallax_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MouseParallax",
	props: {
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		factor: {
			type: [Number, Array],
			required: false,
			default: 2.5
		},
		ease: {
			type: [Number, Array],
			required: false,
			default: .1
		},
		local: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props) {
		const props = __props;
		const { camera, renderer } = useTres();
		const { disabled, factor, ease, local } = toRefs(props);
		const mouseOptions = {};
		if (local.value) {
			mouseOptions.target = renderer.domElement;
			mouseOptions.type = "client";
		}
		const { x, y } = useMouse(mouseOptions);
		const { width, height } = local.value ? useElementSize(renderer.domElement) : useWindowSize();
		const cameraGroupRef = shallowRef();
		const _factor = ref();
		const _ease = ref();
		watch([factor, ease], () => {
			_factor.value = Array.isArray(factor.value) ? factor.value : [factor.value, factor.value];
			_ease.value = Array.isArray(ease.value) ? ease.value : [ease.value, ease.value];
		}, { immediate: true });
		const cursorX = computed(() => (x.value / width.value - .5) * _factor.value[0]);
		const cursorY = computed(() => -(y.value / height.value - .5) * _factor.value[1]);
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ delta }) => {
			if (disabled.value || !cameraGroupRef.value || Number.isNaN(cursorX.value) || Number.isNaN(cursorY.value)) return;
			cameraGroupRef.value.position.x += (cursorX.value - cameraGroupRef.value.position.x) * _ease.value[0] * delta;
			cameraGroupRef.value.position.y += (cursorY.value - cameraGroupRef.value.position.y) * _ease.value[1] * delta;
		});
		watch(() => cameraGroupRef.value, (value) => value?.add(camera.value));
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "cameraGroupRef",
				ref: cameraGroupRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/MouseParallax.vue
var MouseParallax_default = MouseParallax_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/Outline/OutlineMaterialImpl.ts
const OutlineMaterialImpl = /* @__PURE__ */ shaderMaterial({
	screenspace: false,
	color: new Color("black"),
	opacity: 1,
	thickness: .05,
	size: new Vector2(1, 1)
}, `#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   uniform bool screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
       #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
     #include <morphtarget_vertex>
     #include <skinning_vertex>
     #include <project_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`, `uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <colorspace_fragment>
   }`);

//#endregion
//#region src/core/abstractions/Outline/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default$13 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		color: {
			type: null,
			required: false,
			default: "black"
		},
		screenspace: {
			type: Boolean,
			required: false,
			default: false
		},
		opacity: {
			type: Number,
			required: false,
			default: 1
		},
		transparent: {
			type: Boolean,
			required: false,
			default: false
		},
		thickness: {
			type: Number,
			required: false,
			default: .05
		},
		angle: {
			type: Number,
			required: false,
			default: Math.PI
		},
		toneMapped: {
			type: Boolean,
			required: false,
			default: true
		},
		polygonOffset: {
			type: Boolean,
			required: false,
			default: false
		},
		polygonOffsetFactor: {
			type: Number,
			required: false,
			default: 0
		},
		renderOrder: {
			type: Number,
			required: false,
			default: 0
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const groupRef = shallowRef();
		__expose({ instance: groupRef });
		const material = new OutlineMaterialImpl({ ...props });
		const contextSize = new Vector2(1, 1);
		let oldAngle = 0;
		let oldGeometry = null;
		function updateMesh(group) {
			const parent = group.parent;
			if (!parent || !parent.geometry) return;
			if (oldAngle !== props.angle || oldGeometry !== parent.geometry) {
				oldAngle = props.angle;
				oldGeometry = parent.geometry;
				let mesh = group.children?.[0];
				if (mesh) {
					if (props.angle) mesh.geometry.dispose();
					group.remove(mesh);
				}
				if (parent.skeleton) {
					mesh = new SkinnedMesh();
					mesh.material = material;
					mesh.bind(parent.skeleton, parent.bindMatrix);
					group.add(mesh);
				} else if (parent.isInstancedMesh) {
					mesh = new InstancedMesh(parent.geometry, material, parent.count);
					mesh.instanceMatrix = parent.instanceMatrix;
					group.add(mesh);
				} else {
					mesh = new Mesh();
					mesh.material = material;
					group.add(mesh);
				}
				mesh.geometry = props.angle ? toCreasedNormals(parent.geometry, props.angle) : parent.geometry;
			}
		}
		function updateMaterial() {
			material.side = BackSide;
			material.transparent = props.transparent;
			material.thickness = props.thickness;
			material.color = normalizeColor(props.color);
			material.opacity = props.opacity;
			material.size = contextSize;
			material.screenspace = props.screenspace;
			material.toneMapped = props.toneMapped;
			material.polygonOffset = props.polygonOffset;
			material.polygonOffsetFactor = props.polygonOffsetFactor;
		}
		const sizes = useTres().sizes;
		watch(() => [sizes.width.value, sizes.height.value], ([w, h]) => {
			contextSize.set(w, h);
		});
		watch(() => [props.angle], () => {
			if (groupRef.value) updateMesh(groupRef.value);
		});
		watch(() => [
			props.transparent,
			props.thickness,
			props.color,
			props.opacity,
			contextSize,
			props.screenspace,
			props.toneMapped,
			props.polygonOffset,
			props.polygonOffsetFactor
		], () => updateMaterial(), { immediate: true });
		onMounted(() => updateMesh(groupRef.value));
		onUnmounted(() => {
			const mesh = groupRef.value?.children[0];
			if (mesh) {
				mesh.geometry.dispose();
				material.dispose();
				mesh.removeFromParent();
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "groupRef",
				ref: groupRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/Outline/component.vue
var component_default$12 = component_vue_vue_type_script_setup_true_lang_default$13;

//#endregion
//#region src/core/abstractions/PositionalAudio.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$51 = ["args"];
var PositionalAudio_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "PositionalAudio",
	props: {
		ready: {
			type: Boolean,
			required: true,
			default: false
		},
		url: {
			type: String,
			required: true
		},
		distance: {
			type: Number,
			required: false,
			default: 2
		},
		helper: {
			type: Boolean,
			required: false,
			default: false
		},
		loop: {
			type: Boolean,
			required: false,
			default: false
		},
		autoplay: {
			type: Boolean,
			required: false,
			default: false
		},
		innerAngle: {
			type: Number,
			required: false,
			default: 360
		},
		outerAngle: {
			type: Number,
			required: false,
			default: 360
		},
		outerGain: {
			type: Number,
			required: false,
			default: 0
		}
	},
	emits: ["isPlaying"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { ready, url, distance, helper, loop, autoplay, innerAngle, outerAngle, outerGain } = toRefs(props);
		const { state: buffer } = useLoader(AudioLoader, url.value);
		const { camera } = useTresContext();
		const positionalAudioRef = shallowRef(null);
		const positionalAudioHelperRef = shallowRef(null);
		const listener = shallowReactive(new AudioListener());
		const playAudio = () => {
			if (positionalAudioRef?.value?.isPlaying) return;
			positionalAudioRef?.value?.play();
			emit("isPlaying", positionalAudioRef?.value?.isPlaying);
		};
		const pauseAudio = () => {
			if (!positionalAudioRef?.value?.isPlaying) return;
			positionalAudioRef.value.pause();
			emit("isPlaying", positionalAudioRef?.value?.isPlaying);
		};
		const stopAudio = () => {
			if (!positionalAudioRef.value) return;
			positionalAudioRef.value.stop();
			emit("isPlaying", positionalAudioRef?.value?.isPlaying);
		};
		const disposeAudio = () => {
			if (!positionalAudioRef?.value) return;
			stopAudio();
			const audio = positionalAudioRef.value;
			if (audio.source) audio.disconnect();
		};
		const disposeHelper = () => {
			if (!positionalAudioRef?.value || !positionalAudioHelperRef?.value) return;
			positionalAudioHelperRef?.value?.dispose();
			positionalAudioRef?.value?.remove(positionalAudioHelperRef?.value);
		};
		const updatePositionalAudio = () => {
			if (!positionalAudioRef.value || !buffer.value) return;
			const audioBuffer = Array.isArray(buffer.value) ? buffer.value[0] : buffer.value;
			positionalAudioRef.value.setBuffer(audioBuffer);
			positionalAudioRef.value.setRefDistance(distance.value);
			positionalAudioRef.value.setLoop(loop.value);
			positionalAudioRef.value.setDirectionalCone(innerAngle.value, outerAngle.value, outerGain.value);
			positionalAudioHelperRef?.value?.update();
			if (positionalAudioHelperRef?.value) {
				const material = positionalAudioHelperRef.value.material[0];
				if (!material.visible && outerAngle.value !== innerAngle.value) material.visible = true;
			}
		};
		const createHelper = () => {
			updatePositionalAudio();
			const parent = positionalAudioRef.value?.parent;
			const boxParent = new Box3().setFromObject(parent);
			const depthParent = (boxParent.max.z - boxParent.min.z) * 2;
			positionalAudioHelperRef.value = new PositionalAudioHelper(positionalAudioRef.value, depthParent, 32, 16);
			positionalAudioRef?.value?.add(positionalAudioHelperRef.value);
			positionalAudioHelperRef.value.update();
		};
		const dispose = () => {
			camera.activeCamera.value?.remove(listener);
			disposeAudio();
			disposeHelper();
		};
		__expose({
			instance: positionalAudioRef,
			play: playAudio,
			stop: stopAudio,
			pause: pauseAudio,
			dispose
		});
		watch(positionalAudioRef, () => {
			if (!positionalAudioRef?.value) return;
			if (helper.value) createHelper();
			if (ready.value && autoplay) playAudio();
		});
		watch(helper, () => {
			if (helper.value) createHelper();
			else disposeHelper();
		});
		watch(ready, () => {
			if (ready.value) updatePositionalAudio();
			if (autoplay.value && ready.value) playAudio();
			if (!autoplay.value && ready.value) stopAudio();
		});
		watch([
			distance,
			loop,
			buffer,
			innerAngle,
			outerAngle,
			outerGain,
			autoplay
		], () => {
			updatePositionalAudio();
		});
		onMounted(() => {
			camera.activeCamera.value?.add(listener);
		});
		onBeforeUnmount(() => {
			dispose();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresPositionalAudio", {
				ref_key: "positionalAudioRef",
				ref: positionalAudioRef,
				args: [unref(listener)]
			}, null, 8, _hoisted_1$51);
		};
	}
});

//#endregion
//#region src/core/abstractions/PositionalAudio.vue
var PositionalAudio_default = PositionalAudio_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/Reflector.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$50 = ["args", "material-uniforms-color-value"];
var Reflector_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Reflector",
	props: {
		color: {
			type: null,
			required: false,
			default: "#333"
		},
		textureWidth: {
			type: Number,
			required: false,
			default: 512
		},
		textureHeight: {
			type: Number,
			required: false,
			default: 512
		},
		clipBias: {
			type: Number,
			required: false,
			default: 0
		},
		multisample: {
			type: Number,
			required: false,
			default: 4
		},
		shader: {
			type: Object,
			required: false,
			default: Reflector.ReflectorShader
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { extend: extend$1, invalidate } = useTres();
		const reflectorRef = shallowRef();
		extend$1({ Reflector });
		const { color, textureWidth, textureHeight, clipBias, multisample, shader } = toRefs(props);
		const colorValue = computed(() => new Color(color.value));
		watch(props, () => {
			invalidate();
		});
		__expose({ instance: reflectorRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresReflector", {
				ref_key: "reflectorRef",
				ref: reflectorRef,
				args: [void 0, {
					textureWidth: unref(textureWidth),
					textureHeight: unref(textureHeight),
					clipBias: unref(clipBias),
					multisample: unref(multisample),
					shader: unref(shader)
				}],
				"material-uniforms-color-value": colorValue.value
			}, [renderSlot(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createElementVNode("TresPlaneGeometry", { args: [5, 5] }, null, -1))])], 8, _hoisted_1$50);
		};
	}
});

//#endregion
//#region src/core/abstractions/Reflector.vue
var Reflector_default = Reflector_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/ScreenSpace.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$49 = ["position"];
var ScreenSpace_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ScreenSpace",
	props: {
		depth: {
			type: Number,
			required: false,
			default: -1
		},
		top: {
			type: Number,
			required: false
		},
		bottom: {
			type: Number,
			required: false
		},
		left: {
			type: Number,
			required: false
		},
		right: {
			type: Number,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const outerRef = shallowRef();
		const { camera, sizes } = useTresContext();
		const zoom = ref(1);
		useLoop().onBeforeRender(({ camera: camera$1 }) => {
			if (!outerRef.value || !camera$1.value) return;
			outerRef.value.quaternion.copy(camera$1.value.quaternion);
			outerRef.value.position.copy(camera$1.value.position);
			if (camera$1.value instanceof PerspectiveCamera || camera$1.value instanceof OrthographicCamera) zoom.value = camera$1.value.zoom;
		});
		const viewPlaneDimensions = computed(() => {
			let height = 0;
			let width = 0;
			const activeCamera = camera.activeCamera.value;
			if (activeCamera instanceof PerspectiveCamera) {
				height = 2 * Math.tan(activeCamera.fov * Math.PI / 180 / 2) * props.depth / zoom.value;
				width = height * sizes.aspectRatio.value;
			} else if (activeCamera instanceof OrthographicCamera) {
				height = (activeCamera.top - activeCamera.bottom) / zoom.value;
				width = (activeCamera.right - activeCamera.left) / zoom.value;
			} else if (activeCamera) logWarning(`ScreenSpace: Unhandled active camera type, only PerspectiveCamera and OrthographicCamera are supported when using \`top\`, \`bottom\`, \`left\`, and \`right\` props`, activeCamera);
			return {
				height,
				width
			};
		});
		const innerPosition = computed(() => {
			const leftPos = props.left ?? (props.right !== void 0 ? 1 - props.right : .5);
			const topPos = props.top ?? (props.bottom !== void 0 ? 1 - props.bottom : .5);
			return [
				viewPlaneDimensions.value.width * (leftPos - .5),
				viewPlaneDimensions.value.height * (1 - topPos - .5),
				-props.depth
			];
		});
		__expose({ instance: outerRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "outerRef",
				ref: outerRef
			}, [createElementVNode("TresGroup", { position: innerPosition.value }, [renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$49)], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/ScreenSpace.vue
var ScreenSpace_default = ScreenSpace_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/Text3D.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$48 = ["args", "center"];
var Text3D_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Text3D",
	props: {
		font: {
			type: [Object, String],
			required: true
		},
		text: {
			type: String,
			required: false
		},
		size: {
			type: Number,
			required: false,
			default: .5
		},
		height: {
			type: Number,
			required: false,
			default: .2
		},
		curveSegments: {
			type: Number,
			required: false,
			default: 5
		},
		bevelEnabled: {
			type: Boolean,
			required: false,
			default: true
		},
		bevelThickness: {
			type: Number,
			required: false,
			default: .05
		},
		bevelSize: {
			type: Number,
			required: false,
			default: .02
		},
		bevelOffset: {
			type: Number,
			required: false,
			default: 0
		},
		bevelSegments: {
			type: Number,
			required: false,
			default: 4
		},
		center: {
			type: Boolean,
			required: false,
			default: false
		},
		needUpdates: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	async setup(__props, { expose: __expose }) {
		let __temp, __restore;
		const props = __props;
		const { center, font, text, needUpdates, size, height, curveSegments, bevelEnabled, bevelThickness, bevelSize, bevelOffset, bevelSegments } = toRefs(props);
		const { extend: extend$1, invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		extend$1({ TextGeometry });
		const loader = new FontLoader();
		const slots = useSlots();
		const localText = computed(() => {
			if (text?.value) return text.value;
			else if (slots.default) return slots.default()[0].children?.trim();
			return needUpdates.value ? "" : "TresJS";
		});
		const text3DRef = shallowRef();
		__expose({ instance: text3DRef });
		const localFont = ([__temp, __restore] = withAsyncContext(() => new Promise((resolve, reject) => {
			try {
				if (typeof font.value === "string") loader.load(font.value, (font$1) => {
					resolve(font$1);
				});
				else resolve(font.value);
			} catch (error) {
				reject(console.error("cientos", error));
			}
		})), __temp = await __temp, __restore(), __temp);
		const textOptions = computed(() => ({
			font: localFont,
			size: toValue(size),
			height: toValue(height),
			curveSegments: toValue(curveSegments),
			bevelEnabled: toValue(bevelEnabled),
			bevelThickness: toValue(bevelThickness),
			bevelSize: toValue(bevelSize),
			bevelOffset: toValue(bevelOffset),
			bevelSegments: toValue(bevelSegments)
		}));
		watchEffect(() => {
			if (text3DRef.value && needUpdates.value) {
				text3DRef.value.geometry.dispose();
				text3DRef.value.geometry = new TextGeometry(localText.value, textOptions.value);
				if (center.value) text3DRef.value.geometry.center();
			}
		});
		return (_ctx, _cache) => {
			return unref(font) ? (openBlock(), createElementBlock("TresMesh", {
				key: 0,
				ref_key: "text3DRef",
				ref: text3DRef
			}, [localText.value ? (openBlock(), createElementBlock("TresTextGeometry", {
				key: 0,
				args: [localText.value, textOptions.value],
				center: unref(center)
			}, null, 8, _hoisted_1$48)) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "default")], 512)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/abstractions/Text3D.vue
var Text3D_default = Text3D_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/useAnimations.ts
/**
* Creates an AnimationMixer and returns it.
*
* @export
* @template T
* @param {T[]} animations
* @param {(Scene | Ref<Object3D | undefined | null>)} [modelRef]
* @return {*}
*/
function useAnimations(animations, modelRef, options) {
	const reference = ref(modelRef);
	const mixer = computed(() => new AnimationMixer(reference.value));
	const actions = shallowReactive({});
	const setupActions = () => {
		const items = unref(animations);
		if (items && items.length > 0) {
			Object.keys(actions).forEach((key) => delete actions[key]);
			items.forEach((animation) => {
				const action = mixer.value.clipAction(animation, reference.value);
				actions[animation.name] = action;
			});
		}
	};
	watch(animations, setupActions, {
		deep: true,
		immediate: true
	});
	watch(reference, (newRef) => {
		if (newRef) {
			mixer.value.uncacheRoot(reference.value);
			setupActions();
		}
	});
	if (!options?.manualUpdate) {
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ delta }) => {
			mixer.value.update(delta);
		});
	}
	return {
		actions,
		mixer
	};
}

//#endregion
//#region src/core/abstractions/Mask/useMask.ts
function useMask(id, inverse = false) {
	const result = reactive({
		stencilWrite: true,
		stencilRef: toValue(id),
		stencilFunc: toValue(inverse) ? NotEqualStencilFunc : EqualStencilFunc,
		stencilFail: KeepStencilOp,
		stencilZFail: KeepStencilOp,
		stencilZPass: KeepStencilOp
	});
	watchEffect(() => {
		result.stencilRef = toValue(id);
		result.stencilFunc = toValue(inverse) ? NotEqualStencilFunc : EqualStencilFunc;
	});
	return result;
}

//#endregion
//#region src/core/abstractions/useFBO/index.ts
function useFBO(options) {
	const target = ref(null);
	const { height, width, settings, depth, autoRender = ref(true) } = isReactive(options) ? toRefs(options) : toRefs(reactive(options));
	const { onBeforeRender } = useLoop();
	const { camera, renderer, scene, sizes, invalidate } = useTres();
	watch(() => [
		width?.value,
		sizes.width.value,
		height?.value,
		sizes.height.value
	], () => {
		target.value?.dispose();
		target.value = new WebGLRenderTarget(width?.value || sizes.width.value, height?.value || sizes.height.value, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			type: HalfFloatType,
			...settings?.value
		});
		if (depth?.value) target.value.depthTexture = new DepthTexture(width?.value || sizes.width.value, height?.value || sizes.height.value, FloatType);
		invalidate();
	}, { immediate: true });
	onBeforeRender(() => {
		if (autoRender.value) {
			renderer.setRenderTarget(target.value);
			renderer.clear();
			if (camera.value) renderer.render(scene.value, camera.value);
			renderer.setRenderTarget(null);
		}
	}, Number.POSITIVE_INFINITY);
	onBeforeUnmount(() => {
		target.value?.dispose();
	});
	return target;
}

//#endregion
//#region src/core/abstractions/useFBO/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default$12 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		width: {
			type: Number,
			required: false
		},
		height: {
			type: Number,
			required: false
		},
		depth: {
			type: Boolean,
			required: false,
			default: false
		},
		settings: {
			type: Object,
			required: false,
			default: void 0
		},
		autoRender: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	setup(__props, { expose: __expose }) {
		__expose({ instance: useFBO(__props) });
		return () => {};
	}
});

//#endregion
//#region src/core/abstractions/useFBO/component.vue
var component_default$6 = component_vue_vue_type_script_setup_true_lang_default$12;

//#endregion
//#region src/core/abstractions/useSurfaceSampler/index.ts
const useSurfaceSampler = (mesh, count = 16, instanceMesh, weight, transform) => {
	const buffer = ref(new InterleavedBuffer(new Float32Array(count * 16), 16));
	const updateBuffer = () => {
		if (!mesh) return;
		const sampler = new MeshSurfaceSampler(mesh);
		if (weight) sampler.setWeightAttribute(weight);
		sampler.build();
		const position = new Vector3();
		const normal = new Vector3();
		const color = new Color();
		const dummy = new Object3D();
		mesh.updateMatrixWorld(true);
		for (let i = 0; i < count; i++) {
			sampler.sample(position, normal, color);
			if (typeof transform === "function") transform({
				dummy,
				sampledMesh: mesh,
				position,
				normal,
				color
			}, i);
			else dummy.position.copy(position);
			dummy.updateMatrix();
			if (instanceMesh) instanceMesh.setMatrixAt(i, dummy.matrix);
			dummy.matrix.toArray(buffer.value.array, i * 16);
		}
		if (instanceMesh) instanceMesh.instanceMatrix.needsUpdate = true;
		buffer.value.needsUpdate = true;
	};
	updateBuffer();
	return { buffer };
};

//#endregion
//#region src/core/abstractions/useSurfaceSampler/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default$11 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		transform: {
			type: Function,
			required: false
		},
		weight: {
			type: String,
			required: false
		},
		count: {
			type: Number,
			required: false
		},
		mesh: {
			type: Object,
			required: false
		},
		instanceMesh: {
			type: [Object, null],
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const samplerRef = ref();
		const instancedRef = ref();
		const meshToSampleRef = ref();
		const { invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		watchEffect(() => {
			instancedRef.value = props.instanceMesh ?? samplerRef.value?.children.find((c) => Object.prototype.hasOwnProperty.call(c, "instanceMatrix"));
			meshToSampleRef.value = props.mesh ?? samplerRef.value?.children.find((c) => c.type === "Mesh");
			useSurfaceSampler(meshToSampleRef.value, props.count, instancedRef.value, props.weight, props.transform);
		});
		__expose({ samplerRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "samplerRef",
				ref: samplerRef
			}, [renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/useSurfaceSampler/component.vue
var component_default$15 = component_vue_vue_type_script_setup_true_lang_default$11;

//#endregion
//#region src/utils/calculateScaleFactor.ts
const tV0 = new THREE.Vector3();
const tV1 = new THREE.Vector3();
const tV2 = new THREE.Vector3();
const getPoint2 = (point3, camera, size) => {
	const widthHalf = size.width / 2;
	const heightHalf = size.height / 2;
	camera.updateMatrixWorld(false);
	const vector = point3.project(camera);
	vector.x = vector.x * widthHalf + widthHalf;
	vector.y = -(vector.y * heightHalf) + heightHalf;
	return vector;
};
const getPoint3 = (point2, camera, size, zValue = 1) => {
	const vector = tV0.set(point2.x / size.width * 2 - 1, -(point2.y / size.height) * 2 + 1, zValue);
	vector.unproject(camera);
	return vector;
};
const calculateScaleFactor = (point3, radiusPx, camera, size) => {
	const point2 = getPoint2(tV2.copy(point3), camera, size);
	let scale = 0;
	for (let i = 0; i < 2; ++i) {
		const point2off = tV1.copy(point2).setComponent(i, point2.getComponent(i) + radiusPx);
		const point3off = getPoint3(point2off, camera, size, point2off.z);
		scale = Math.max(scale, point3.distanceTo(point3off));
	}
	return scale;
};

//#endregion
//#region src/core/abstractions/ScreenSizer.vue?vue&type=script&setup=true&lang.ts
var ScreenSizer_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ScreenSizer",
	setup(__props, { expose: __expose }) {
		const worldPos = new Vector3();
		const outerRef = shallowRef();
		const innerRef = shallowRef();
		const sizes = useTres().sizes;
		const size = computed(() => ({
			width: sizes.width.value,
			height: sizes.height.value
		}));
		useLoop().onBeforeRender(({ camera }) => {
			const obj = innerRef.value;
			if (!obj || !camera.value) return;
			const sf = calculateScaleFactor(obj.getWorldPosition(worldPos), 1, camera.value, size.value);
			obj.scale.setScalar(sf);
		});
		__expose({ instance: outerRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresObject3D", {
				ref_key: "outerRef",
				ref: outerRef
			}, [createElementVNode("TresObject3D", {
				ref_key: "innerRef",
				ref: innerRef
			}, [renderSlot(_ctx.$slots, "default")], 512)], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/ScreenSizer.vue
var ScreenSizer_default = ScreenSizer_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/abstractions/Edges.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$47 = ["color"];
var Edges_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Edges",
	props: {
		color: {
			type: null,
			required: false,
			default: "#ff0000"
		},
		threshold: {
			type: Number,
			required: false,
			default: 15
		}
	},
	setup(__props, { expose: __expose }) {
		const { color, threshold } = toRefs(__props);
		const lineSegmentsRef = shallowRef();
		const saveGeometry = ref(null);
		const saveThreshold = ref(1);
		__expose({ instance: lineSegmentsRef });
		watch(() => [lineSegmentsRef.value, threshold.value], () => {
			if (lineSegmentsRef.value) {
				const parent = lineSegmentsRef.value.parent;
				if (parent && "geometry" in parent && parent.geometry instanceof BufferGeometry) {
					const geometry = parent.geometry;
					if (geometry !== saveGeometry.value || threshold.value !== saveThreshold.value) {
						saveGeometry.value = geometry;
						saveThreshold.value = threshold.value;
						lineSegmentsRef.value.geometry = new EdgesGeometry(geometry, threshold.value);
					}
				}
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresLineSegments", {
				ref_key: "lineSegmentsRef",
				ref: lineSegmentsRef
			}, [renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresLineBasicMaterial", { color: unref(color) }, null, 8, _hoisted_1$47)])], 512);
		};
	}
});

//#endregion
//#region src/core/abstractions/Edges.vue
var Edges_default = Edges_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/useEnvironment/const.ts
const environmentPresets = {
	sunset: "venice/venice_sunset_1k.hdr",
	studio: "studio/poly_haven_studio_1k.hdr",
	city: "city/canary_wharf_1k.hdr",
	umbrellas: "outdoor/outdoor_umbrellas_1k.hdr",
	night: "outdoor/satara_night_1k.hdr",
	forest: "outood/mossy_forest_1k.hdr",
	snow: "outdoor/snowy_forest_path_01_1k.hdr",
	dawn: "kiara/kiara_1_dawn_1k.hdr",
	hangar: "indoor/small_hangar_01_1k.hdr",
	urban: "indoor/abandoned_games_room_02_1k.hdr",
	modern: "city/modern_buildings_2_1k.hdr",
	shangai: "city/shanghai_bund_1k.hdr"
};

//#endregion
//#region src/core/staging/useEnvironment/index.ts
const PRESET_ROOT = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
/**
* Converts various rotation formats to an Euler instance
* @param value - The rotation value to convert
* @returns An Euler instance or null if conversion fails
*/
function toEuler(value) {
	if (value instanceof Euler) return value;
	if (Array.isArray(value)) return new Euler(value[0], value[1], value[2]);
	if (typeof value === "number") return new Euler(value, value, value);
	if (value instanceof Vector3) return new Euler(value.x, value.y, value.z);
	if (typeof value === "object" && "x" in value && "y" in value && "z" in value) return new Euler(value.x, value.y, value.z);
	return null;
}
/**
* Updates all materials in the scene
* @param scene - The scene to update
*/
function updateMaterials(scene) {
	scene.traverse((child) => {
		if (child instanceof Mesh && child.material) child.material.needsUpdate = true;
	});
}
/**
* Component that loads an environment map and sets it as the scene's background and environment.
*
* @export
* @param {Partial<EnvironmentOptions>} options - The options for the environment map
*   files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],
*   blur = 0,
*   background = false,
*   path = undefined,
*   preset = undefined,
*   colorSpace = 'srgb',
*   backgroundIntensity = 1,
*   environmentIntensity = 1,
*   backgroundRotation = [0, 0, 0],
*   environmentRotation = [0, 0, 0],
*   syncMaterials = false,
* @param {Ref<WebGLCubeRenderTarget | null>} fbo - The framebuffer object
* @return {Promise<Ref<Texture | CubeTexture | null>>} The loaded texture
*/
async function useEnvironment(options, fbo) {
	const { scene, invalidate } = useTres();
	const { preset, blur, files = ref([]), path = ref(""), background, backgroundIntensity = ref(1), environmentIntensity = ref(1), backgroundRotation = ref([
		0,
		0,
		0
	]), environmentRotation = ref([
		0,
		0,
		0
	]), syncMaterials = ref(false) } = toRefs(options);
	watch(options, () => {
		invalidate();
	});
	const texture$1 = ref(null);
	const isCubeMap = computed(() => Array.isArray(files.value));
	const cubeTextureLoader = new CubeTextureLoader();
	const rgbeLoader = new RGBELoader();
	const loadTexture = async (files$1, path$1) => {
		return new Promise((resolve, reject) => {
			if (isCubeMap.value) {
				if (path$1) cubeTextureLoader.setPath(path$1);
				cubeTextureLoader.load(files$1, (texture$2) => {
					texture$2.mapping = CubeReflectionMapping;
					resolve(texture$2);
				}, void 0, (error) => reject(error));
			} else {
				if (path$1) rgbeLoader.setPath(path$1);
				rgbeLoader.load(files$1[0], (texture$2) => {
					texture$2.mapping = EquirectangularReflectionMapping;
					resolve(texture$2);
				}, void 0, (error) => reject(error));
			}
		});
	};
	watch([files, path], async ([files$1, path$1]) => {
		if (!files$1 || files$1.length === 0 || preset?.value) return;
		try {
			texture$1.value = await loadTexture(isCubeMap.value ? [...unref(files$1)] : [unref(files$1)], unref(path$1));
		} catch (error) {
			throw new Error(`Failed to load environment map: ${error}`);
		}
	}, { immediate: true });
	watch(texture$1, (value) => {
		if (scene.value && value) scene.value.environment = value;
	}, { immediate: true });
	watch([background, texture$1], ([background$1, texture$2]) => {
		if (scene.value) {
			const bTexture = fbo?.value ? fbo.value.texture : texture$2;
			if (bTexture) scene.value.background = background$1 ? bTexture : null;
		}
	}, { immediate: true });
	watch(() => blur?.value, (value) => {
		if (scene.value && value) scene.value.backgroundBlurriness = value;
	}, { immediate: true });
	watch(() => backgroundIntensity?.value, (value) => {
		if (scene.value) scene.value.backgroundIntensity = value ?? 1;
	}, { immediate: true });
	watch(() => environmentIntensity?.value, (value) => {
		if (scene.value) scene.value.environmentIntensity = value ?? 1;
	}, { immediate: true });
	watch(() => backgroundRotation?.value, (value) => {
		if (scene.value) {
			const euler = toEuler(value);
			if (euler) scene.value.backgroundRotation = euler;
		}
	}, { immediate: true });
	watch(() => environmentRotation?.value, (value) => {
		if (scene.value && !syncMaterials?.value) {
			const euler = toEuler(value);
			if (euler) {
				scene.value.environmentRotation = euler;
				updateMaterials(scene.value);
			}
		}
	}, { immediate: true });
	watch(() => preset?.value, async (value) => {
		if (value && value in environmentPresets) {
			const _path = PRESET_ROOT;
			const _files = environmentPresets[value];
			try {
				rgbeLoader.setPath(_path);
				texture$1.value = await new Promise((resolve, reject) => {
					rgbeLoader.load(_files, (texture$2) => {
						texture$2.mapping = EquirectangularReflectionMapping;
						resolve(texture$2);
					}, void 0, (error) => reject(error));
				});
				invalidate();
			} catch (error) {
				throw new Error(`Failed to load environment map: ${error}`);
			}
			if (texture$1.value) texture$1.value.mapping = EquirectangularReflectionMapping;
			invalidate();
		} else if (value && !(value in environmentPresets)) throw new Error(`Preset must be one of: ${Object.keys(environmentPresets).join(", ")}`);
	}, { immediate: true });
	watch([syncMaterials, backgroundRotation], ([sync, bgRotation]) => {
		if (sync && scene.value) {
			const euler = toEuler(bgRotation);
			if (euler) {
				scene.value.environmentRotation = euler;
				updateMaterials(scene.value);
			}
		}
	}, { immediate: true });
	return texture$1;
}

//#endregion
//#region src/utils/types.ts
const isPerspectiveCamera$1 = (camera) => Boolean(camera && camera.isPerspectiveCamera);
const isOrthographicCamera$1 = (camera) => Boolean(camera && camera.isOrthographicCamera);

//#endregion
//#region src/core/controls/CameraControls.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$46 = [
	"min-polar-angle",
	"max-polar-angle",
	"min-azimuth-angle",
	"max-azimuth-angle",
	"distance",
	"min-distance",
	"max-distance",
	"infinity-dolly",
	"min-zoom",
	"max-zoom",
	"smooth-time",
	"dragging-smooth-time",
	"max-speed",
	"azimuth-rotate-speed",
	"polar-rotate-speed",
	"dolly-speed",
	"dolly-drag-inverted",
	"truck-speed",
	"dolly-to-cursor",
	"drag-to-offset",
	"vertical-drag-to-forward",
	"boundary-friction",
	"rest-threshold",
	"collider-meshes",
	"args",
	"mouse-buttons",
	"touches"
];
const getMouseButtons = (camera, mouseButtons) => ({
	left: CameraControls.ACTION.ROTATE,
	middle: CameraControls.ACTION.DOLLY,
	right: CameraControls.ACTION.TRUCK,
	wheel: isPerspectiveCamera$1(camera) ? CameraControls.ACTION.DOLLY : isOrthographicCamera$1(camera) ? CameraControls.ACTION.ZOOM : CameraControls.ACTION.NONE,
	...mouseButtons
});
const getTouches = (camera, touches) => ({
	one: CameraControls.ACTION.TOUCH_ROTATE,
	two: isPerspectiveCamera$1(camera) ? CameraControls.ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera$1(camera) ? CameraControls.ACTION.TOUCH_ZOOM_TRUCK : CameraControls.ACTION.NONE,
	three: CameraControls.ACTION.TOUCH_TRUCK,
	...touches
});
var CameraControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CameraControls",
	props: {
		makeDefault: {
			type: Boolean,
			required: false,
			default: false
		},
		camera: {
			type: Object,
			required: false
		},
		domElement: {
			type: null,
			required: false
		},
		minPolarAngle: {
			type: Number,
			required: false,
			default: 0
		},
		maxPolarAngle: {
			type: Number,
			required: false,
			default: Math.PI
		},
		minAzimuthAngle: {
			type: Number,
			required: false,
			default: Number.NEGATIVE_INFINITY
		},
		maxAzimuthAngle: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		distance: {
			type: Number,
			required: false,
			default: () => useTres().camera.value.position.z
		},
		minDistance: {
			type: Number,
			required: false,
			default: Number.EPSILON
		},
		maxDistance: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		infinityDolly: {
			type: Boolean,
			required: false,
			default: false
		},
		minZoom: {
			type: Number,
			required: false,
			default: .01
		},
		maxZoom: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		smoothTime: {
			type: Number,
			required: false,
			default: .25
		},
		draggingSmoothTime: {
			type: Number,
			required: false,
			default: .125
		},
		maxSpeed: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		azimuthRotateSpeed: {
			type: Number,
			required: false,
			default: 1
		},
		polarRotateSpeed: {
			type: Number,
			required: false,
			default: 1
		},
		dollySpeed: {
			type: Number,
			required: false,
			default: 1
		},
		dollyDragInverted: {
			type: Boolean,
			required: false,
			default: false
		},
		truckSpeed: {
			type: Number,
			required: false,
			default: 2
		},
		dollyToCursor: {
			type: Boolean,
			required: false,
			default: false
		},
		dragToOffset: {
			type: Boolean,
			required: false,
			default: false
		},
		verticalDragToForward: {
			type: Boolean,
			required: false,
			default: false
		},
		boundaryFriction: {
			type: Number,
			required: false,
			default: 0
		},
		restThreshold: {
			type: Number,
			required: false,
			default: .01
		},
		colliderMeshes: {
			type: Array,
			required: false,
			default: () => []
		},
		mouseButtons: {
			type: Object,
			required: false,
			default: () => getMouseButtons(useTres().camera.value)
		},
		touches: {
			type: Object,
			required: false,
			default: () => getTouches(useTres().camera.value)
		}
	},
	emits: [
		"change",
		"start",
		"end"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { makeDefault, minPolarAngle, maxPolarAngle, minAzimuthAngle, maxAzimuthAngle, distance, minDistance, maxDistance, infinityDolly, minZoom, maxZoom, smoothTime, draggingSmoothTime, maxSpeed, azimuthRotateSpeed, polarRotateSpeed, dollySpeed, dollyDragInverted, truckSpeed, dollyToCursor, dragToOffset, verticalDragToForward, boundaryFriction, restThreshold, colliderMeshes } = toRefs(props);
		const subsetOfTHREE = {
			Box3,
			MathUtils: { clamp: MathUtils.clamp },
			Matrix4,
			Quaternion,
			Raycaster,
			Sphere,
			Spherical,
			Vector2,
			Vector3,
			Vector4
		};
		CameraControls.install({ THREE: subsetOfTHREE });
		const { camera: activeCamera, renderer, extend: extend$1, controls, invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const mouseButtons = computed(() => getMouseButtons(props.camera || activeCamera.value, props.mouseButtons));
		const touches = computed(() => getTouches(props.camera || activeCamera.value, props.touches));
		const controlsRef = shallowRef(null);
		extend$1({ CameraControls });
		watchEffect(() => {
			addEventListeners();
			if (controlsRef.value && makeDefault.value) controls.value = controlsRef.value;
			else controls.value = null;
		});
		function addEventListeners() {
			useEventListener(controlsRef.value, "update", () => {
				emit("change", controlsRef.value);
				invalidate();
			});
			useEventListener(controlsRef.value, "controlend", () => emit("end", controlsRef.value));
			useEventListener(controlsRef.value, "controlstart", () => emit("start", controlsRef.value));
		}
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ delta }) => {
			if (controlsRef.value?.enabled) controlsRef.value?.update(delta);
		});
		onUnmounted(() => {
			if (controlsRef.value) controlsRef.value.disconnect();
		});
		__expose({ instance: controlsRef });
		return (_ctx, _cache) => {
			return (__props.camera || unref(activeCamera)) && (__props.domElement || unref(renderer).domElement) ? (openBlock(), createElementBlock("TresCameraControls", {
				key: 0,
				ref_key: "controlsRef",
				ref: controlsRef,
				"min-polar-angle": unref(minPolarAngle),
				"max-polar-angle": unref(maxPolarAngle),
				"min-azimuth-angle": unref(minAzimuthAngle),
				"max-azimuth-angle": unref(maxAzimuthAngle),
				distance: unref(distance),
				"min-distance": unref(minDistance),
				"max-distance": unref(maxDistance),
				"infinity-dolly": unref(infinityDolly),
				"min-zoom": unref(minZoom),
				"max-zoom": unref(maxZoom),
				"smooth-time": unref(smoothTime),
				"dragging-smooth-time": unref(draggingSmoothTime),
				"max-speed": unref(maxSpeed),
				"azimuth-rotate-speed": unref(azimuthRotateSpeed),
				"polar-rotate-speed": unref(polarRotateSpeed),
				"dolly-speed": unref(dollySpeed),
				"dolly-drag-inverted": unref(dollyDragInverted),
				"truck-speed": unref(truckSpeed),
				"dolly-to-cursor": unref(dollyToCursor),
				"drag-to-offset": unref(dragToOffset),
				"vertical-drag-to-forward": unref(verticalDragToForward),
				"boundary-friction": unref(boundaryFriction),
				"rest-threshold": unref(restThreshold),
				"collider-meshes": unref(colliderMeshes),
				args: [__props.camera || unref(activeCamera), __props.domElement || unref(renderer).domElement],
				"mouse-buttons": mouseButtons.value,
				touches: touches.value
			}, null, 8, _hoisted_1$46)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/controls/CameraControls.vue
var CameraControls_default = CameraControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/controls/Helper/useHelper.ts
function useHelper(object3D, helperConstructor, ...args) {
	const helper = shallowRef();
	const { scene } = useTres();
	let currentHelper = void 0;
	watchEffect(() => {
		if (object3D && toValue(object3D) && helperConstructor) helper.value = currentHelper = new helperConstructor(toValue(object3D), ...args);
		if (currentHelper) {
			currentHelper.traverse((child) => child.raycast = () => null);
			scene.value.add(currentHelper);
		}
	});
	onBeforeUnmount(() => {
		helper.value = void 0;
		scene.value.remove(currentHelper);
		currentHelper.dispose?.();
	});
	useLoop().onBeforeRender(() => {
		helper.value?.update?.();
	});
	return helper;
}

//#endregion
//#region src/core/controls/Helper/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default$10 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		type: {
			type: null,
			required: true
		},
		args: {
			type: Array,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		const objRef = shallowRef();
		const parentRef = shallowRef();
		watchEffect(() => {
			if (objRef.value && objRef.value.parent) parentRef.value = objRef.value.parent;
		});
		useHelper(parentRef, props.type, ...props.args ?? []);
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresObject3D", {
				ref_key: "objRef",
				ref: objRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/controls/Helper/component.vue
var component_default$8 = component_vue_vue_type_script_setup_true_lang_default$10;

//#endregion
//#region src/core/controls/KeyboardControls.vue?vue&type=script&setup=true&lang.ts
var KeyboardControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "KeyboardControls",
	props: {
		makeDefault: {
			type: Boolean,
			required: false,
			default: true
		},
		camera: {
			type: Object,
			required: false
		},
		domElement: {
			type: null,
			required: false
		},
		moveSpeed: {
			type: Number,
			required: false,
			default: .2
		},
		selector: {
			type: String,
			required: false
		}
	},
	emits: ["isLock", "change"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { moveSpeed } = toRefs(props);
		const { camera: activeCamera, controls, renderer, invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const sidewardMove = ref(0);
		const forwardMove = ref(0);
		const { KeyW, KeyA, KeyS, KeyD, Up, Down, Left, Right } = useMagicKeys();
		watchEffect(() => {
			if (KeyA.value || Left.value) sidewardMove.value = -moveSpeed.value;
			else if (KeyD.value || Right.value) sidewardMove.value = moveSpeed.value;
			else sidewardMove.value = 0;
			if (KeyW.value || Up.value) forwardMove.value = moveSpeed.value;
			else if (KeyS.value || Down.value) forwardMove.value = -moveSpeed.value;
			else forwardMove.value = 0;
		});
		__expose({ instance: controls });
		const isActive = (isLock) => emit("isLock", isLock);
		const hasChange = (state) => emit("change", state);
		const moveVector = new Vector3();
		const rotationVector = new Vector3();
		const tmpQuaternion = new Quaternion();
		const moveForward = (delta, movementSpeed) => {
			if (!activeCamera.value?.position && !moveVector) return;
			const camera = activeCamera.value;
			const rotMult = delta * .001;
			camera?.translateZ(-movementSpeed);
			tmpQuaternion.set(rotationVector.x * rotMult, rotationVector.y * rotMult, rotationVector.z * rotMult, 1).normalize();
			camera?.quaternion.multiply(tmpQuaternion);
			if (sidewardMove.value || forwardMove.value) emit("change", controls.value);
		};
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ delta }) => {
			if (controls.value instanceof PointerLockControls && controls.value?.isLocked) {
				moveForward(delta, forwardMove.value);
				controls.value.moveRight(sidewardMove.value);
			}
		});
		return (_ctx, _cache) => {
			return unref(renderer) ? (openBlock(), createBlock(unref(PointerLockControls_default), {
				key: 0,
				selector: __props.selector,
				"make-default": __props.makeDefault,
				camera: __props.camera || unref(activeCamera),
				"dom-element": __props.domElement || unref(renderer).domElement,
				onIsLock: isActive,
				onChange: hasChange
			}, null, 8, [
				"selector",
				"make-default",
				"camera",
				"dom-element"
			])) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/controls/KeyboardControls.vue
var KeyboardControls_default = KeyboardControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/controls/MapControls.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$45 = [
	"args",
	"auto-rotate",
	"auto-rotate-speed",
	"enable-damping",
	"damping-factor",
	"enable-pan",
	"key-pan-speed",
	"keys",
	"max-azimuth-angle",
	"min-azimuth-angle",
	"max-polar-angle",
	"min-polar-angle",
	"min-distance",
	"max-distance",
	"min-zoom",
	"max-zoom",
	"enable-zoom",
	"zoom-speed",
	"enable-rotate",
	"rotate-speed"
];
var MapControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "MapControls",
	props: {
		makeDefault: {
			type: Boolean,
			required: false,
			default: false
		},
		camera: {
			type: Object,
			required: false
		},
		domElement: {
			type: null,
			required: false
		},
		target: {
			type: null,
			required: false
		},
		enableDamping: {
			type: Boolean,
			required: false,
			default: true
		},
		dampingFactor: {
			type: Number,
			required: false,
			default: .05
		},
		autoRotate: {
			type: Boolean,
			required: false,
			default: false
		},
		autoRotateSpeed: {
			type: Number,
			required: false,
			default: 2
		},
		enablePan: {
			type: Boolean,
			required: false,
			default: true
		},
		keyPanSpeed: {
			type: Number,
			required: false,
			default: 7
		},
		keys: {
			type: Object,
			required: false
		},
		maxAzimuthAngle: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		minAzimuthAngle: {
			type: Number,
			required: false,
			default: Number.NEGATIVE_INFINITY
		},
		maxPolarAngle: {
			type: Number,
			required: false,
			default: Math.PI
		},
		minPolarAngle: {
			type: Number,
			required: false,
			default: 0
		},
		minDistance: {
			type: Number,
			required: false,
			default: 0
		},
		maxDistance: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		minZoom: {
			type: Number,
			required: false,
			default: 0
		},
		maxZoom: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		touches: {
			type: Object,
			required: false
		},
		enableZoom: {
			type: Boolean,
			required: false,
			default: true
		},
		zoomSpeed: {
			type: Number,
			required: false,
			default: 1
		},
		enableRotate: {
			type: Boolean,
			required: false,
			default: true
		},
		rotateSpeed: {
			type: Number,
			required: false,
			default: 1
		}
	},
	emits: [
		"change",
		"start",
		"end"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { autoRotate, autoRotateSpeed, enableDamping, dampingFactor, enablePan, keyPanSpeed, maxAzimuthAngle, minAzimuthAngle, maxPolarAngle, minPolarAngle, minDistance, maxDistance, minZoom, maxZoom, enableZoom, zoomSpeed, enableRotate, rotateSpeed } = toRefs(props);
		const { camera: activeCamera, renderer, extend: extend$1, controls, invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const controlsRef = shallowRef(null);
		extend$1({ MapControls });
		watch(controls, (value) => {
			if (value && props.makeDefault) controls.value = value;
			else controls.value = null;
		});
		function onChange() {
			addEventListeners();
			invalidate();
			emit("change", controlsRef.value);
		}
		function addEventListeners() {
			useEventListener(controlsRef.value, "change", onChange);
			useEventListener(controlsRef.value, "start", () => emit("start", controlsRef.value));
			useEventListener(controlsRef.value, "end", () => emit("end", controlsRef.value));
		}
		const { onBeforeRender } = useLoop();
		onBeforeRender(() => {
			if (controlsRef.value && (enableDamping.value || autoRotate.value)) controlsRef.value.update();
		});
		onUnmounted(() => {
			if (controlsRef.value) controlsRef.value.dispose();
		});
		__expose({ instance: controlsRef });
		return (_ctx, _cache) => {
			return (__props.camera || unref(activeCamera)) && (__props.domElement || unref(renderer).domElement) ? (openBlock(), createElementBlock("TresMapControls", {
				key: 0,
				ref_key: "controlsRef",
				ref: controlsRef,
				args: [__props.camera || unref(activeCamera), __props.domElement || unref(renderer).domElement],
				"auto-rotate": unref(autoRotate),
				"auto-rotate-speed": unref(autoRotateSpeed),
				"enable-damping": unref(enableDamping),
				"damping-factor": unref(dampingFactor),
				"enable-pan": unref(enablePan),
				"key-pan-speed": unref(keyPanSpeed),
				keys: __props.keys,
				"max-azimuth-angle": unref(maxAzimuthAngle),
				"min-azimuth-angle": unref(minAzimuthAngle),
				"max-polar-angle": unref(maxPolarAngle),
				"min-polar-angle": unref(minPolarAngle),
				"min-distance": unref(minDistance),
				"max-distance": unref(maxDistance),
				"min-zoom": unref(minZoom),
				"max-zoom": unref(maxZoom),
				"enable-zoom": unref(enableZoom),
				"zoom-speed": unref(zoomSpeed),
				"enable-rotate": unref(enableRotate),
				"rotate-speed": unref(rotateSpeed)
			}, null, 8, _hoisted_1$45)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/controls/MapControls.vue
var MapControls_default = MapControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/controls/OrbitControls.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$44 = [
	"target",
	"auto-rotate",
	"auto-rotate-speed",
	"enable-damping",
	"damping-factor",
	"enable-pan",
	"key-pan-speed",
	"keys",
	"max-azimuth-angle",
	"min-azimuth-angle",
	"max-polar-angle",
	"min-polar-angle",
	"min-distance",
	"max-distance",
	"min-zoom",
	"max-zoom",
	"touches",
	"enable-zoom",
	"zoom-speed",
	"enable-rotate",
	"rotate-speed",
	"mouse-buttons",
	"args"
];
var OrbitControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "OrbitControls",
	props: {
		makeDefault: {
			type: Boolean,
			required: false,
			default: false
		},
		camera: {
			type: Object,
			required: false
		},
		domElement: {
			type: null,
			required: false
		},
		target: {
			type: null,
			required: false,
			default: () => [
				0,
				0,
				0
			]
		},
		enableDamping: {
			type: Boolean,
			required: false,
			default: true
		},
		dampingFactor: {
			type: Number,
			required: false,
			default: .05
		},
		autoRotate: {
			type: Boolean,
			required: false,
			default: false
		},
		autoRotateSpeed: {
			type: Number,
			required: false,
			default: 2
		},
		enablePan: {
			type: Boolean,
			required: false,
			default: true
		},
		keyPanSpeed: {
			type: Number,
			required: false,
			default: 7
		},
		keys: {
			type: Object,
			required: false
		},
		maxAzimuthAngle: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		minAzimuthAngle: {
			type: Number,
			required: false,
			default: Number.NEGATIVE_INFINITY
		},
		maxPolarAngle: {
			type: Number,
			required: false,
			default: Math.PI
		},
		minPolarAngle: {
			type: Number,
			required: false,
			default: 0
		},
		minDistance: {
			type: Number,
			required: false,
			default: 0
		},
		maxDistance: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		minZoom: {
			type: Number,
			required: false,
			default: 0
		},
		maxZoom: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		touches: {
			type: Object,
			required: false,
			default: () => ({
				ONE: TOUCH.ROTATE,
				TWO: TOUCH.DOLLY_PAN
			})
		},
		enableZoom: {
			type: Boolean,
			required: false,
			default: true
		},
		zoomSpeed: {
			type: Number,
			required: false,
			default: 1
		},
		enableRotate: {
			type: Boolean,
			required: false,
			default: true
		},
		rotateSpeed: {
			type: Number,
			required: false,
			default: 1
		},
		mouseButtons: {
			type: Object,
			required: false,
			default: () => ({
				LEFT: MOUSE.ROTATE,
				MIDDLE: MOUSE.DOLLY,
				RIGHT: MOUSE.PAN
			})
		}
	},
	emits: [
		"change",
		"start",
		"end"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { makeDefault, autoRotate, autoRotateSpeed, enableDamping, dampingFactor, enablePan, keyPanSpeed, maxAzimuthAngle, minAzimuthAngle, maxPolarAngle, minPolarAngle, minDistance, maxDistance, minZoom, maxZoom, enableZoom, zoomSpeed, enableRotate, touches, rotateSpeed, target, mouseButtons } = toRefs(props);
		const { camera: activeCamera, renderer, extend: extend$1, controls, invalidate } = useTres();
		const controlsRef = shallowRef(null);
		extend$1({ OrbitControls });
		watch(controlsRef, (value) => {
			addEventListeners();
			if (value && makeDefault.value) controls.value = value;
			else controls.value = null;
		});
		function addEventListeners() {
			useEventListener(controlsRef.value, "change", () => {
				emit("change", controlsRef.value);
				invalidate();
			});
			useEventListener(controlsRef.value, "start", () => emit("start", controlsRef.value));
			useEventListener(controlsRef.value, "end", () => emit("end", controlsRef.value));
		}
		const { onBeforeRender } = useLoop();
		onBeforeRender(() => {
			if (controlsRef.value && (enableDamping.value || autoRotate.value)) {
				controlsRef.value.update();
				if (autoRotate.value) {}
			}
		});
		onUnmounted(() => {
			if (controlsRef.value) controlsRef.value.dispose();
		});
		__expose({ instance: controlsRef });
		return (_ctx, _cache) => {
			return (__props.camera || unref(activeCamera)) && (__props.domElement || unref(renderer).domElement) ? (openBlock(), createElementBlock("TresOrbitControls", {
				ref_key: "controlsRef",
				ref: controlsRef,
				key: (__props.camera || unref(activeCamera))?.uuid,
				target: unref(target),
				"auto-rotate": unref(autoRotate),
				"auto-rotate-speed": unref(autoRotateSpeed),
				"enable-damping": unref(enableDamping),
				"damping-factor": unref(dampingFactor),
				"enable-pan": unref(enablePan),
				"key-pan-speed": unref(keyPanSpeed),
				keys: __props.keys,
				"max-azimuth-angle": unref(maxAzimuthAngle),
				"min-azimuth-angle": unref(minAzimuthAngle),
				"max-polar-angle": unref(maxPolarAngle),
				"min-polar-angle": unref(minPolarAngle),
				"min-distance": unref(minDistance),
				"max-distance": unref(maxDistance),
				"min-zoom": unref(minZoom),
				"max-zoom": unref(maxZoom),
				touches: unref(touches),
				"enable-zoom": unref(enableZoom),
				"zoom-speed": unref(zoomSpeed),
				"enable-rotate": unref(enableRotate),
				"rotate-speed": unref(rotateSpeed),
				"mouse-buttons": unref(mouseButtons),
				args: [__props.camera || unref(activeCamera), __props.domElement || unref(renderer).domElement]
			}, null, 8, _hoisted_1$44)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/controls/OrbitControls.vue
var OrbitControls_default = OrbitControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/controls/PointerLockControls.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$43 = ["args"];
var PointerLockControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "PointerLockControls",
	props: {
		makeDefault: {
			type: Boolean,
			required: false,
			default: false
		},
		camera: {
			type: Object,
			required: false
		},
		domElement: {
			type: null,
			required: false
		},
		selector: {
			type: String,
			required: false
		}
	},
	emits: ["isLock", "change"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { camera: activeCamera, renderer, extend: extend$1, controls, invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const controlsRef = shallowRef(null);
		let triggerSelector;
		extend$1({ PointerLockControls });
		const isLockEmitter = (event) => {
			emit("isLock", event);
		};
		watch(controlsRef, (value) => {
			if (value && props.makeDefault) controls.value = value;
			else controls.value = null;
			triggerSelector = document.getElementById(props.selector || "") || renderer.domElement;
			useEventListener(triggerSelector, "click", () => {
				if (controlsRef.value) {
					controlsRef.value.lock();
					controlsRef.value.addEventListener("lock", () => isLockEmitter(true));
					controlsRef.value.addEventListener("unlock", () => isLockEmitter(false));
					invalidate();
				}
			});
		});
		onUnmounted(() => {
			const controls$1 = controlsRef.value;
			if (controls$1) {
				controls$1.removeEventListener("lock", () => isLockEmitter(true));
				controls$1.removeEventListener("unlock", () => isLockEmitter(false));
				controls$1.dispose();
			}
		});
		__expose({ instance: controls });
		return (_ctx, _cache) => {
			return (__props.camera || unref(activeCamera)) && (__props.domElement || unref(renderer).domElement) ? (openBlock(), createElementBlock("TresPointerLockControls", {
				key: 0,
				ref_key: "controlsRef",
				ref: controlsRef,
				args: [__props.camera || unref(activeCamera), __props.domElement || unref(renderer).domElement]
			}, null, 8, _hoisted_1$43)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/controls/PointerLockControls.vue
var PointerLockControls_default = PointerLockControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/controls/ScrollControls.vue?vue&type=script&setup=true&lang.ts
var ScrollControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ScrollControls",
	props: {
		pages: {
			type: Number,
			required: false,
			default: 4
		},
		distance: {
			type: Number,
			required: false,
			default: 4
		},
		smoothScroll: {
			type: Number,
			required: false,
			default: .1
		},
		horizontal: {
			type: Boolean,
			required: false,
			default: false
		},
		htmlScroll: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	emits: ["update:modelValue"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		if (props.smoothScroll < 0) logWarning("SmoothControl must be greater than zero");
		if (props.pages < 0) logWarning("Pages must be greater than zero");
		const { camera, controls, renderer } = useTresContext();
		watch(props, () => {
			renderer.invalidate();
		});
		const wrapperRef = shallowRef();
		const scrollContainer = document.createElement("div");
		const { y: windowY } = useWindowScroll();
		const { x: containerX, y: containerY, isScrolling } = useScroll(scrollContainer);
		const { height, width } = useWindowSize();
		let initCameraPos = 0;
		const initialized = ref(false);
		const progress = ref(0);
		const progressScroll = ref(0);
		const scrollNodeY = ref(0);
		const direction = props.horizontal ? "x" : "y";
		const unWatch = watch(camera.activeCamera, (value) => {
			if (initialized.value) {
				unWatch();
				return;
			}
			initCameraPos = props.horizontal ? value?.position.x || 0 : value?.position.y || 0;
			initialized.value = true;
		}, { immediate: true });
		watch(isScrolling, (value) => {
			if (controls.value) controls.value.enabled = !value;
		}, { immediate: true });
		watch(windowY, (value) => {
			if (!isScrolling.value && !props.htmlScroll) return;
			progressScroll.value = value / height.value / (scrollNodeY.value / height.value - 1);
			progress.value = -1 * progressScroll.value;
			emit("update:modelValue", progressScroll.value);
		});
		watch(containerY, (value) => {
			progressScroll.value = value / height.value / (scrollNodeY.value / height.value);
			progress.value = -1 * progressScroll.value;
			emit("update:modelValue", progressScroll.value);
		});
		watch(containerX, (value) => {
			progressScroll.value = value / width.value / (scrollNodeY.value / width.value - 1);
			progress.value = +progressScroll.value;
			emit("update:modelValue", progressScroll.value);
		});
		watch(() => renderer.instance, (value) => {
			const canvas = value?.domElement;
			if (props.htmlScroll && value?.domElement) {
				if (canvas?.style.width && canvas?.style.position && canvas?.style.top && canvas?.style.left) {
					canvas.style.width = "100%";
					canvas.style.position = "fixed";
					canvas.style.zIndex = " -99999";
					canvas.style.top = "0";
					canvas.style.left = "0";
				}
				scrollNodeY.value = document.body.scrollHeight;
			} else {
				const fixed = document.createElement("div");
				const fill = document.createElement("div");
				scrollContainer.style[props.horizontal ? "overflowX" : "overflowY"] = "auto";
				scrollContainer.style[props.horizontal ? "overflowY" : "overflowX"] = "hidden";
				scrollContainer.style.position = "absolute";
				scrollContainer.style.width = "100%";
				scrollContainer.style.height = " 100%";
				scrollContainer.style.top = "0";
				scrollContainer.style.left = "0";
				scrollContainer.classList.add("scrollContainer");
				fixed.style.position = "sticky";
				fixed.style.top = "0px";
				fixed.style.left = "0px";
				fixed.style.width = "100%";
				fixed.style.height = "100%";
				fixed.style.overflow = "hidden";
				scrollContainer.appendChild(fixed);
				fill.style.height = props.horizontal ? "100%" : `${height.value * props.pages}px`;
				fill.style.width = props.horizontal ? `${width.value * props.pages}px` : "100vw";
				fill.style.pointerEvents = "none";
				canvas.style.position = "fixed";
				canvas.style.zIndex = "0";
				if (canvas?.style.width) canvas.style.width = "100%";
				scrollContainer.appendChild(fill);
				if (value?.domElement.parentNode) value.domElement.parentNode.style.position = "relative";
				value?.domElement?.parentNode?.appendChild(scrollContainer);
				scrollNodeY.value = props.horizontal ? width.value * props.pages : height.value * props.pages;
			}
		}, { immediate: true });
		const { onBeforeRender } = useLoop();
		onBeforeRender(() => {
			if (camera.activeCamera.value?.position) {
				const delta = (progress.value * props.distance - camera.activeCamera.value.position[direction] + initCameraPos) * props.smoothScroll;
				camera.activeCamera.value.position[direction] += delta;
				if (wrapperRef.value.children.length > 0) wrapperRef.value.position[direction] += delta;
			}
		});
		__expose({ instance: wrapperRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "wrapperRef",
				ref: wrapperRef
			}, [renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});

//#endregion
//#region src/core/controls/ScrollControls.vue
var ScrollControls_default = ScrollControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/controls/TransformControls.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$42 = [
	"object",
	"args",
	"mode",
	"enabled",
	"axis",
	"translation-snap",
	"rotation-snap",
	"scale-snap",
	"space",
	"size",
	"show-x",
	"show-y",
	"show-z"
];
var TransformControls_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "TransformControls",
	props: {
		object: {
			type: Object,
			required: true
		},
		camera: {
			type: Object,
			required: false
		},
		mode: {
			type: String,
			required: false,
			default: "translate"
		},
		enabled: {
			type: Boolean,
			required: false,
			default: true
		},
		axis: {
			type: String,
			required: false,
			default: "XYZ"
		},
		translationSnap: {
			type: Number,
			required: false
		},
		rotationSnap: {
			type: Number,
			required: false
		},
		scaleSnap: {
			type: Number,
			required: false
		},
		space: {
			type: String,
			required: false,
			default: "world"
		},
		size: {
			type: Number,
			required: false,
			default: 1
		},
		showX: {
			type: Boolean,
			required: false,
			default: true
		},
		showY: {
			type: Boolean,
			required: false,
			default: true
		},
		showZ: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	emits: [
		"dragging",
		"change",
		"mouseDown",
		"mouseUp",
		"objectChange"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { object, mode, enabled, axis, translationSnap, rotationSnap, scaleSnap, space, size, showX, showY, showZ } = toRefs(props);
		const controlsRef = shallowRef(null);
		const { controls, camera: activeCamera, renderer, extend: extend$1, invalidate } = useTres();
		watch([
			object,
			mode,
			enabled,
			axis,
			translationSnap,
			rotationSnap,
			scaleSnap,
			space,
			size,
			showX,
			showY,
			showZ
		], () => {
			invalidate();
		});
		extend$1({ TransformControls });
		const onChange = () => {
			invalidate();
			emit("change");
		};
		const onDragingChange = (e) => {
			if (controls.value) controls.value.enabled = !e.value;
			invalidate();
			emit("dragging", e.value);
		};
		const onMouseDown = () => {
			invalidate();
			emit("mouseDown");
		};
		const onMouseUp = () => {
			invalidate();
			emit("mouseUp");
		};
		const onObjectChange = () => {
			invalidate();
			emit("objectChange");
		};
		function addEventListeners() {
			useEventListener(controlsRef.value, "change", onChange);
			useEventListener(controlsRef.value, "dragging-changed", onDragingChange);
			useEventListener(controlsRef.value, "mouseDown", onMouseDown);
			useEventListener(controlsRef.value, "mouseUp", onMouseUp);
			useEventListener(controlsRef.value, "objectChange", onObjectChange);
		}
		watch(controlsRef, (value) => {
			if (value) addEventListeners();
		});
		onUnmounted(() => {
			if (controlsRef.value) controlsRef.value.dispose();
		});
		__expose({ instance: controlsRef });
		return (_ctx, _cache) => {
			return (__props.camera || unref(activeCamera)) && unref(renderer).domElement ? (openBlock(), createElementBlock("TresTransformControls", {
				ref_key: "controlsRef",
				ref: controlsRef,
				key: (__props.camera || unref(activeCamera))?.uuid,
				object: unref(object),
				args: [__props.camera || unref(activeCamera), unref(renderer).domElement],
				mode: unref(mode),
				enabled: unref(enabled),
				axis: unref(axis),
				"translation-snap": unref(translationSnap),
				"rotation-snap": unref(rotationSnap),
				"scale-snap": unref(scaleSnap),
				space: unref(space),
				size: unref(size),
				"show-x": unref(showX),
				"show-y": unref(showY),
				"show-z": unref(showZ),
				visible: true
			}, null, 8, _hoisted_1$42)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/controls/TransformControls.vue
var TransformControls_default = TransformControls_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/loaders/useSVG/index.ts
/**
* Vue composable for loading SVG files in TresJS
*
* @remarks
* This composable uses Three.js SVGLoader under the hood to load and process SVG files
* into geometries and materials that can be rendered in a 3D scene.
*
* @example
* ```ts
* const { state: svg, layers } = useSVG('/path/to/file.svg', { skipStrokes: false })
* ```
*
* @param {MaybeRef<string>} path - Path to the SVG file or SVG data string
* @param {UseSVGOptions} options - Options for processing the SVG
* @returns Object containing the SVG state, loading state, processed layers and disposal function
*/
function useSVG(path, options = {}) {
	const { skipStrokes = false, skipFills = false, fillMaterial = {}, strokeMaterial = {}, depth = "renderOrder" } = options;
	const result = useLoader(SVGLoader, computed(() => {
		const pathValue = typeof path === "string" ? path : path.value;
		return !pathValue.startsWith("<svg") ? pathValue : encodeURI(`data:image/svg+xml;utf8,${pathValue}`);
	}), {});
	/**
	* Process SVG paths into renderable layers
	*/
	const layers = computed(() => {
		if (!result.state.value?.paths) return [];
		const _layers = [];
		const paths = result.state.value.paths;
		const [depthWrite, offsetZ] = (() => {
			return typeof depth === "number" ? [true, depth] : [{
				flat: false,
				renderOrder: false,
				offsetZ: true
			}[depth], {
				flat: 0,
				renderOrder: 0,
				offsetZ: .025
			}[depth]];
		})();
		let layerIndex = 0;
		for (const path$1 of paths) {
			const style = path$1.userData?.style ?? {};
			if (!skipFills && style.fill !== void 0 && style.fill !== "none") {
				const fillMat = {
					color: style.fill,
					opacity: style.fillOpacity,
					transparent: true,
					side: DoubleSide,
					depthWrite,
					...fillMaterial
				};
				for (const shape of SVGLoader.createShapes(path$1)) {
					const geometry = new ShapeGeometry(shape);
					geometry.scale(1, -1, 1);
					if (offsetZ) geometry.translate(0, 0, layerIndex * offsetZ);
					_layers.push({
						geometry,
						material: fillMat,
						isStroke: false
					});
					layerIndex++;
				}
			}
			if (!skipStrokes && style.stroke !== void 0 && style.stroke !== "none") {
				const strokeMat = {
					color: style.stroke,
					opacity: style.strokeOpacity,
					transparent: true,
					side: DoubleSide,
					depthWrite,
					...strokeMaterial
				};
				for (const subPath of path$1.subPaths) {
					const points = subPath.getPoints().map((v2$1) => new Vector2(v2$1.x, -v2$1.y));
					const geometry = SVGLoader.pointsToStroke(points, style);
					if (offsetZ) geometry.translate(0, 0, layerIndex * offsetZ);
					_layers.push({
						geometry,
						material: strokeMat,
						isStroke: true
					});
					layerIndex++;
				}
			}
		}
		return _layers;
	});
	/**
	* Dispose of all geometries to free memory
	*/
	const dispose = () => {
		layers.value.forEach((layer) => layer.geometry.dispose());
	};
	return {
		...result,
		layers,
		dispose
	};
}

//#endregion
//#region src/core/loaders/useSVG/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$41 = { key: 0 };
const _hoisted_2$25 = ["geometry", "render-order"];
var component_vue_vue_type_script_setup_true_lang_default$9 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		src: {
			type: String,
			required: true
		},
		skipStrokes: {
			type: Boolean,
			required: false,
			default: false
		},
		skipFills: {
			type: Boolean,
			required: false,
			default: false
		},
		fillMaterial: {
			type: Object,
			required: false
		},
		strokeMaterial: {
			type: Object,
			required: false
		},
		fillMeshProps: {
			type: Object,
			required: false
		},
		strokeMeshProps: {
			type: Object,
			required: false
		},
		depth: {
			type: [String, Number],
			required: false,
			default: "renderOrder"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { state, isLoading, layers, dispose } = useSVG(props.src, {
			skipStrokes: props.skipStrokes,
			skipFills: props.skipFills,
			fillMaterial: props.fillMaterial,
			strokeMaterial: props.strokeMaterial,
			depth: props.depth
		});
		__expose({
			instance: state,
			layers
		});
		onUnmounted(() => {
			dispose();
		});
		return (_ctx, _cache) => {
			return !unref(isLoading) ? (openBlock(), createElementBlock("TresGroup", _hoisted_1$41, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(layers), ({ geometry, material, isStroke }, i) => {
				return openBlock(), createElementBlock("TresMesh", mergeProps({ key: `${i}` }, { ref_for: true }, isStroke ? props.strokeMeshProps : props.fillMeshProps, {
					geometry,
					"render-order": props.depth === "renderOrder" ? i : 0
				}), [createElementVNode("TresMeshBasicMaterial", mergeProps({ ref_for: true }, material), null, 16)], 16, _hoisted_2$25);
			}), 128))])) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/loaders/useSVG/component.vue
var component_default$17 = component_vue_vue_type_script_setup_true_lang_default$9;

//#endregion
//#region src/core/loaders/useFBX/index.ts
/**
* Vue composable for loading FBX models in TresJS
*
* @remarks
* This composable uses Three.js FBXLoader under the hood to load FBX 3D models.
* The loaded model is automatically parsed and made available as a reactive state.
*
* @example
* ```ts
* const { state: model } = useFBX('/path/to/model.fbx')
* ```
*
* @param {MaybeRef<string>} path - Path to the FBX model file
* @returns {{ state: Group, isLoading: boolean, execute: () => Promise<void>, nodes: object, materials: object }} Object containing the model state, loading state, reload function, and parsed nodes/materials
*/
function useFBX(path, options) {
	const result = useLoader(FBXLoader, path);
	if (options?.traverse) watch(result.state, (state) => {
		state.traverse((child) => options.traverse?.(child));
	});
	const nodes = computed(() => {
		return result.state.value ? buildGraph(result.state.value).nodes : {};
	});
	const materials = computed(() => {
		return result.state.value ? buildGraph(result.state.value).materials : {};
	});
	return {
		...result,
		nodes,
		materials
	};
}

//#endregion
//#region src/core/loaders/useFBX/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$40 = ["object"];
var component_vue_vue_type_script_setup_true_lang_default$8 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		path: {
			type: String,
			required: true
		},
		castShadow: {
			type: Boolean,
			required: false,
			default: false
		},
		receiveShadow: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { state: model, isLoading } = useFBX(props.path);
		__expose({ instance: model });
		watchEffect(() => {
			if (model.value && (props.castShadow || props.receiveShadow)) model.value.traverse((child) => {
				if (child instanceof Mesh) {
					child.castShadow = props.castShadow;
					child.receiveShadow = props.receiveShadow;
				}
			});
		});
		return (_ctx, _cache) => {
			return !unref(isLoading) && unref(model) ? (openBlock(), createElementBlock("primitive", {
				key: 0,
				object: unref(model)
			}, null, 8, _hoisted_1$40)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/loaders/useFBX/component.vue
var component_default$5 = component_vue_vue_type_script_setup_true_lang_default$8;

//#endregion
//#region src/core/loaders/useGLTF/index.ts
/**
* Vue composable for loading GLTF models in TresJS
*
* @remarks
* This composable uses Three.js GLTFLoader under the hood and supports DRACO compression.
* When DRACO compression is enabled, it will use the specified decoder path or fallback to Google's CDN.
*
* @example
* ```ts
* const { state: model } = useGLTF('/path/to/model.glb', { draco: true })
* ```
*
* @param {MaybeRef<string>} path - Path to the GLTF model file
* @param {UseGLTFOptions} options - Options for loading the model
* @returns {{ state: GLTF, isLoading: boolean, execute: () => Promise<void> }} Object containing the model state, loading state and reload function
*/
function useGLTF(path, options) {
	const useLoaderOptions = {};
	if (options?.draco) {
		const dracoLoader = new DRACOLoader();
		dracoLoader.setDecoderPath(options.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.5.6/");
		useLoaderOptions.extensions = (loader) => {
			if (loader instanceof GLTFLoader) loader.setDRACOLoader(dracoLoader);
		};
	}
	const result = useLoader(GLTFLoader, path, useLoaderOptions);
	if (options?.traverse) watch(result.state, (state) => {
		state.scene.traverse((child) => options.traverse?.(child));
	});
	const nodes = computed(() => {
		return result.state.value?.scene ? buildGraph(result.state.value?.scene).nodes : {};
	});
	const materials = computed(() => {
		return result.state.value?.scene ? buildGraph(result.state.value?.scene).materials : {};
	});
	return {
		...result,
		nodes,
		materials
	};
}

//#endregion
//#region src/core/loaders/useGLTF/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$39 = ["object"];
var component_vue_vue_type_script_setup_true_lang_default$7 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		path: {
			type: String,
			required: true
		},
		draco: {
			type: Boolean,
			required: false,
			default: false
		},
		castShadow: {
			type: Boolean,
			required: false,
			default: false
		},
		receiveShadow: {
			type: Boolean,
			required: false,
			default: false
		},
		decoderPath: {
			type: String,
			required: false,
			default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { state, isLoading } = useGLTF(props.path, {
			draco: props.draco,
			decoderPath: props.decoderPath
		});
		__expose({ instance: state });
		watchEffect(() => {
			if (state.value?.scene && (props.castShadow || props.receiveShadow)) state.value.scene.traverse((child) => {
				if (child instanceof Mesh) {
					child.castShadow = props.castShadow;
					child.receiveShadow = props.receiveShadow;
				}
			});
		});
		return (_ctx, _cache) => {
			return !unref(isLoading) && unref(state)?.scene ? (openBlock(), createElementBlock("primitive", {
				key: 0,
				object: unref(state)?.scene
			}, null, 8, _hoisted_1$39)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/loaders/useGLTF/component.vue
var component_default$7 = component_vue_vue_type_script_setup_true_lang_default$7;

//#endregion
//#region src/core/loaders/useTexture/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default$6 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		path: {
			type: String,
			required: true
		},
		manager: {
			type: Object,
			required: false
		}
	},
	emits: ["loaded", "error"],
	setup(__props, { emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { state: texture$1, isLoading, error } = useTexture(props.path);
		whenever(error, (err) => {
			if (err) emit("error", err);
		});
		whenever(texture$1, (value) => {
			if (value) emit("loaded", value);
		});
		return (_ctx, _cache) => {
			return renderSlot(_ctx.$slots, "default", {
				state: unref(texture$1),
				isLoading: unref(isLoading),
				error: unref(error)
			});
		};
	}
});

//#endregion
//#region src/core/loaders/useTexture/component.vue
var component_default$18 = component_vue_vue_type_script_setup_true_lang_default$6;

//#endregion
//#region src/core/loaders/useProgress.ts
let saveLastTotalLoaded = 0;
function useProgress() {
	const hasFinishLoading = ref(false);
	const progress = ref(0);
	const items = ref([]);
	return new Promise((resolve) => {
		DefaultLoadingManager.onStart = () => {
			hasFinishLoading.value = false;
		};
		DefaultLoadingManager.onLoad = () => {
			hasFinishLoading.value = true;
		};
		DefaultLoadingManager.onProgress = (item, loaded, total) => {
			if (loaded === total) {
				saveLastTotalLoaded = total;
				hasFinishLoading.value = true;
				items.value.push(item);
			}
			progress.value = Math.round((loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100 || 100);
		};
		DefaultLoadingManager.onError = (error) => {
			logError("Error loading assets", new Error(error));
			hasFinishLoading.value = true;
		};
		resolve({
			items,
			hasFinishLoading,
			progress
		});
	});
}

//#endregion
//#region src/core/loaders/useVideoTexture.ts
/**
* Composable for loading video textures.
*
* ```ts
* import { ref } from 'vue'
* import { useVideoTexture } from '@tresjs/cientos'
* import MyVideo from 'MyVideo.mp4'
*
* const texture = ref()
* texture.value = await useVideoTexture(MyVideo)
* ```
* Then you can use the texture in your material.
*
* ```vue
* <TresMeshBasicMaterial :map="texture" />
* ```
* @see https://threejs.org/docs/index.html?q=video#api/en/textures/VideoTexture
* @export
* @param {HTMLVideoElement} src
* @return {VideoTexture}  {VideoTexture}
*/
async function useVideoTexture(src, options) {
	/**
	* Load a video as a texture.
	*
	* @param {src} string
	* @return {VideoTexture}  {VideoTexture}
	*/
	if (!src) return logError("Error no path provided");
	const { unsuspend, start, crossOrigin, muted, loop, ...rest } = {
		unsuspend: "loadedmetadata",
		crossOrigin: "Anonymous",
		muted: true,
		loop: true,
		start: true,
		playsInline: true,
		...options
	};
	function loadTexture() {
		return new Promise((resolve, reject) => {
			const video = Object.assign(document.createElement("video"), {
				src: typeof src === "string" && src || void 0,
				crossOrigin,
				loop,
				muted,
				autoplay: true,
				...rest
			});
			const texture$1 = new VideoTexture(video);
			video.addEventListener(unsuspend, () => resolve(texture$1));
			video.addEventListener("error", () => reject(/* @__PURE__ */ new Error("Error loading video")));
			return texture$1;
		});
	}
	try {
		const texture$1 = await loadTexture();
		if (start && texture$1.image) texture$1.image.play();
		return texture$1;
	} catch {
		logError("Error loading resource");
	}
}

//#endregion
//#region src/core/loaders/useTextures/index.ts
/**
* Composable that loads multiple textures at once
*
* @param paths - Array of paths to texture files
* @returns Object containing textures, loading state, and error state
*/
function useTextures(paths) {
	const error = ref(null);
	const results = unref(paths).map((path) => {
		try {
			return useLoader(TextureLoader, path, { initialValue: new Texture() });
		} catch (err) {
			error.value = err;
			return ref(null);
		}
	});
	return {
		textures: computed(() => {
			return results.map((result) => {
				if (result && "state" in result) return result.state.value;
				return null;
			}).filter(Boolean);
		}),
		isLoading: computed(() => {
			return results.some((result) => {
				if (result && "isLoading" in result) return result.isLoading.value;
				return false;
			});
		}),
		error: computed(() => {
			const errors = [];
			results.forEach((result) => {
				if (result && "error" in result && result.error) {
					const err = result.error;
					if (err instanceof Error) errors.push(err);
					else if (typeof err === "object" && err !== null && "message" in err) errors.push(new Error(String(err.message)));
				}
			});
			if (error.value) errors.push(error.value);
			return errors.length > 0 ? errors : null;
		})
	};
}

//#endregion
//#region src/core/materials/customShaderMaterial/index.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$38 = ["args"];
var index_vue_vue_type_script_setup_true_lang_default$6 = /* @__PURE__ */ defineComponent({
	__name: "index",
	props: {
		baseMaterial: {
			type: Function,
			required: true
		},
		vertexShader: {
			type: String,
			required: false
		},
		fragmentShader: {
			type: String,
			required: false
		},
		silent: {
			type: Boolean,
			required: false
		},
		uniforms: {
			type: Object,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const customShaderMaterialClass = shallowRef(null);
		const { extend: extend$1, invalidate } = useTres();
		extend$1({ CustomShaderMaterial });
		watch(props, () => {
			invalidate();
		});
		__expose({ instance: customShaderMaterialClass });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresCustomShaderMaterial", {
				ref_key: "customShaderMaterialClass",
				ref: customShaderMaterialClass,
				args: [props]
			}, null, 8, _hoisted_1$38);
		};
	}
});

//#endregion
//#region src/core/materials/customShaderMaterial/index.vue
var customShaderMaterial_default = index_vue_vue_type_script_setup_true_lang_default$6;

//#endregion
//#region src/core/materials/holographicMaterial/HolographicMaterialParameters.ts
var HolographicMaterial = class extends ShaderMaterial {
	clock;
	/**
	* Create a HolographicMaterial.
	*
	* @param {object} parameters - The parameters to configure the material.
	* @param {number} [parameters.time] - The time uniform representing animation time.
	* @param {number} [parameters.fresnelOpacity] - The opacity for the fresnel effect.
	* @param {number} [parameters.fresnelAmount] - The strength of the fresnel effect.
	* @param {number} [parameters.scanlineSize] - The size of the scanline effect.
	* @param {number} [parameters.hologramBrightness] - The brightness of the hologram.
	* @param {number} [parameters.signalSpeed] - The speed of the signal effect.
	* @param {Color} [parameters.hologramColor] - The color of the hologram.
	* @param {boolean} [parameters.enableBlinking] - Enable/disable blinking effect.
	* @param {boolean} [parameters.blinkFresnelOnly] - Enable blinking only on the fresnel effect.
	* @param {number} [parameters.hologramOpacity] - The opacity of the hologram.
	* @param {number} [parameters.blendMode] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
	* @param {number} [parameters.side] - The rendering side. Use `THREE.FrontSide`,
	*  `THREE.BackSide`, or `THREE.DoubleSide`.
	* @param {boolean} [parameters.depthTest] - Enable or disable depthTest.
	*/
	constructor(parameters = {}) {
		super();
		this.vertexShader = `
      #define STANDARD
      varying vec3 vViewPosition;
      #ifdef USE_TRANSMISSION
      varying vec3 vWorldPosition;
      #endif
    
      varying vec2 vUv;
      varying vec4 vPos;
      varying vec3 vNormalW;
      varying vec3 vPositionW;

      #include <common>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>

      void main() {
        
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
      
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
      
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
      
        #endif
      
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
      
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;

        vUv = uv;
        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
        
        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );

      }`;
		this.fragmentShader = ` 
      varying vec2 vUv;
      varying vec3 vPositionW;
      varying vec4 vPos;
      varying vec3 vNormalW;
      
      uniform float time;
      uniform float fresnelOpacity;
      uniform float scanlineSize;
      uniform float fresnelAmount;
      uniform float signalSpeed;
      uniform float hologramBrightness;
      uniform float hologramOpacity;
      uniform bool blinkFresnelOnly;
      uniform bool enableBlinking;
      uniform vec3 hologramColor;

      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }

      void main() {
        vec2 vCoords = vPos.xy;
        vCoords /= vPos.w;
        vCoords = vCoords * 0.5 + 0.5;
        vec2 myUV = fract( vCoords );

        // Defines hologram main color
        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));

        // Add scanlines
        float scanlines = 10.;
        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);

        // Scanlines offsets
        float r = random(vUv.x, vUv.y);
        float g = random(vUv.y * 20.2, vUv.y * .2);
        float b = random(vUv.y * .9, vUv.y * .2);

        // Scanline composition
        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);

        // Calculates fresnel
        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);

        // Blinkin effect
        //Suggested by Octano - https://x.com/OtanoDesign?s=20
        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
        float blink = flicker(blinkValue, time * signalSpeed * .02);

        // Final shader composition
        vec3 finalColor;

        if(blinkFresnelOnly){
          finalColor = scanlineMix.rgb + fresnelEffect * blink;
        }else{
          finalColor = scanlineMix.rgb * blink + fresnelEffect;
        }

        gl_FragColor = vec4( finalColor, hologramOpacity);

      }`;
		this.uniforms = {
			time: new Uniform(0),
			fresnelOpacity: new Uniform(parameters.fresnelOpacity !== void 0 ? parameters.fresnelOpacity : 1),
			fresnelAmount: new Uniform(parameters.fresnelAmount !== void 0 ? parameters.fresnelAmount : .45),
			scanlineSize: new Uniform(parameters.scanlineSize !== void 0 ? parameters.scanlineSize : 8),
			hologramBrightness: new Uniform(parameters.hologramBrightness !== void 0 ? parameters.hologramBrightness : 1),
			signalSpeed: new Uniform(parameters.signalSpeed !== void 0 ? parameters.signalSpeed : 1),
			hologramColor: new Uniform(parameters.hologramColor !== void 0 ? new Color(parameters.hologramColor) : new Color("#00d5ff")),
			enableBlinking: new Uniform(parameters.enableBlinking !== void 0 ? parameters.enableBlinking : true),
			blinkFresnelOnly: new Uniform(parameters.blinkFresnelOnly !== void 0 ? parameters.blinkFresnelOnly : true),
			hologramOpacity: new Uniform(parameters.hologramOpacity !== void 0 ? parameters.hologramOpacity : 1)
		};
		this.clock = new Clock();
		this.setValues(parameters);
		this.depthTest = parameters.depthTest !== void 0 ? parameters.depthTest : false;
		this.blending = parameters.blendMode !== void 0 ? parameters.blendMode : AdditiveBlending;
		this.transparent = true;
		this.side = parameters.side !== void 0 ? parameters.side : FrontSide;
	}
	update() {
		this.uniforms.time.value = this.clock.getElapsedTime();
	}
};
var HolographicMaterialParameters_default = HolographicMaterial;

//#endregion
//#region src/core/materials/holographicMaterial/index.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$37 = [
	"uniforms-fresnelAmount-value",
	"uniforms-enableBlinking-value",
	"uniforms-fresnelOpacity-value",
	"uniforms-hologramBrightness-value",
	"uniforms-scanlineSize-value",
	"uniforms-signalSpeed-value",
	"uniforms-hologramColor-value",
	"uniforms-hologramOpacity-value",
	"uniforms-blinkFresnelOnly-value",
	"enableAdditive",
	"side"
];
var index_vue_vue_type_script_setup_true_lang_default$5 = /* @__PURE__ */ defineComponent({
	__name: "index",
	props: {
		fresnelAmount: {
			type: Number,
			required: false,
			default: .45
		},
		fresnelOpacity: {
			type: Number,
			required: false,
			default: 1
		},
		blinkFresnelOnly: {
			type: Boolean,
			required: false,
			default: true
		},
		enableBlinking: {
			type: Boolean,
			required: false,
			default: true
		},
		enableAdditive: {
			type: Boolean,
			required: false,
			default: true
		},
		hologramBrightness: {
			type: Number,
			required: false,
			default: .7
		},
		scanlineSize: {
			type: Number,
			required: false,
			default: 8
		},
		signalSpeed: {
			type: Number,
			required: false,
			default: .45
		},
		hologramOpacity: {
			type: Number,
			required: false,
			default: 1
		},
		hologramColor: {
			type: null,
			required: false,
			default: "#00d5ff"
		},
		side: {
			type: null,
			required: false,
			default: FrontSide
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const MeshHolographicMaterialClass = shallowRef();
		const { extend: extend$1 } = useTresContext();
		extend$1({ HolographicMaterial: HolographicMaterialParameters_default });
		__expose({
			root: MeshHolographicMaterialClass,
			constructor: HolographicMaterialParameters_default
		});
		const colorValue = computed(() => new Color(props.hologramColor));
		const { onBeforeRender } = useLoop();
		onBeforeRender(() => {
			MeshHolographicMaterialClass.value?.update();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresHolographicMaterial", {
				ref_key: "MeshHolographicMaterialClass",
				ref: MeshHolographicMaterialClass,
				"uniforms-fresnelAmount-value": props.fresnelAmount,
				"uniforms-enableBlinking-value": props.enableBlinking,
				"uniforms-fresnelOpacity-value": props.fresnelOpacity,
				"uniforms-hologramBrightness-value": props.hologramBrightness,
				"uniforms-scanlineSize-value": props.scanlineSize,
				"uniforms-signalSpeed-value": props.signalSpeed,
				"uniforms-hologramColor-value": colorValue.value,
				"uniforms-hologramOpacity-value": props.hologramOpacity,
				"uniforms-blinkFresnelOnly-value": props.blinkFresnelOnly,
				enableAdditive: props.enableAdditive,
				side: props.side
			}, null, 8, _hoisted_1$37);
		};
	}
});

//#endregion
//#region src/core/materials/holographicMaterial/index.vue
var holographicMaterial_default = index_vue_vue_type_script_setup_true_lang_default$5;

//#endregion
//#region src/core/materials/meshDiscardMaterial/material.ts
var MeshDiscardMaterial = class extends ShaderMaterial {
	constructor() {
		super();
		this.vertexShader = "void main() { }";
		this.fragmentShader = "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;}";
	}
};

//#endregion
//#region src/core/materials/meshDiscardMaterial/index.vue?vue&type=script&setup=true&lang.ts
var index_vue_vue_type_script_setup_true_lang_default$4 = /* @__PURE__ */ defineComponent({
	__name: "index",
	setup(__props, { expose: __expose }) {
		const meshDiscardMaterialRef = shallowRef();
		const { extend: extend$1 } = useTresContext();
		extend$1({ MeshDiscardMaterial });
		__expose({ instance: meshDiscardMaterialRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMeshDiscardMaterial", {
				ref_key: "meshDiscardMaterialRef",
				ref: meshDiscardMaterialRef
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/materials/meshDiscardMaterial/index.vue
var meshDiscardMaterial_default = index_vue_vue_type_script_setup_true_lang_default$4;

//#endregion
//#region src/core/materials/meshGlassMaterial/material.ts
var MeshGlassMaterial = class extends MeshStandardMaterial {
	isMeshPhysicalMaterial;
	clearcoatMap;
	clearcoatRoughness;
	clearcoatRoughnessMap;
	clearcoatNormalScale;
	clearcoatNormalMap;
	ior;
	transmissionMap;
	thickness;
	thicknessMap;
	attenuationDistance;
	attenuationColor;
	specularIntensity;
	specularIntensityMap;
	specularColor;
	specularColorMap;
	_clearcoat;
	_transmission;
	constructor(parameters = {}) {
		super();
		this.isMeshPhysicalMaterial = true;
		this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		};
		this.clearcoatMap = null;
		this.clearcoatRoughness = 0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2(1, 1);
		this.clearcoatNormalMap = null;
		this.ior = 1.5;
		Object.defineProperty(this, "reflectivity", {
			get() {
				return MathUtils.clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
			},
			set(reflectivity) {
				this.ior = (1 + .4 * reflectivity) / (1 - .4 * reflectivity);
			}
		});
		this.roughness = 0;
		this.transmissionMap = null;
		this.thickness = .5;
		this.thicknessMap = null;
		this.attenuationDistance = Number.POSITIVE_INFINITY;
		this.attenuationColor = new Color(1, 1, 1);
		this.specularIntensity = 1;
		this.specularIntensityMap = null;
		this.specularColor = new Color(1, 1, 1);
		this.specularColorMap = null;
		this._clearcoat = .5;
		this._transmission = 1;
		this.setValues(parameters);
	}
	get clearcoat() {
		return this._clearcoat;
	}
	set clearcoat(value) {
		if (this._clearcoat > 0 !== value > 0) this.version++;
		this._clearcoat = value;
	}
	get transmission() {
		return this._transmission;
	}
	set transmission(value) {
		if (this._transmission > 0 !== value > 0) this.version++;
		this._transmission = value;
	}
	copy(source) {
		super.copy(source);
		this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		};
		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
		this.ior = source.ior;
		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;
		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy(source.attenuationColor);
		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy(source.specularColor);
		this.specularColorMap = source.specularColorMap;
		return this;
	}
};
var material_default = MeshGlassMaterial;

//#endregion
//#region src/core/materials/meshGlassMaterial/index.vue?vue&type=script&setup=true&lang.ts
var index_vue_vue_type_script_setup_true_lang_default$3 = /* @__PURE__ */ defineComponent({
	__name: "index",
	setup(__props, { expose: __expose }) {
		const MeshGlassMaterialClass = shallowRef();
		const { extend: extend$1 } = useTresContext();
		extend$1({ MeshGlassMaterial: material_default });
		__expose({ instance: MeshGlassMaterialClass });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMeshGlassMaterial", {
				ref_key: "MeshGlassMaterialClass",
				ref: MeshGlassMaterialClass
			}, null, 512);
		};
	}
});

//#endregion
//#region src/core/materials/meshGlassMaterial/index.vue
var meshGlassMaterial_default = index_vue_vue_type_script_setup_true_lang_default$3;

//#endregion
//#region src/utils/constants.ts
const getVersion = () => Number.parseInt(REVISION.replace(/\D+/g, ""));
const version = /* @__PURE__ */ getVersion();

//#endregion
//#region src/core/materials/meshReflectionMaterial/ConvolutionMaterial.ts
var ConvolutionMaterial = class extends ShaderMaterial {
	kernel;
	constructor(texelSize = new Vector2()) {
		super({
			uniforms: {
				inputBuffer: new Uniform(null),
				depthBuffer: new Uniform(null),
				resolution: new Uniform(new Vector2()),
				texelSize: new Uniform(new Vector2()),
				halfTexelSize: new Uniform(new Vector2()),
				kernel: new Uniform(0),
				scale: new Uniform(1),
				cameraNear: new Uniform(0),
				cameraFar: new Uniform(1),
				depthEdge0: new Uniform(0),
				depthEdge1: new Uniform(1),
				depthScale: new Uniform(0),
				depthBias: new Uniform(.25)
			},
			fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float depthEdge0;
        uniform float depthEdge1;
        uniform float depthScale;
        uniform float depthBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(
              1.0 - depthEdge1, 1.0 - depthEdge0,
              1.0 - (depth.r * depth.a) + depthBias
            );
            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);
          #endif

          gl_FragColor = 0.25 * (
            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))
          );
          
          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${version >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }`,
			vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
			blending: NoBlending,
			depthWrite: false,
			depthTest: false
		});
		this.toneMapped = false;
		this.setTexelSize(texelSize.x, texelSize.y);
		this.kernel = new Float32Array([
			0,
			1,
			2,
			2,
			3
		]);
	}
	setTexelSize(x, y) {
		this.uniforms.texelSize.value.set(x, y);
		this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(.5);
	}
	setResolution(resolution) {
		this.uniforms.resolution.value.copy(resolution);
	}
};

//#endregion
//#region src/core/materials/meshReflectionMaterial/BlurPass.ts
var BlurPass = class {
	renderTargetA;
	renderTargetB;
	convolutionMaterial;
	scene;
	camera;
	screen;
	renderToScreen = false;
	constructor({ resolution, width = 500, height = 500, depthEdge0 = 0, depthEdge1 = 1, depthScale = 0, depthBias = .25 }) {
		this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			stencilBuffer: false,
			depthBuffer: false,
			type: HalfFloatType
		});
		this.renderTargetB = this.renderTargetA.clone();
		this.convolutionMaterial = new ConvolutionMaterial();
		this.convolutionMaterial.setTexelSize(1 / width, 1 / height);
		this.convolutionMaterial.setResolution(new Vector2(width, height));
		this.scene = new Scene();
		this.camera = new Camera();
		this.convolutionMaterial.uniforms.depthEdge0.value = depthEdge0;
		this.convolutionMaterial.uniforms.depthEdge1.value = depthEdge1;
		this.convolutionMaterial.uniforms.depthScale.value = depthScale;
		this.convolutionMaterial.uniforms.depthBias.value = depthBias;
		this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;
		const vertices = new Float32Array([
			-1,
			-1,
			0,
			3,
			-1,
			0,
			-1,
			3,
			0
		]);
		const uvs = new Float32Array([
			0,
			0,
			2,
			0,
			0,
			2
		]);
		const geometry = new BufferGeometry();
		geometry.setAttribute("position", new BufferAttribute(vertices, 3));
		geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
		this.screen = new Mesh(geometry, this.convolutionMaterial);
		this.screen.frustumCulled = false;
		this.scene.add(this.screen);
	}
	render(renderer, inputBuffer, outputBuffer) {
		const scene = this.scene;
		const camera = this.camera;
		const renderTargetA = this.renderTargetA;
		const renderTargetB = this.renderTargetB;
		const material = this.convolutionMaterial;
		const uniforms = material.uniforms;
		uniforms.depthBuffer.value = inputBuffer.depthTexture;
		const kernel = material.kernel;
		let lastRT = inputBuffer;
		let destRT;
		let i, l;
		for (i = 0, l = kernel.length - 1; i < l; ++i) {
			destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;
			uniforms.kernel.value = kernel[i];
			uniforms.inputBuffer.value = lastRT.texture;
			renderer.setRenderTarget(destRT);
			renderer.render(scene, camera);
			lastRT = destRT;
		}
		uniforms.kernel.value = kernel[i];
		uniforms.inputBuffer.value = lastRT.texture;
		renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
		renderer.render(scene, camera);
	}
	dispose() {
		this.screen.material.dispose();
		this.screen.geometry.dispose();
		this.renderTargetA.dispose();
		this.renderTargetB.dispose();
		this.convolutionMaterial.dispose();
	}
};

//#endregion
//#region src/core/materials/meshReflectionMaterial/material.ts
var MeshReflectionMaterial = class extends MeshStandardMaterial {
	_tDepth = { value: null };
	_distortionMap = { value: null };
	_tSharp = { value: null };
	_tBlur = { value: null };
	_textureMatrix = { value: null };
	_mix = { value: .5 };
	_sharpMix = { value: 0 };
	_blurMixSmooth = { value: 0 };
	_blurMixRough = { value: 0 };
	_sharpDepthEdgeMin = { value: .9 };
	_sharpDepthEdgeMax = { value: 1 };
	_sharpDepthScale = { value: 0 };
	_sharpDepthBias = { value: 0 };
	_distortion = { value: 1 };
	constructor(parameters = {}) {
		super(parameters);
		this.setValues(parameters);
	}
	onBeforeCompile(shader) {
		if (!shader.defines?.USE_UV) shader.defines.USE_UV = "";
		for (const key of Object.keys(shader.defines)) shader.defines[key.toUpperCase()] = shader.defines[key];
		shader.uniforms.tSharp = this._tSharp;
		shader.uniforms.tDepth = this._tDepth;
		shader.uniforms.tBlur = this._tBlur;
		shader.uniforms.distortionMap = this._distortionMap;
		shader.uniforms.textureMatrix = this._textureMatrix;
		shader.uniforms.mixMain = this._mix;
		shader.uniforms.sharpMix = this._sharpMix;
		shader.uniforms.sharpDepthScale = this._sharpDepthScale;
		shader.uniforms.sharpDepthEdgeMin = this._sharpDepthEdgeMin;
		shader.uniforms.sharpDepthEdgeMax = this._sharpDepthEdgeMax;
		shader.uniforms.sharpDepthBias = this._sharpDepthBias;
		shader.uniforms.blurMixSmooth = this._blurMixSmooth;
		shader.uniforms.blurMixRough = this._blurMixRough;
		shader.uniforms.distortion = this._distortion;
		shader.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${shader.vertexShader}`;
		shader.vertexShader = shader.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`);
		shader.fragmentShader = `
        uniform sampler2D tSharp;
        uniform sampler2D tBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float mixMain;
        uniform float sharpMix;
        uniform float blurMixSmooth;
        uniform float blurMixRough;
        uniform float sharpDepthScale;
        uniform float sharpDepthBias;
        uniform float sharpDepthEdgeMin;
        uniform float sharpDepthEdgeMax;
        varying vec4 my_vUv;
        ${shader.fragmentShader}`;
		shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `#include <emissivemap_fragment>

      vec4 new_vUv = my_vUv;

      #ifdef USE_DISTORTION
        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;
        new_vUv.x += distortionFactor;
        new_vUv.y += distortionFactor;
      #endif

      #ifdef USE_NORMALMAP

        vec4 normalColor = texture(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;

        vec4 sharp = texture(tSharp, normal_uv);

        #ifdef USE_BLUR
          vec4 blur = texture(tBlur, normal_uv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = texture(tDepth, normal_uv);
        #endif

      #else

        vec4 sharp = textureProj(tSharp, new_vUv);

        #ifdef USE_BLUR
          vec4 blur = textureProj(tBlur, new_vUv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = textureProj(tDepth, new_vUv);
        #endif

      #endif

      #ifdef USE_DEPTH
        float depthFactor = smoothstep(
          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,
          1.0 - (depth.r * depth.a) + sharpDepthBias
        );
        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);

        sharp *= depthFactor;
      #endif

      sharp *= (1.0 - roughnessFactor);
      `);
		shader.fragmentShader = shader.fragmentShader.replace("#include <opaque_fragment>", `

      #ifdef USE_BLUR
        outgoingLight += mixMain * (
          vec3(sharp) * sharpMix
          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)
        );
      #else
        outgoingLight += mixMain * vec3(sharp) * sharpMix;
      #endif

      #include <opaque_fragment>
      `);
	}
	get tSharp() {
		return this._tSharp.value;
	}
	set tSharp(v) {
		this._tSharp.value = v;
	}
	get tDepth() {
		return this._tDepth.value;
	}
	set tDepth(v) {
		this._tDepth.value = v;
	}
	get distortionMap() {
		return this._distortionMap.value;
	}
	set distortionMap(v) {
		this._distortionMap.value = v;
	}
	get tBlur() {
		return this._tBlur.value;
	}
	set tBlur(v) {
		this._tBlur.value = v;
	}
	get textureMatrix() {
		return this._textureMatrix.value;
	}
	set textureMatrix(v) {
		this._textureMatrix.value = v;
	}
	get sharpMix() {
		return this._sharpMix.value;
	}
	set sharpMix(v) {
		this._sharpMix.value = v;
	}
	get blurMixSmooth() {
		return this._blurMixSmooth.value;
	}
	set blurMixSmooth(v) {
		this._blurMixSmooth.value = v;
	}
	get blurMixRough() {
		return this._blurMixRough.value;
	}
	set blurMixRough(v) {
		this._blurMixRough.value = v;
	}
	get mix() {
		return this._mix.value;
	}
	set mix(v) {
		this._mix.value = v;
	}
	get sharpDepthScale() {
		return this._sharpDepthScale.value;
	}
	set sharpDepthScale(v) {
		this._sharpDepthScale.value = v;
	}
	get sharpDepthBias() {
		return this._sharpDepthBias.value;
	}
	set sharpDepthBias(v) {
		this._sharpDepthBias.value = v;
	}
	get sharpDepthEdgeMin() {
		return this._sharpDepthEdgeMin.value;
	}
	set sharpDepthEdgeMin(v) {
		this._sharpDepthEdgeMin.value = v;
	}
	get sharpDepthEdgeMax() {
		return this._sharpDepthEdgeMax.value;
	}
	set sharpDepthEdgeMax(v) {
		this._sharpDepthEdgeMax.value = v;
	}
	get distortion() {
		return this._distortion.value;
	}
	set distortion(v) {
		this._distortion.value = v;
	}
};

//#endregion
//#region src/core/materials/meshReflectionMaterial/index.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$36 = [
	"texture-matrix",
	"t-sharp",
	"t-depth",
	"t-blur",
	"defines-USE_BLUR",
	"defines-USE_DEPTH",
	"defines-USE_DISTORTION"
];
var index_vue_vue_type_script_setup_true_lang_default$2 = /* @__PURE__ */ defineComponent({
	__name: "index",
	props: {
		resolution: {
			type: Number,
			required: false,
			default: 256
		},
		mix: {
			type: Number,
			required: false,
			default: 1
		},
		sharpMix: {
			type: Number,
			required: false,
			default: 1
		},
		sharpDepthScale: {
			type: Number,
			required: false,
			default: 1
		},
		sharpDepthBias: {
			type: Number,
			required: false,
			default: 0
		},
		sharpDepthEdgeMin: {
			type: Number,
			required: false,
			default: 0
		},
		sharpDepthEdgeMax: {
			type: Number,
			required: false,
			default: .2
		},
		blurMixSmooth: {
			type: Number,
			required: false,
			default: 1
		},
		blurMixRough: {
			type: Number,
			required: false,
			default: 1
		},
		blurDepthScale: {
			type: Number,
			required: false,
			default: 1
		},
		blurDepthBias: {
			type: Number,
			required: false,
			default: 0
		},
		blurDepthEdgeMin: {
			type: Number,
			required: false,
			default: 0
		},
		blurDepthEdgeMax: {
			type: Number,
			required: false,
			default: .2
		},
		blurSize: {
			type: [Array, Number],
			required: false,
			default: () => [0, 0]
		},
		distortionMap: {
			type: Object,
			required: false
		},
		distortion: {
			type: Number,
			required: false,
			default: 0
		},
		reflectorOffset: {
			type: Number,
			required: false,
			default: 0
		},
		color: {
			type: null,
			required: false,
			default: () => new Color(3355443)
		},
		roughness: {
			type: Number,
			required: false,
			default: 1
		},
		metalness: {
			type: Number,
			required: false,
			default: 0
		},
		map: {
			type: Object,
			required: false
		},
		lightMap: {
			type: Object,
			required: false
		},
		lightMapIntensity: {
			type: Number,
			required: false,
			default: 1
		},
		aoMap: {
			type: [Object, null],
			required: false
		},
		aoMapIntensity: {
			type: Number,
			required: false,
			default: 1
		},
		emissive: {
			type: null,
			required: false,
			default: () => new Color(0)
		},
		emissiveIntensity: {
			type: Number,
			required: false,
			default: 1
		},
		emissiveMap: {
			type: Object,
			required: false
		},
		bumpMap: {
			type: Object,
			required: false
		},
		bumpScale: {
			type: Number,
			required: false,
			default: 1
		},
		normalMap: {
			type: Object,
			required: false
		},
		normalMapType: {
			type: Number,
			required: false,
			default: TangentSpaceNormalMap
		},
		normalScale: {
			type: Object,
			required: false,
			default: () => new Vector2(1, 1)
		},
		displacementMap: {
			type: Object,
			required: false
		},
		displacementScale: {
			type: Number,
			required: false,
			default: 1
		},
		displacementBias: {
			type: Number,
			required: false,
			default: 0
		},
		roughnessMap: {
			type: [Object, null],
			required: false,
			default: null
		},
		metalnessMap: {
			type: [Object, null],
			required: false
		},
		alphaMap: {
			type: [Object, null],
			required: false
		},
		envMap: {
			type: [Object, null],
			required: false
		},
		envMapRotation: {
			type: Object,
			required: false,
			default: () => new Euler()
		},
		envMapIntensity: {
			type: Number,
			required: false,
			default: 1
		},
		wireframe: {
			type: Boolean,
			required: false,
			default: false
		},
		wireframeLinewidth: {
			type: Number,
			required: false,
			default: 1
		},
		wireframeLinecap: {
			type: String,
			required: false,
			default: "round"
		},
		wireframeLinejoin: {
			type: String,
			required: false,
			default: "round"
		},
		flatShading: {
			type: Boolean,
			required: false,
			default: false
		},
		fog: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { extend: extend$1, invalidate } = useTres();
		extend$1({ MeshReflectionMaterial });
		const blurWidth = computed(() => 500 - (Array.isArray(props.blurSize) ? props.blurSize[0] : props.blurSize));
		const blurHeight = computed(() => 500 - (Array.isArray(props.blurSize) ? props.blurSize[1] : props.blurSize));
		const hasBlur = computed(() => blurWidth.value > 0 || blurHeight.value > 0);
		const hasDepth = computed(() => props.sharpDepthScale > 0 || props.blurDepthScale > 0);
		const hasDistortion = computed(() => !!props.distortionMap);
		const hasRoughness = computed(() => !!props.roughnessMap);
		const materialRef = shallowRef();
		let blurpass;
		const state = {
			reflectorPlane: new Plane(),
			normal: new Vector3(),
			reflectorWorldPosition: new Vector3(),
			cameraWorldPosition: new Vector3(),
			rotationMatrix: new Matrix4(),
			lookAtPosition: new Vector3(0, 0, -1),
			clipPlane: new Vector4(),
			view: new Vector3(),
			target: new Vector3(),
			q: new Vector4(),
			virtualCamera: new PerspectiveCamera(),
			textureMatrix: new Matrix4()
		};
		const fboSharp = new WebGLRenderTarget(props.resolution, props.resolution, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			type: HalfFloatType,
			depthBuffer: true,
			depthTexture: new DepthTexture(props.resolution, props.resolution)
		});
		const fboBlur = new WebGLRenderTarget(props.resolution, props.resolution, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			type: HalfFloatType
		});
		watch(() => [props.resolution], () => {
			fboSharp.setSize(props.resolution, props.resolution);
			fboBlur.setSize(props.resolution, props.resolution);
		});
		watch(() => [
			props.resolution,
			blurWidth.value,
			blurHeight.value,
			props.blurDepthEdgeMin,
			props.blurDepthEdgeMax,
			props.blurDepthScale,
			props.blurDepthBias
		], () => {
			blurpass?.dispose();
			blurpass = new BlurPass({
				resolution: props.resolution,
				width: blurWidth.value,
				height: blurHeight.value,
				depthEdge0: props.blurDepthEdgeMin,
				depthEdge1: props.blurDepthEdgeMax,
				depthScale: props.blurDepthScale,
				depthBias: props.blurDepthBias
			});
		}, { immediate: true });
		watch(() => [hasBlur.value], () => {
			logWarning("MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.");
		});
		watch(hasDepth, () => {
			logWarning("MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.");
		});
		watch(hasDistortion, () => {
			logWarning("MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.");
		});
		watch(hasRoughness, () => {
			logWarning("MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.");
		});
		watch(() => [props.normalMap], () => {
			logWarning("MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.");
		});
		onBeforeUnmount(() => {
			fboSharp.dispose();
			fboBlur.dispose();
			blurpass.dispose();
		});
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ renderer, scene, camera }) => {
			const parent = materialRef.value?.__tres?.parent;
			if (!parent) return;
			if ("isWebGPURenderer" in renderer && renderer.isWebGPURenderer === true) {
				console.warn("MeshReflectionMaterial: WebGPURenderer is not supported yet");
				return;
			}
			if (renderer instanceof WebGLRenderer) {
				invalidate();
				const currentXrEnabled = renderer.xr.enabled;
				const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
				state.reflectorWorldPosition.setFromMatrixPosition(parent.matrixWorld);
				state.cameraWorldPosition.setFromMatrixPosition(camera.value?.matrixWorld);
				state.rotationMatrix.extractRotation(parent.matrixWorld);
				state.normal.set(0, 0, 1);
				state.normal.applyMatrix4(state.rotationMatrix);
				state.reflectorWorldPosition.addScaledVector(state.normal, props.reflectorOffset);
				state.view.subVectors(state.reflectorWorldPosition, state.cameraWorldPosition);
				if (state.view.dot(state.normal) > 0) return;
				parent.visible = false;
				state.view.reflect(state.normal).negate();
				state.view.add(state.reflectorWorldPosition);
				state.rotationMatrix.extractRotation(camera.value?.matrixWorld);
				state.lookAtPosition.set(0, 0, -1);
				state.lookAtPosition.applyMatrix4(state.rotationMatrix);
				state.lookAtPosition.add(state.cameraWorldPosition);
				state.target.subVectors(state.reflectorWorldPosition, state.lookAtPosition);
				state.target.reflect(state.normal).negate();
				state.target.add(state.reflectorWorldPosition);
				state.virtualCamera.position.copy(state.view);
				state.virtualCamera.up.set(0, 1, 0);
				state.virtualCamera.up.applyMatrix4(state.rotationMatrix);
				state.virtualCamera.up.reflect(state.normal);
				state.virtualCamera.lookAt(state.target);
				state.virtualCamera.far = camera.value.far;
				state.virtualCamera.updateMatrixWorld();
				state.virtualCamera.far = camera.value.far;
				state.virtualCamera.projectionMatrix.copy(camera.value.projectionMatrix);
				state.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
				state.textureMatrix.multiply(state.virtualCamera.projectionMatrix);
				state.textureMatrix.multiply(state.virtualCamera.matrixWorldInverse);
				state.textureMatrix.multiply(parent.matrixWorld);
				state.reflectorPlane.setFromNormalAndCoplanarPoint(state.normal, state.reflectorWorldPosition);
				state.reflectorPlane.applyMatrix4(state.virtualCamera.matrixWorldInverse);
				state.clipPlane.set(state.reflectorPlane.normal.x, state.reflectorPlane.normal.y, state.reflectorPlane.normal.z, state.reflectorPlane.constant);
				const projectionMatrix = state.virtualCamera.projectionMatrix;
				state.q.x = (Math.sign(state.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
				state.q.y = (Math.sign(state.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
				state.q.z = -1;
				state.q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
				state.clipPlane.multiplyScalar(2 / state.clipPlane.dot(state.q));
				projectionMatrix.elements[2] = state.clipPlane.x;
				projectionMatrix.elements[6] = state.clipPlane.y;
				projectionMatrix.elements[10] = state.clipPlane.z + 1;
				projectionMatrix.elements[14] = state.clipPlane.w;
				renderer.shadowMap.autoUpdate = false;
				renderer.setRenderTarget(fboSharp);
				if (!renderer.autoClear) renderer.clear();
				renderer.render(toValue(scene), state.virtualCamera);
				if (renderer instanceof WebGLRenderer) blurpass.render(renderer, fboSharp, fboBlur);
				renderer.xr.enabled = currentXrEnabled;
				renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
				parent.visible = true;
				renderer.setRenderTarget(null);
				invalidate();
			}
		});
		__expose({ instance: materialRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMeshReflectionMaterial", mergeProps({
				key: `key${hasBlur.value ? "0" : "1"}${hasDepth.value ? "0" : "1"}${hasDistortion.value ? "0" : "1"}${hasRoughness.value ? "0" : "1"}`,
				ref_key: "materialRef",
				ref: materialRef
			}, props, {
				"texture-matrix": state.textureMatrix,
				"t-sharp": unref(fboSharp)?.texture,
				"t-depth": unref(fboSharp)?.depthTexture,
				"t-blur": unref(fboBlur)?.texture,
				"defines-USE_BLUR": hasBlur.value ? "" : void 0,
				"defines-USE_DEPTH": hasDepth.value ? "" : void 0,
				"defines-USE_DISTORTION": hasDistortion.value ? "" : void 0
			}), null, 16, _hoisted_1$36);
		};
	}
});

//#endregion
//#region src/core/materials/meshReflectionMaterial/index.vue
var meshReflectionMaterial_default = index_vue_vue_type_script_setup_true_lang_default$2;

//#endregion
//#region src/core/materials/meshWobbleMaterial/material.ts
var WobbleMaterialImpl = class extends MeshStandardMaterial {
	_time;
	_factor;
	constructor(parameters = {}) {
		super(parameters);
		this.setValues(parameters);
		this._time = { value: 0 };
		this._factor = { value: 1 };
	}
	onBeforeCompile(shader) {
		if (!shader.uniforms) shader.uniforms = {};
		shader.uniforms.time = this._time;
		shader.uniforms.factor = this._factor;
		shader.vertexShader = `
        uniform float time;
        uniform float factor;
        ${shader.vertexShader}
      `;
		shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`);
	}
	get time() {
		return this._time.value;
	}
	set time(v) {
		this._time.value = v;
	}
	get factor() {
		return this._factor.value;
	}
	set factor(v) {
		this._factor.value = v;
	}
};

//#endregion
//#region src/core/materials/meshWobbleMaterial/index.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$35 = ["factor"];
var index_vue_vue_type_script_setup_true_lang_default$1 = /* @__PURE__ */ defineComponent({
	__name: "index",
	props: {
		speed: {
			type: Number,
			required: false,
			default: 1
		},
		factor: {
			type: Number,
			required: false,
			default: 1
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const materialRef = shallowRef();
		const { extend: extend$1, invalidate } = useTres();
		extend$1({ MeshWobbleMaterial: WobbleMaterialImpl });
		watch(props, () => {
			invalidate();
		});
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ elapsed }) => {
			if (materialRef.value) {
				materialRef.value.time = elapsed * props?.speed;
				invalidate();
			}
		});
		__expose({ instance: materialRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMeshWobbleMaterial", {
				ref_key: "materialRef",
				ref: materialRef,
				factor: __props.factor
			}, null, 8, _hoisted_1$35);
		};
	}
});

//#endregion
//#region src/core/materials/meshWobbleMaterial/index.vue
var meshWobbleMaterial_default = index_vue_vue_type_script_setup_true_lang_default$1;

//#endregion
//#region src/core/materials/pointMaterial/material.ts
const opaque_fragment = "opaque_fragment";
var PointMaterial = class extends PointsMaterial {
	constructor(props) {
		super(props);
		this.onBeforeCompile = (shader, renderer) => {
			const { isWebGL2 } = renderer.capabilities;
			shader.fragmentShader = shader.fragmentShader.replace(`#include <${opaque_fragment}>`, `
        ${!isWebGL2 ? `#extension GL_OES_standard_derivatives : enable\n#include <${opaque_fragment}>` : `#include <${opaque_fragment}>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <colorspace_fragment>
      `);
		};
	}
};

//#endregion
//#region src/core/materials/pointMaterial/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$34 = ["object"];
var component_vue_vue_type_script_setup_true_lang_default$5 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: { sizeAttenuation: {
		type: Boolean,
		required: false
	} },
	setup(__props, { expose: __expose }) {
		const props = __props;
		extend({ PointMaterial });
		const materialRef = shallowRef(new PointMaterial({ sizeAttenuation: props.sizeAttenuation }));
		watch(() => props.sizeAttenuation, () => {
			if (materialRef.value) materialRef.value.dispose();
			materialRef.value = new PointMaterial({ sizeAttenuation: props.sizeAttenuation });
		});
		onUnmounted(() => {
			if (materialRef.value && materialRef.value.dispose) materialRef.value.dispose();
		});
		__expose({ instance: materialRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", { object: materialRef.value }, null, 8, _hoisted_1$34);
		};
	}
});

//#endregion
//#region src/core/materials/pointMaterial/component.vue
var component_default$13 = component_vue_vue_type_script_setup_true_lang_default$5;

//#endregion
//#region src/core/misc/BakeShadows.ts
const BakeShadows = defineComponent({
	name: "BakeShadows",
	setup() {
		const { renderer } = useTres();
		watchEffect(() => {
			if (renderer instanceof WebGLRenderer) {
				renderer.shadowMap.autoUpdate = false;
				renderer.shadowMap.needsUpdate = true;
			}
		});
	}
});

//#endregion
//#region src/core/misc/LOD.vue?vue&type=script&setup=true&lang.ts
var LOD_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "LOD",
	props: {
		levels: {
			type: Array,
			required: true
		},
		hysteresis: {
			type: Number,
			required: false,
			default: 0
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const lodRef = shallowRef(new LOD());
		function onChange() {
			const distances = props.levels && props.levels.length && props.levels.every((n) => typeof n === "number") ? [...props.levels] : [1e3];
			while (distances.length < lodRef.value.children.length) distances.push(Math.abs(distances[distances.length - 1]) * 2);
			const levels = [];
			for (let i = 0; i < lodRef.value.children.length; i++) {
				const hysteresis = props.hysteresis;
				const distance = distances[i];
				const object = lodRef.value.children[i];
				levels.push({
					hysteresis,
					distance,
					object
				});
			}
			levels.sort((a, b) => a.distance - b.distance);
			lodRef.value.levels.length = 0;
			levels.forEach((level) => lodRef.value.levels.push(level));
		}
		if (isReactive(props.levels)) watch(() => props.levels, onChange);
		if (isReactive(props.hysteresis)) watch(() => props.hysteresis, onChange);
		onMounted(onChange);
		__expose({ instance: lodRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresLOD", {
				ref_key: "lodRef",
				ref: lodRef
			}, [renderSlot(_ctx.$slots, "default")], 512);
		};
	}
});

//#endregion
//#region src/core/misc/LOD.vue
var LOD_default = LOD_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/misc/html/shaders/fragment.glsl
var fragment_default = "void main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}";

//#endregion
//#region src/core/misc/html/shaders/vertex.glsl
var vertex_default = "#include <common>\n\nuniform float uWidth;\nuniform float uHeight;\n\nvoid main() {\n\n  vec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n  vec2 quad = position.xy;\n\n  vec2 alignedPosition = quad * vec2(uWidth, uHeight);\n\n  mvPosition.xy += alignedPosition;\n\n  gl_Position = projectionMatrix * mvPosition;\n}";

//#endregion
//#region src/core/misc/html/shaders/passthrough-vertex.glsl
var passthrough_vertex_default = "#include <common>\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";

//#endregion
//#region src/core/misc/html/utils.ts
const v1 = new Vector3(0, 0, 0);
const v2 = new Vector3(0, 0, 0);
const v3 = new Vector3(0, 0, 0);
function calculatePosition(instance, camera, size) {
	const objectPos = v1.setFromMatrixPosition(instance.matrixWorld);
	objectPos.project(camera);
	const widthHalf = size.width / 2;
	const heightHalf = size.height / 2;
	return [
		(Number.isNaN(objectPos.x) ? 0 : objectPos.x) * widthHalf + widthHalf,
		-(objectPos.y * heightHalf) + heightHalf,
		objectPos.z
	];
}
function isObjectBehindCamera(el, camera) {
	const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
	const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
	const deltaCamObj = objectPos.sub(cameraPos);
	const camDir = camera.getWorldDirection(v3);
	return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}
function isObjectVisible(el, camera, raycaster, occlude) {
	const elPos = v1.setFromMatrixPosition(el.matrixWorld);
	const screenPos = elPos.clone();
	screenPos.project(camera);
	raycaster.setFromCamera(new Vector2(screenPos.x, screenPos.y), camera);
	const intersects = raycaster.intersectObjects(occlude, true);
	if (intersects.length > 0) {
		const intersectionDistance = intersects[0].distance;
		return elPos.distanceTo(raycaster.ray.origin) < intersectionDistance;
	}
	return true;
}
function getViewportFactor(camera, target = new Vector3(0, 0, 0), size) {
	const { width, height } = size;
	const aspect = width / height;
	const position = v1;
	const tempTarget = v2;
	tempTarget.copy(target);
	const distance = camera.getWorldPosition(position).distanceTo(tempTarget);
	if (camera instanceof OrthographicCamera) return 1;
	const fov = camera.fov * Math.PI / 180;
	return width / (2 * Math.tan(fov / 2) * distance * aspect);
}
function objectScale(el, camera) {
	if (camera instanceof OrthographicCamera) return camera.zoom;
	else if (camera instanceof PerspectiveCamera) {
		const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
		const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
		const vFOV = camera.fov * Math.PI / 180;
		const dist = objectPos.distanceTo(cameraPos);
		return 1 / (2 * Math.tan(vFOV / 2) * dist);
	} else return 1;
}
function objectZIndex(el, camera, zIndexRange) {
	if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
		const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
		const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
		const dist = objectPos.distanceTo(cameraPos);
		const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
		const B = zIndexRange[1] - A * camera.far;
		return Math.round(A * dist + B);
	}
}
const epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
function getCSSMatrix(matrix, multipliers, prepend = "") {
	let matrix3d = "matrix3d(";
	for (let i = 0; i !== 16; i++) matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? "," : ")");
	return prepend + matrix3d;
}
const getCameraCSSMatrix = ((multipliers) => (matrix) => getCSSMatrix(matrix, multipliers))([
	1,
	-1,
	1,
	1,
	1,
	-1,
	1,
	1,
	1,
	-1,
	1,
	1,
	1,
	-1,
	1,
	1
]);
const getObjectCSSMatrix = (matrix, factor) => {
	return getCSSMatrix(matrix, [
		1 / factor,
		1 / factor,
		1 / factor,
		1,
		-1 / factor,
		-1 / factor,
		-1 / factor,
		-1,
		1 / factor,
		1 / factor,
		1 / factor,
		1,
		1,
		1,
		1,
		1
	], "translate(-50%,-50%)");
};

//#endregion
//#region src/core/misc/html/HTML.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$33 = [
	"material",
	"cast-shadow",
	"receive-shadow",
	"geometry"
];
var HTML_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "HTML",
	props: {
		geometry: {
			type: null,
			required: false
		},
		material: {
			type: null,
			required: false
		},
		as: {
			type: String,
			required: false,
			default: "div"
		},
		transform: {
			type: Boolean,
			required: false,
			default: false
		},
		prepend: {
			type: Boolean,
			required: false,
			default: false
		},
		portal: {
			type: null,
			required: false
		},
		wrapperClass: {
			type: String,
			required: false
		},
		eps: {
			type: Number,
			required: false,
			default: 1e-4
		},
		distanceFactor: {
			type: Number,
			required: false
		},
		fullscreen: {
			type: Boolean,
			required: false
		},
		center: {
			type: Boolean,
			required: false
		},
		pointerEvents: {
			type: String,
			required: false,
			default: "auto"
		},
		sprite: {
			type: Boolean,
			required: false,
			default: false
		},
		transparentMaterial: {
			type: Boolean,
			required: false,
			default: false
		},
		zIndexRange: {
			type: Array,
			required: false,
			default: () => [16777271, 0]
		},
		calculatePosition: {
			type: null,
			required: false,
			default: () => calculatePosition
		},
		occlude: {
			type: [
				Object,
				null,
				Array,
				Boolean,
				String
			],
			required: false
		},
		castShadow: {
			type: Boolean,
			required: false,
			default: false
		},
		receiveShadow: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	emits: ["onOcclude"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emits = __emit;
		const slots = useSlots();
		const { geometry, material, as, transform, portal, wrapperClass, eps, distanceFactor, fullscreen, center, pointerEvents, sprite, prepend, occlude, zIndexRange, castShadow, receiveShadow, transparentMaterial, calculatePosition: calculatePosition$1 } = toRefs(props);
		const attrs = useAttrs();
		const groupRef = shallowRef(null);
		const occlusionMeshRef = shallowRef(null);
		const defaultPlaneGeometry = new PlaneGeometry();
		const { renderer, scene, camera, sizes } = useTresContext();
		const el = computed(() => document.createElement(as.value));
		const raycaster = new Raycaster();
		const tmpVec = new Vector3();
		const tmpMatrix = new Matrix4();
		const tmpQuat = new Quaternion();
		const previousPosition = ref([
			0,
			0,
			0
		]);
		const previousZoom = ref(0);
		const vnode = ref(null);
		const isVisible = ref(true);
		const isMeshSizeSet = ref(false);
		const baseStyle = computed(() => ({
			position: "absolute",
			top: "0",
			left: "0",
			willChange: "transform",
			pointerEvents: pointerEvents.value,
			...typeof attrs.style === "object" ? attrs.style : {}
		}));
		const styles = computed(() => {
			const w = sizes.width.value;
			const h = sizes.height.value;
			if (transform.value) return {
				...baseStyle.value,
				transformStyle: "preserve-3d",
				pointerEvents: "none",
				width: `${w}px`,
				height: `${h}px`
			};
			return {
				...baseStyle.value,
				transform: center.value ? "translate3d(-50%,-50%,0)" : "none",
				...fullscreen.value && {
					top: `-${h / 2}px`,
					left: `-${w / 2}px`,
					width: `${w}px`,
					height: `${h}px`
				},
				pointerEvents: fullscreen.value ? "none" : pointerEvents.value
			};
		});
		const transformInnerStyles = computed(() => ({
			position: "absolute",
			pointerEvents: pointerEvents.value
		}));
		const isRayCastOcclusion = computed(() => {
			const o = occlude.value;
			return o && o !== "blending" && (Array.isArray(o) ? o.length && typeof o[0] !== "boolean" : true);
		});
		const effectiveMaterial = computed(() => {
			if (material.value) return material.value;
			return new ShaderMaterial({
				vertexShader: sprite.value ? vertex_default : transform.value ? passthrough_vertex_default : vertex_default,
				fragmentShader: fragment_default,
				side: DoubleSide,
				transparent: transparentMaterial.value,
				uniforms: {
					uWidth: { value: 1 },
					uHeight: { value: 1 }
				}
			});
		});
		watchEffect(() => {
			effectiveMaterial.value.transparent = transparentMaterial.value;
		});
		watch([occlude, () => renderer.instance], ([occludeVal, r]) => {
			if (!r || occludeVal !== "blending") return;
			const target = r.domElement;
			target.style.zIndex = `${Math.floor(zIndexRange.value[0] / 2)}`;
			target.style.position = "absolute";
		}, { immediate: true });
		watch(() => [
			groupRef.value,
			renderer.instance,
			sizes.width.value,
			sizes.height.value,
			slots.default?.(),
			camera.activeCamera.value
		], ([group, r]) => {
			if (!group || !r || !camera.activeCamera.value) return;
			isMeshSizeSet.value = false;
			scene.value?.updateMatrixWorld();
			const elStyle = el.value.style;
			elStyle.position = "absolute";
			elStyle.top = "0";
			elStyle.left = "0";
			if (transform.value) {
				elStyle.pointerEvents = "none";
				elStyle.overflow = "hidden";
				elStyle.transformStyle = "preserve-3d";
			} else {
				elStyle.transformOrigin = "0 0";
				elStyle.willChange = "transform";
				if (!occlude.value) elStyle.zIndex = `${zIndexRange.value[0]}`;
			}
			const parent = portal.value || r.domElement?.parentNode;
			if (parent && !el.value.parentNode) prepend.value ? parent.prepend(el.value) : parent.appendChild(el.value);
			vnode.value = transform.value ? createVNode("div", { style: styles.value }, [createVNode("div", { style: transformInnerStyles.value }, [createVNode("div", {
				key: groupRef.value?.uuid,
				class: attrs.class,
				style: attrs.style
			}, slots.default?.())])]) : createVNode("div", {
				key: groupRef.value?.uuid,
				style: styles.value,
				class: attrs.class
			}, slots.default?.());
			render(vnode.value, el.value);
		});
		watchEffect(() => {
			if (wrapperClass.value) el.value.className = wrapperClass.value;
		});
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ invalidate }) => {
			const group = groupRef.value;
			const cam = camera.activeCamera.value;
			const rend = renderer.instance;
			if (!group || !cam || !rend) return;
			cam.updateMatrixWorld();
			group.updateWorldMatrix(true, false);
			const width = sizes.width.value;
			const height = sizes.height.value;
			const widthHalf = width * .5;
			const heightHalf = height * .5;
			const newPos = transform.value ? previousPosition.value : calculatePosition$1.value(group, cam, {
				width,
				height
			});
			const posChanged = Math.abs(previousZoom.value - cam.zoom) > eps.value || Math.abs(previousPosition.value[0] - newPos[0]) > eps.value || Math.abs(previousPosition.value[1] - newPos[1]) > eps.value || Math.abs(previousPosition.value[2] - newPos[2]) > eps.value;
			let changed = transform.value || posChanged;
			let visible = true;
			const behind = isObjectBehindCamera(group, cam);
			if (isRayCastOcclusion.value) {
				let targets = false;
				if (Array.isArray(occlude.value)) targets = occlude.value;
				else if (occlude.value !== "blending") targets = [scene.value];
				if (targets) visible = isObjectVisible(group, cam, raycaster, targets) && !behind;
			} else visible = !behind;
			if (visible !== isVisible.value) {
				isVisible.value = visible;
				el.value.style.display = visible ? "block" : "none";
				emits("onOcclude", !visible);
				changed = true;
			}
			const halfRange = Math.floor(zIndexRange.value[0] / 2);
			const zRange = occlude.value ? isRayCastOcclusion.value ? [zIndexRange.value[0], halfRange] : [halfRange - 1, 0] : zIndexRange.value;
			el.value.style.zIndex = `${objectZIndex(group, cam, zRange)}`;
			if (transform.value) {
				const persp = cam.projectionMatrix.elements[5] * heightHalf;
				const camMatrix = getCameraCSSMatrix(cam.matrixWorldInverse);
				const isOrtho = cam instanceof OrthographicCamera;
				const cameraTransform = isOrtho ? `scale(${persp})translate(${epsilon(-(cam.right + cam.left) / 2)}px,${epsilon((cam.top + cam.bottom) / 2)}px)` : `translateZ(${persp}px)`;
				let finalMatrix = group.matrixWorld;
				if (sprite.value) {
					tmpMatrix.copy(group.matrixWorld);
					const invCamMat = cam.matrixWorldInverse.clone().transpose();
					tmpQuat.setFromRotationMatrix(invCamMat);
					tmpMatrix.makeRotationFromQuaternion(tmpQuat);
					group.getWorldPosition(tmpVec);
					tmpMatrix.setPosition(tmpVec);
					tmpMatrix.scale(group.scale);
					tmpMatrix.elements[3] = tmpMatrix.elements[7] = tmpMatrix.elements[11] = 0;
					tmpMatrix.elements[15] = 1;
					finalMatrix = tmpMatrix;
				}
				const style = el.value.style;
				style.width = `${width}px`;
				style.height = `${height}px`;
				style.perspective = isOrtho ? "" : `${persp}px`;
				if (vnode.value?.el) {
					vnode.value.el.style.transform = `${cameraTransform}${camMatrix}translate(${widthHalf}px,${heightHalf}px)`;
					let inner;
					if (Array.isArray(vnode.value.children)) inner = vnode.value.children[0];
					if (inner?.el) inner.el.style.transform = getObjectCSSMatrix(finalMatrix, 1 / ((distanceFactor.value || 10) / 400));
				}
			} else {
				const scale = distanceFactor.value === void 0 ? 1 : objectScale(group, cam) * distanceFactor.value;
				el.value.style.transform = `translate3d(${newPos[0]}px,${newPos[1]}px,0) scale(${scale})`;
			}
			previousPosition.value = [
				newPos[0],
				newPos[1],
				newPos[2]
			];
			previousZoom.value = cam.zoom;
			if (!isRayCastOcclusion.value && occlusionMeshRef.value && !isMeshSizeSet.value) {
				const mesh = occlusionMeshRef.value;
				if (transform.value) {
					const children = vnode.value?.children;
					if (Array.isArray(children)) {
						const element = children[0]?.el;
						if (element) {
							const isOrtho = cam instanceof OrthographicCamera;
							if (isOrtho && geometry.value && attrs.scale) if (!Array.isArray(attrs.scale)) mesh.scale.setScalar(1 / attrs.scale);
							else if (attrs.scale instanceof Vector3) mesh.scale.copy(attrs.scale);
							else mesh.scale.set(1 / attrs.scale[0], 1 / attrs.scale[1], 1 / attrs.scale[2]);
							else if (!isOrtho && !geometry.value) {
								const ratio = (distanceFactor.value || 10) / 400;
								if (sprite.value) {
									effectiveMaterial.value.uniforms.uWidth.value = element.clientWidth * ratio;
									effectiveMaterial.value.uniforms.uHeight.value = element.clientHeight * ratio;
									mesh.lookAt(cam.position);
									mesh.scale.set(1, 1, 1);
								} else {
									const w = element.clientWidth * ratio;
									const h = element.clientHeight * ratio;
									mesh.scale.set(w, h, 1);
								}
							}
							isMeshSizeSet.value = true;
						}
					}
				} else {
					const element = el.value.children[0];
					if (element?.clientWidth && element?.clientHeight) {
						group.getWorldPosition(tmpVec);
						const ratio = 1 / getViewportFactor(cam, tmpVec, {
							width,
							height
						});
						effectiveMaterial.value.uniforms.uWidth.value = element.clientWidth * ratio;
						effectiveMaterial.value.uniforms.uHeight.value = element.clientHeight * ratio;
						mesh.scale.set(1, 1, 1);
						mesh.lookAt(cam.position);
						isMeshSizeSet.value = true;
					}
				}
			}
			if (changed) invalidate();
		});
		onUnmounted(() => {
			defaultPlaneGeometry?.dispose();
			effectiveMaterial.value?.dispose();
			if (el.value?.parentNode) el.value.parentNode.removeChild(el.value);
		});
		__expose({
			instance: groupRef,
			isVisible,
			occlusionMesh: occlusionMeshRef
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "groupRef",
				ref: groupRef
			}, [unref(occlude) && !isRayCastOcclusion.value ? (openBlock(), createElementBlock("TresMesh", {
				key: 0,
				ref_key: "occlusionMeshRef",
				ref: occlusionMeshRef,
				material: effectiveMaterial.value,
				"cast-shadow": unref(castShadow),
				"receive-shadow": unref(receiveShadow),
				geometry: unref(geometry) || unref(defaultPlaneGeometry)
			}, null, 8, _hoisted_1$33)) : createCommentVNode("v-if", true)], 512);
		};
	}
});

//#endregion
//#region src/core/misc/html/HTML.vue
var HTML_default = HTML_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/misc/Stats.ts
const Stats = defineComponent({
	name: "Stats",
	props: { showPanel: {
		type: Number,
		default: 0
	} },
	setup(props, { expose }) {
		const stats = new StatsImpl();
		expose({ instance: stats });
		const node = document.body;
		stats.showPanel(props.showPanel || 0);
		node?.appendChild(stats.dom);
		const { onBeforeRender, onRender } = useLoop();
		onBeforeRender(() => stats.begin(), Number.NEGATIVE_INFINITY);
		onRender(() => stats.end(), Number.POSITIVE_INFINITY);
		onUnmounted(() => {
			node?.removeChild(stats.dom);
		});
	}
});

//#endregion
//#region src/core/misc/StatsGl.ts
const StatsGl = defineComponent({
	name: "StatsGl",
	props: [
		"logsPerSecond",
		"samplesLog",
		"samplesGraph",
		"precision",
		"horizontal",
		"minimal",
		"mode"
	],
	setup(props, { expose }) {
		const statsGl = new StatsGlImpl({
			logsPerSecond: props.logsPerSecond,
			samplesLog: props.samplesLog,
			samplesGraph: props.samplesGraph,
			precision: props.precision,
			horizontal: props.horizontal,
			minimal: props.minimal,
			mode: props.mode
		});
		expose({ instance: statsGl });
		const node = document.body;
		const statContainer = statsGl.container;
		node?.appendChild(statContainer);
		const { renderer } = useTresContext();
		const { onRender } = useLoop();
		statsGl.init(renderer.instance);
		onRender(() => statsGl.update(), Number.POSITIVE_INFINITY);
		onUnmounted(() => {
			node?.removeChild(statContainer);
		});
	}
});

//#endregion
//#region src/core/misc/useGLTFExporter.ts
async function useGLTFExporter(object3D, options) {
	const exporter = new GLTFExporter();
	const name = options?.fileName || "scene";
	exporter.parse(object3D, (gltf) => {
		if (gltf instanceof ArrayBuffer) saveArrayBuffer(gltf, `${name}.glb`);
		else saveString(JSON.stringify(gltf, null, 2), `${name}.gltf`);
	}, (error) => {
		logError("An error happened while exporting the GLTF", error);
	}, options);
}
function saveString(text, filename) {
	save(new Blob([text], { type: "text/plain" }), filename);
}
function saveArrayBuffer(buffer, filename) {
	save(new Blob([buffer], { type: "application/octet-stream" }), filename);
}
function save(blob, filename) {
	const link = document.createElement("a");
	link.style.display = "none";
	document.body.appendChild(link);
	link.href = URL.createObjectURL(blob);
	link.download = filename;
	link.click();
	link.remove();
}

//#endregion
//#region src/core/misc/useIntersect.ts
function normalizeCientosInstance(obj) {
	if ("onBeforeRender" in obj && "onAfterRender" in obj) return obj;
	return obj.instance;
}
function useIntersect(onChange = () => {}) {
	const ref$1 = shallowRef();
	const intersect = shallowRef(false);
	let _isIntersected = false;
	let _oldIsIntersected = false;
	const loop = useLoop();
	function setup(objOrCientosExposed) {
		const obj = normalizeCientosInstance(objOrCientosExposed);
		let oldOnRender = obj.onBeforeRender;
		const { off: off0 } = loop.onBeforeRender(() => {
			_isIntersected = false;
			oldOnRender = obj.onBeforeRender;
			obj.onBeforeRender = () => _isIntersected = true;
		});
		const { off: off1 } = loop.onRender(() => {
			if (_isIntersected !== _oldIsIntersected) {
				intersect.value = _isIntersected;
				unref(onChange)?.(_isIntersected);
				_oldIsIntersected = _isIntersected;
			}
		});
		return () => {
			off0();
			off1();
			obj.onBeforeRender = oldOnRender;
		};
	}
	let teardown = () => {};
	watch(ref$1, () => {
		teardown();
		if (ref$1.value) teardown = setup(ref$1.value);
	});
	return {
		ref: ref$1,
		intersect,
		off: () => teardown()
	};
}

//#endregion
//#region src/core/shapes/Box.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$32 = ["args"];
const _hoisted_2$24 = ["color"];
var Box_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Box",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				1,
				1
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const boxRef = shallowRef();
		__expose({ instance: boxRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "boxRef",
				ref: boxRef
			}, [createElementVNode("TresBoxGeometry", { args: unref(args) }, null, 8, _hoisted_1$32), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$24)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Box.vue
var Box_default = Box_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Line2.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$31 = ["object"];
var Line2_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Line2",
	props: {
		points: {
			type: Array,
			required: true
		},
		vertexColors: {
			type: [Array, null],
			required: false,
			default: null
		},
		color: {
			type: null,
			required: false,
			default: "white"
		},
		lineWidth: {
			type: Number,
			required: false,
			default: 1
		},
		worldUnits: {
			type: Boolean,
			required: false,
			default: false
		},
		alphaToCoverage: {
			type: Boolean,
			required: false,
			default: false
		},
		dashed: {
			type: Boolean,
			required: false,
			default: false
		},
		dashSize: {
			type: Number,
			required: false,
			default: 1
		},
		gapSize: {
			type: Number,
			required: false,
			default: 1
		},
		dashScale: {
			type: Number,
			required: false,
			default: 1
		},
		dashOffset: {
			type: Number,
			required: false,
			default: 0
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		function getInterpolatedVertexColors(vertexColors, numPoints) {
			if (!vertexColors || vertexColors.length === 0) return Array.from({ length: numPoints }).fill(normalizeColor(props.color));
			if (vertexColors.length === 1) return Array.from({ length: numPoints }).fill(normalizeColor(vertexColors[0]));
			if (vertexColors.length === numPoints) return vertexColors.map(normalizeColor);
			const numSegments = numPoints - 1;
			const mappedColors = vertexColors.map(normalizeColor);
			if (closed) mappedColors.push(mappedColors[0].clone());
			const iColors = [mappedColors[0]];
			const divisions = numSegments / (mappedColors.length - 1);
			for (let i = 1; i < numSegments; i++) {
				const alpha = i % divisions / divisions;
				const colorIndex = Math.floor(i / divisions);
				iColors.push(mappedColors[colorIndex].clone().lerp(mappedColors[colorIndex + 1], alpha));
			}
			iColors.push(mappedColors[mappedColors.length - 1]);
			return iColors;
		}
		const lineMaterial = new LineMaterial();
		const lineGeometry = new LineGeometry();
		const line$1 = new Line2(lineGeometry, lineMaterial);
		const { sizes, invalidate } = useTres();
		const hasVertexColors = computed(() => Array.isArray(props.vertexColors));
		function updateLineMaterial(material, props$1) {
			material.color = normalizeColor(props$1.color);
			material.linewidth = props$1.lineWidth;
			material.alphaToCoverage = props$1.alphaToCoverage;
			material.worldUnits = props$1.worldUnits;
			material.vertexColors = Array.isArray(props$1.vertexColors);
			material.dashed = props$1.dashed;
			material.dashScale = props$1.dashScale;
			material.dashSize = props$1.dashSize;
			material.dashOffset = props$1.dashOffset;
			material.gapSize = props$1.gapSize;
			material.needsUpdate = true;
		}
		function updateLineGeometry(geometry, points, vertexColors) {
			const pValues = points.map((p) => {
				if (p instanceof Vector3) return [
					p.x,
					p.y,
					p.z
				];
				else if (p instanceof Vector2) return [
					p.x,
					p.y,
					0
				];
				else if (Array.isArray(p) && p.length === 2) return [
					p[0],
					p[1],
					0
				];
				else return p;
			}).flat();
			geometry.setPositions(pValues.flat());
			const colors = getInterpolatedVertexColors(vertexColors, points.length).map((c) => c.toArray()).flat();
			geometry.setColors(colors);
			line$1.computeLineDistances();
		}
		updateLineMaterial(lineMaterial, props);
		updateLineGeometry(lineGeometry, props.points, props.vertexColors);
		line$1.computeLineDistances();
		watch(() => [
			props.color,
			props.lineWidth,
			props.alphaToCoverage,
			props.worldUnits,
			hasVertexColors,
			props.dashed,
			props.dashScale,
			props.dashSize,
			props.dashOffset
		], () => {
			updateLineMaterial(lineMaterial, props);
			invalidate();
		});
		watch(() => [props.points, props.vertexColors], () => {
			updateLineGeometry(lineGeometry, props.points, props.vertexColors);
			invalidate();
		});
		watch(() => [sizes.height, sizes.width], () => {
			lineMaterial.resolution = new Vector2(sizes.width.value, sizes.height.value);
			invalidate();
		});
		onUnmounted(() => {
			lineGeometry.dispose();
			lineMaterial.dispose();
		});
		const lineRef = shallowRef();
		__expose({ instance: lineRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", {
				ref: lineRef.value,
				object: unref(line$1)
			}, null, 8, _hoisted_1$31);
		};
	}
});

//#endregion
//#region src/core/shapes/Line2.vue
var Line2_default = Line2_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/CatmullRomCurve3.vue?vue&type=script&setup=true&lang.ts
var CatmullRomCurve3_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CatmullRomCurve3",
	props: {
		segments: {
			type: Number,
			required: false,
			default: 20
		},
		closed: {
			type: Boolean,
			required: false,
			default: false
		},
		curveType: {
			type: String,
			required: false,
			default: "centripetal"
		},
		tension: {
			type: Number,
			required: false,
			default: .5
		},
		points: {
			type: Array,
			required: true
		},
		vertexColors: {
			type: null,
			required: false
		},
		color: {
			type: null,
			required: false
		},
		lineWidth: {
			type: Number,
			required: false
		},
		alphaToCoverage: {
			type: Boolean,
			required: false
		},
		dashed: {
			type: Boolean,
			required: false
		},
		dashSize: {
			type: Number,
			required: false
		},
		dashScale: {
			type: Number,
			required: false
		},
		dashOffset: {
			type: Number,
			required: false
		},
		gapSize: {
			type: Number,
			required: false
		},
		worldUnits: {
			type: Boolean,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		function getCatmullRomCurve(points, closed$1, curveType, tension) {
			return new CatmullRomCurve3(points.map((pt) => pt instanceof Vector3 ? pt : new Vector3(...pt)), closed$1, curveType, tension);
		}
		function getSegmentedPoints(curve$1, segments) {
			return curve$1.getPoints(segments);
		}
		const curve = computed(() => getCatmullRomCurve(props.points, props.closed, props.curveType, props.tension));
		const segmentedPoints = computed(() => getSegmentedPoints(curve.value, props.segments));
		const lineRef = shallowRef();
		__expose({ instance: lineRef });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Line2_default, {
				ref: lineRef.value,
				points: segmentedPoints.value,
				"vertex-colors": props.vertexColors,
				color: props.color,
				"line-width": props.lineWidth,
				"alpha-to-coverage": props.alphaToCoverage,
				dashed: props.dashed,
				"dash-size": props.dashSize,
				"dash-scale": props.dashScale,
				"dash-offset": props.dashOffset,
				"gap-size": props.gapSize,
				"world-units": props.worldUnits
			}, null, 8, [
				"points",
				"vertex-colors",
				"color",
				"line-width",
				"alpha-to-coverage",
				"dashed",
				"dash-size",
				"dash-scale",
				"dash-offset",
				"gap-size",
				"world-units"
			]);
		};
	}
});

//#endregion
//#region src/core/shapes/CatmullRomCurve3.vue
var CatmullRomCurve3_default = CatmullRomCurve3_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Circle.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$30 = ["args"];
const _hoisted_2$23 = ["color"];
var Circle_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Circle",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				32,
				0,
				Math.PI * 2
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const circleRef = shallowRef();
		__expose({ instance: circleRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "circleRef",
				ref: circleRef
			}, [createElementVNode("TresCircleGeometry", { args: unref(args) }, null, 8, _hoisted_1$30), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$23)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Circle.vue
var Circle_default = Circle_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Cone.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$29 = ["args"];
const _hoisted_2$22 = ["color"];
var Cone_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Cone",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				1,
				12,
				12,
				false,
				0,
				Math.PI * 2
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const coneRef = shallowRef();
		__expose({ instance: coneRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "coneRef",
				ref: coneRef
			}, [createElementVNode("TresConeGeometry", { args: unref(args) }, null, 8, _hoisted_1$29), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$22)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Cone.vue
var Cone_default = Cone_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/QuadraticBezierLine.vue?vue&type=script&setup=true&lang.ts
var QuadraticBezierLine_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "QuadraticBezierLine",
	props: {
		start: {
			type: [Object, Array],
			required: true
		},
		end: {
			type: [Object, Array],
			required: true
		},
		mid: {
			type: [Object, Array],
			required: false
		},
		segments: {
			type: Number,
			required: false,
			default: 20
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const points = computed(() => {
			const startV = props.start instanceof Vector3 ? props.start : new Vector3(...props.start);
			const endV = props.end instanceof Vector3 ? props.end : new Vector3(...props.end);
			return new QuadraticBezierCurve3(startV, props.mid instanceof Vector3 ? props.mid : Array.isArray(props.mid) ? new Vector3(...props.mid) : new Vector3(endV.x, startV.y, endV.z), endV).getPoints(props.segments);
		});
		const lineRef = shallowRef();
		__expose({ instance: lineRef });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Line2_default, {
				ref_key: "lineRef",
				ref: lineRef,
				points: points.value
			}, null, 8, ["points"]);
		};
	}
});

//#endregion
//#region src/core/shapes/QuadraticBezierLine.vue
var QuadraticBezierLine_default = QuadraticBezierLine_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/CubicBezierLine.vue?vue&type=script&setup=true&lang.ts
var CubicBezierLine_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CubicBezierLine",
	props: {
		start: {
			type: [Object, Array],
			required: true
		},
		end: {
			type: [Object, Array],
			required: true
		},
		midA: {
			type: [Object, Array],
			required: true
		},
		midB: {
			type: [Object, Array],
			required: true
		},
		segments: {
			type: Number,
			required: false,
			default: 20
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const points = computed(() => {
			const startV = props.start instanceof Vector3 ? props.start : new Vector3(...props.start);
			const endV = props.end instanceof Vector3 ? props.end : new Vector3(...props.end);
			return new CubicBezierCurve3(startV, props.midA instanceof Vector3 ? props.midA : new Vector3(...props.midA), props.midB instanceof Vector3 ? props.midB : new Vector3(...props.midB), endV).getPoints(props.segments);
		});
		const lineRef = shallowRef();
		__expose({ instance: lineRef });
		return (_ctx, _cache) => {
			return openBlock(), createBlock(Line2_default, {
				ref_key: "lineRef",
				ref: lineRef,
				points: points.value
			}, null, 8, ["points"]);
		};
	}
});

//#endregion
//#region src/core/shapes/CubicBezierLine.vue
var CubicBezierLine_default = CubicBezierLine_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Cylinder.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$28 = ["args"];
const _hoisted_2$21 = ["color"];
var Cylinder_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Cylinder",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				1,
				1,
				32,
				1,
				false,
				0,
				Math.PI * 2
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const cylinderRef = shallowRef();
		__expose({ instance: cylinderRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "cylinderRef",
				ref: cylinderRef
			}, [createElementVNode("TresCylinderGeometry", { args: unref(args) }, null, 8, _hoisted_1$28), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$21)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Cylinder.vue
var Cylinder_default = Cylinder_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Dodecahedron.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$27 = ["args"];
const _hoisted_2$20 = ["color"];
var Dodecahedron_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Dodecahedron",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [1, 0]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const dodecahedronRef = shallowRef();
		__expose({ instance: dodecahedronRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "dodecahedronRef",
				ref: dodecahedronRef
			}, [createElementVNode("TresDodecahedronGeometry", { args: unref(args) }, null, 8, _hoisted_1$27), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$20)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Dodecahedron.vue
var Dodecahedron_default = Dodecahedron_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Icosahedron.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$26 = ["args"];
const _hoisted_2$19 = ["color"];
var Icosahedron_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Icosahedron",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [1, 0]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const icosahedronRef = shallowRef();
		__expose({ instance: icosahedronRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "icosahedronRef",
				ref: icosahedronRef
			}, [createElementVNode("TresIcosahedronGeometry", { args: unref(args) }, null, 8, _hoisted_1$26), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$19)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Icosahedron.vue
var Icosahedron_default = Icosahedron_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Octahedron.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$25 = ["args"];
const _hoisted_2$18 = ["color"];
var Octahedron_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Octahedron",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [1, 0]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const octahedronRef = shallowRef();
		__expose({ instance: octahedronRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "octahedronRef",
				ref: octahedronRef
			}, [createElementVNode("TresOctahedronGeometry", { args: unref(args) }, null, 8, _hoisted_1$25), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$18)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Octahedron.vue
var Octahedron_default = Octahedron_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Plane.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$24 = ["rotation"];
const _hoisted_2$17 = ["args"];
const _hoisted_3$4 = ["color"];
var Plane_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Plane",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [1, 1]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const planeRef = shallowRef();
		__expose({ instance: planeRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "planeRef",
				ref: planeRef,
				rotation: [
					-Math.PI / 2,
					0,
					0
				]
			}, [createElementVNode("TresPlaneGeometry", { args: unref(args) }, null, 8, _hoisted_2$17), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_3$4)])], 8, _hoisted_1$24);
		};
	}
});

//#endregion
//#region src/core/shapes/Plane.vue
var Plane_default = Plane_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Ring.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$23 = ["args"];
const _hoisted_2$16 = ["color"];
var Ring_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Ring",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				.5,
				1,
				32
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const { args, color } = toRefs(__props);
		const { invalidate } = useTres();
		watch(args, () => {
			invalidate();
		});
		const ringRef = shallowRef();
		__expose({ instance: ringRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "ringRef",
				ref: ringRef
			}, [createElementVNode("TresRingGeometry", { args: unref(args) }, null, 8, _hoisted_1$23), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$16)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Ring.vue
var Ring_default = Ring_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/RoundedBox.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$22 = ["args"];
const _hoisted_2$15 = ["color"];
var RoundedBox_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "RoundedBox",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				1,
				1,
				2,
				.1
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const { args, color } = toRefs(__props);
		const { invalidate, extend: extend$1 } = useTres();
		extend$1({ RoundedBoxGeometry });
		watch(args, () => {
			invalidate();
		});
		const roundedBoxRef = shallowRef();
		__expose({ instance: roundedBoxRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "roundedBoxRef",
				ref: roundedBoxRef
			}, [createElementVNode("TresRoundedBoxGeometry", { args: unref(args) }, null, 8, _hoisted_1$22), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$15)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/RoundedBox.vue
var RoundedBox_default = RoundedBox_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/ScreenQuad.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$21 = ["geometry"];
var ScreenQuad_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ScreenQuad",
	setup(__props, { expose: __expose }) {
		const geometry = new THREE.BufferGeometry();
		const vertices = new Float32Array([
			-1,
			-1,
			3,
			-1,
			-1,
			3
		]);
		geometry.boundingSphere = new THREE.Sphere();
		geometry.boundingSphere.set(new THREE.Vector3(), Infinity);
		geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 2));
		const meshRef = shallowRef();
		__expose({ instance: meshRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "meshRef",
				ref: meshRef,
				geometry: unref(geometry),
				"frustum-culled": false
			}, [renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$21);
		};
	}
});

//#endregion
//#region src/core/shapes/ScreenQuad.vue
var ScreenQuad_default = ScreenQuad_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Sphere.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$20 = ["args"];
const _hoisted_2$14 = ["color"];
var Sphere_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Sphere",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				2,
				32,
				16
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const sphereRef = shallowRef();
		__expose({ instance: sphereRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "sphereRef",
				ref: sphereRef
			}, [createElementVNode("TresSphereGeometry", { args: unref(args) }, null, 8, _hoisted_1$20), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$14)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Sphere.vue
var Sphere_default = Sphere_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Superformula.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$19 = ["geometry"];
const _hoisted_2$13 = ["color"];
var Superformula_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Superformula",
	props: {
		widthSegments: {
			type: Number,
			required: false,
			default: 32
		},
		heightSegments: {
			type: Number,
			required: false,
			default: 32
		},
		numArmsA: {
			type: Number,
			required: false,
			default: 4
		},
		expA: {
			type: Array,
			required: false,
			default: () => [
				40,
				1.3,
				.9
			]
		},
		numArmsB: {
			type: Number,
			required: false,
			default: 4
		},
		expB: {
			type: Array,
			required: false,
			default: () => [
				40,
				1.3,
				.9
			]
		},
		color: {
			type: null,
			required: false,
			default: "white"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { cos, sin, abs } = Math;
		const geometry = shallowRef();
		const color = shallowRef(props.color);
		function makeGeometry(widthSegments, heightSegments) {
			const geometry$1 = new BufferGeometry();
			const numPoints = widthSegments * heightSegments;
			const vertices = new Float32Array(Array.from({ length: 3 * numPoints }).fill(0));
			const normals = new Float32Array(Array.from({ length: 3 * numPoints }).fill(0));
			const indices = [];
			for (let h = 0; h < heightSegments - 1; h++) {
				for (let w = 0; w < widthSegments - 1; w++) {
					const tl$1 = h * widthSegments + w;
					const tr$1 = tl$1 + 1;
					const bl$1 = tl$1 + widthSegments;
					const br$1 = tr$1 + widthSegments;
					indices.push(tl$1, bl$1, tr$1);
					indices.push(bl$1, br$1, tr$1);
				}
				const tl = h * widthSegments + widthSegments - 1;
				const tr = h * widthSegments;
				const bl = tl + widthSegments;
				const br = tr + widthSegments;
				indices.push(tl, bl, tr);
				indices.push(bl, br, tr);
			}
			geometry$1.setIndex(indices);
			geometry$1.setAttribute("position", new BufferAttribute(vertices, 3));
			geometry$1.setAttribute("normal", new BufferAttribute(normals, 3));
			return geometry$1;
		}
		function r(theta, numArms, exp1, exp2, exp3) {
			return (abs(cos(numArms * theta * .25)) ** exp2 + abs(sin(numArms * theta * .25)) ** exp3) ** (-1 / exp1);
		}
		function updateGeometry(geometry$1, numArmsA, expA1, expA2, expA3, numArmsB, expB1, expB2, expB3, widthSegments, heightSegments) {
			const thetaStep = 2 * Math.PI / widthSegments;
			const thetaStart = -Math.PI;
			const phiStep = Math.PI / (heightSegments - 1);
			const phiStart = -.5 * Math.PI;
			const positionAttribute = geometry$1.getAttribute("position");
			let i = 0;
			let theta = 0;
			let phi = phiStart;
			for (let pi = 0; pi < heightSegments; pi++) {
				theta = thetaStart;
				for (let ti = 0; ti < widthSegments; ti++) {
					const rA = r(theta, numArmsA, expA1, expA2, expA3);
					const rB = r(phi, numArmsB, expB1, expB2, expB3);
					positionAttribute.setXYZ(i, rA * cos(theta) * rB * cos(phi), rB * sin(phi), rA * sin(theta) * rB * cos(phi));
					i++;
					theta += thetaStep;
				}
				phi += phiStep;
			}
			positionAttribute.needsUpdate = true;
			geometry$1.computeVertexNormals();
		}
		watch(() => props.color, () => color.value = props.color);
		watch(() => [props.widthSegments, props.heightSegments], () => {
			if (geometry.value) geometry.value.dispose();
			geometry.value = makeGeometry(props.widthSegments, props.heightSegments);
			invalidate();
		}, { immediate: true });
		watch(() => [
			props.numArmsA,
			props.expA[0],
			props.expA[1],
			props.expA[2],
			props.numArmsB,
			props.expB[0],
			props.expB[1],
			props.expB[2]
		], () => {
			updateGeometry(geometry.value, props.numArmsA, props.expA[0], props.expA[1], props.expA[2], props.numArmsB, props.expB[0], props.expB[1], props.expB[2], props.widthSegments, props.heightSegments);
			invalidate();
		}, { immediate: true });
		onUnmounted(() => {
			if (geometry.value) geometry.value.dispose();
		});
		const superformulaRef = shallowRef();
		__expose({ instance: superformulaRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "superformulaRef",
				ref: superformulaRef,
				geometry: geometry.value
			}, [renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: color.value }, null, 8, _hoisted_2$13)])], 8, _hoisted_1$19);
		};
	}
});

//#endregion
//#region src/core/shapes/Superformula.vue
var Superformula_default = Superformula_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Tetrahedron.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$18 = ["rotation"];
const _hoisted_2$12 = ["args"];
const _hoisted_3$3 = ["color"];
var Tetrahedron_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Tetrahedron",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [1, 0]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const tetrahedronRef = shallowRef();
		__expose({ instance: tetrahedronRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "tetrahedronRef",
				ref: tetrahedronRef,
				rotation: [
					-Math.PI / 2,
					0,
					0
				]
			}, [createElementVNode("TresTetrahedronGeometry", { args: unref(args) }, null, 8, _hoisted_2$12), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_3$3)])], 8, _hoisted_1$18);
		};
	}
});

//#endregion
//#region src/core/shapes/Tetrahedron.vue
var Tetrahedron_default = Tetrahedron_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Torus.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$17 = ["args"];
const _hoisted_2$11 = ["color"];
var Torus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Torus",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				1,
				16,
				80
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const { args, color } = toRefs(__props);
		const { invalidate } = useTres();
		watch(args, () => {
			invalidate();
		});
		const torusRef = shallowRef();
		__expose({ instance: torusRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "torusRef",
				ref: torusRef
			}, [createElementVNode("TresTorusGeometry", { args: unref(args) }, null, 8, _hoisted_1$17), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$11)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Torus.vue
var Torus_default = Torus_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/TorusKnot.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$16 = ["args"];
const _hoisted_2$10 = ["color"];
var TorusKnot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "TorusKnot",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				1,
				.4,
				64,
				8
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const { args, color } = toRefs(__props);
		const { invalidate } = useTres();
		watch(args, () => {
			invalidate();
		});
		const torusKnotRef = shallowRef();
		__expose({ instance: torusKnotRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "torusKnotRef",
				ref: torusKnotRef
			}, [createElementVNode("TresTorusKnotGeometry", { args: unref(args) }, null, 8, _hoisted_1$16), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$10)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/TorusKnot.vue
var TorusKnot_default = TorusKnot_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/shapes/Tube.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$15 = ["args"];
const _hoisted_2$9 = ["color"];
var Tube_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Tube",
	props: {
		args: {
			type: Array,
			required: false,
			default: () => [
				new QuadraticBezierCurve3(new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 0, 0)),
				20,
				.2,
				8,
				false
			]
		},
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const { args, color } = toRefs(props);
		watch(args, () => {
			invalidate();
		});
		const tubeRef = shallowRef();
		__expose({ instance: tubeRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "tubeRef",
				ref: tubeRef
			}, [createElementVNode("TresTubeGeometry", { args: unref(args) }, null, 8, _hoisted_1$15), renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("TresMeshBasicMaterial", { color: unref(color) }, null, 8, _hoisted_2$9)])], 512);
		};
	}
});

//#endregion
//#region src/core/shapes/Tube.vue
var Tube_default = Tube_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/RandomizedLights/RandomizedLights.ts
var RandomizedLights = class extends Group {
	/** Light position */
	position = new Vector3(0, 0, 0);
	/** Radius of the jiggle, higher values make softer light */
	radius = 1;
	/** Light intensity */
	intensity = Math.PI;
	/** Ambient occlusion, lower values mean less AO, hight more, you can mix AO and directional light */
	ambient = .5;
	/** If the lights cast shadows */
	castShadow = true;
	/** Default shadow bias */
	bias = 0;
	constructor(config = {}) {
		super();
		Object.assign(this, config);
		if (this.count === 0) this.count = 8;
		if (!config.mapSize) this.mapSize = 512;
		if (!config.size) this.size = 10;
		if (!config.near) this.near = .5;
		if (!config.far) this.far = 500;
	}
	get length() {
		return this.position.length();
	}
	set count(n) {
		this.clear();
		for (let i = 0; i < n; i++) this.add(new DirectionalLight("white", this.intensity));
	}
	get count() {
		return this.children.filter((c) => "isDirectionalLight" in c).length;
	}
	get mapSize() {
		return this.lights[0].shadow.mapSize.width;
	}
	set mapSize(n) {
		for (const light of this.lights) {
			light.shadow.mapSize.set(n, n);
			light.shadow.map?.setSize(n, n);
		}
	}
	get size() {
		return this.lights[0].shadow.camera.right;
	}
	set size(n) {
		for (const light of this.lights) {
			light.shadow.camera.left = -n;
			light.shadow.camera.right = n;
			light.shadow.camera.top = n;
			light.shadow.camera.bottom = -n;
		}
	}
	get near() {
		return this.lights[0].shadow.camera.near;
	}
	set near(n) {
		for (const light of this.lights) light.shadow.camera.near = n;
	}
	get far() {
		return this.lights[0].shadow.camera.far;
	}
	set far(n) {
		for (const light of this.lights) light.shadow.camera.far = n;
	}
	get lights() {
		return this.children.filter((c) => "isDirectionalLight" in c);
	}
	update() {
		const lights = this.lights;
		const lightIntensity = this.intensity / lights.length;
		let ambientCount = Math.floor(this.ambient * lights.length);
		for (const light of lights) {
			light.castShadow = this.castShadow;
			light.shadow.bias = this.bias;
			light.intensity = lightIntensity;
			if (ambientCount-- > 0) {
				const lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2;
				const phi = 2 * Math.PI * Math.random();
				light.position.set(Math.cos(lambda) * Math.cos(phi) * this.length, Math.abs(Math.cos(lambda) * Math.sin(phi) * this.length), Math.sin(lambda) * this.length);
			} else if (Math.random() > this.ambient) light.position.set(this.position.x + MathUtils.randFloatSpread(this.radius), this.position.y + MathUtils.randFloatSpread(this.radius), this.position.z + MathUtils.randFloatSpread(this.radius));
		}
	}
};

//#endregion
//#region src/core/staging/RandomizedLights/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$14 = [
	"count",
	"radius",
	"intensity",
	"ambient",
	"cast-shadow",
	"bias",
	"map-size",
	"size",
	"near",
	"far",
	"position"
];
var component_vue_vue_type_script_setup_true_lang_default$4 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		count: {
			type: Number,
			required: false,
			default: 8
		},
		radius: {
			type: Number,
			required: false,
			default: 1
		},
		intensity: {
			type: Number,
			required: false,
			default: Math.PI
		},
		ambient: {
			type: Number,
			required: false,
			default: .5
		},
		castShadow: {
			type: Boolean,
			required: false,
			default: true
		},
		bias: {
			type: Number,
			required: false,
			default: 0
		},
		mapSize: {
			type: Number,
			required: false,
			default: 512
		},
		size: {
			type: Number,
			required: false,
			default: 10
		},
		near: {
			type: Number,
			required: false,
			default: .5
		},
		far: {
			type: Number,
			required: false,
			default: 500
		},
		position: {
			type: [
				Object,
				Array,
				Number
			],
			required: false,
			default: () => [
				5,
				5,
				-10
			]
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		extend({ RandomizedLights });
		const lightsRef = shallowRef();
		const pos = computed(() => normalizeVectorFlexibleParam(props.position));
		__expose({ instance: lightsRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresRandomizedLights", {
				ref_key: "lightsRef",
				ref: lightsRef,
				count: __props.count,
				radius: __props.radius,
				intensity: __props.intensity,
				ambient: __props.ambient,
				"cast-shadow": __props.castShadow,
				bias: __props.bias,
				"map-size": __props.mapSize,
				size: __props.size,
				near: __props.near,
				far: __props.far,
				position: pos.value
			}, null, 8, _hoisted_1$14);
		};
	}
});

//#endregion
//#region src/core/staging/RandomizedLights/component.vue
var component_default$14 = component_vue_vue_type_script_setup_true_lang_default$4;

//#endregion
//#region src/core/staging/AccumulativeShadows/ProgressiveLightMap.ts
function isLight(object) {
	return object.isLight;
}
function isGeometry(object) {
	return !!object.geometry;
}
var ProgressiveLightMap = class {
	renderer;
	res;
	scene;
	object;
	lightsGroup = null;
	buffer1Active;
	progressiveLightMap1;
	progressiveLightMap2;
	discardMat;
	targetMat;
	previousShadowMap;
	averagingWindow;
	clearColor;
	clearAlpha;
	lights;
	meshes;
	constructor(renderer, scene, res = 1024) {
		this.renderer = renderer;
		this.res = res;
		this.scene = scene;
		this.buffer1Active = false;
		this.lights = [];
		this.meshes = [];
		this.object = null;
		this.clearColor = new Color();
		this.clearAlpha = 0;
		const textureParams = {
			type: HalfFloatType,
			magFilter: NearestFilter,
			minFilter: NearestFilter
		};
		this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, textureParams);
		this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, textureParams);
		this.discardMat = new MeshDiscardMaterial();
		this.targetMat = new MeshLambertMaterial({ fog: false });
		this.previousShadowMap = { value: this.progressiveLightMap1.texture };
		this.averagingWindow = { value: 100 };
		this.targetMat.onBeforeCompile = (shader) => {
			shader.vertexShader = `varying vec2 vUv;
        ${shader.vertexShader.slice(0, -1)}
        vUv = uv; 
        gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }`;
			const bodyStart = shader.fragmentShader.indexOf("void main() {");
			shader.fragmentShader = `
        varying vec2 vUv;
        ${shader.fragmentShader.slice(0, bodyStart)}
        uniform sampler2D previousShadowMap;
        uniform float averagingWindow;
        ${shader.fragmentShader.slice(bodyStart - 1, -1)}
        vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0 / averagingWindow);
      }`;
			shader.uniforms.previousShadowMap = this.previousShadowMap;
			shader.uniforms.averagingWindow = this.averagingWindow;
		};
	}
	clear() {
		this.renderer.getClearColor(this.clearColor);
		this.clearAlpha = this.renderer.getClearAlpha();
		this.renderer.setClearColor("black", 1);
		this.renderer.setRenderTarget(this.progressiveLightMap1);
		this.renderer.clear();
		this.renderer.setRenderTarget(this.progressiveLightMap2);
		this.renderer.clear();
		this.renderer.setRenderTarget(null);
		this.renderer.setClearColor(this.clearColor, this.clearAlpha);
		this.lights = [];
		this.meshes = [];
		this.scene.traverse((object) => {
			if (object === this.lightsGroup) return false;
			if (isGeometry(object)) this.meshes.push({
				object,
				material: object.material
			});
			else if (isLight(object)) this.lights.push({
				object,
				intensity: object.intensity
			});
		});
	}
	prepare() {
		this.lights.forEach((light) => light.object.intensity = 0);
		this.meshes.forEach((mesh) => mesh.object.material = this.discardMat);
	}
	finish() {
		this.lights.forEach((light) => light.object.intensity = light.intensity);
		this.meshes.forEach((mesh) => mesh.object.material = mesh.material);
	}
	configure(object, lightsGroup) {
		this.object = object;
		this.lightsGroup = lightsGroup;
	}
	update(camera, blendWindow = 100) {
		if (!this.object) return;
		this.averagingWindow.value = blendWindow;
		this.object.material = this.targetMat;
		const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;
		const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;
		const oldBg = this.scene.background;
		this.scene.background = null;
		this.renderer.setRenderTarget(activeMap);
		this.previousShadowMap.value = inactiveMap.texture;
		this.buffer1Active = !this.buffer1Active;
		this.renderer.render(this.scene, camera);
		this.renderer.setRenderTarget(null);
		this.scene.background = oldBg;
	}
};

//#endregion
//#region src/core/staging/AccumulativeShadows/SoftShadowMaterial.ts
const SoftShadowMaterial = /* @__PURE__ */ shaderMaterial({
	color: new Color(),
	blend: 2,
	alphaTest: .75,
	opacity: 0,
	map: null
}, `varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vUv = uv;
   }`, `varying vec2 vUv;
   uniform sampler2D map;
   uniform vec3 color;
   uniform float opacity;
   uniform float alphaTest;
   uniform float blend;
   void main() {
     vec4 sampledDiffuseColor = texture2D(map, vUv);
     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
     #include <tonemapping_fragment>
     #include <colorspace_fragment>
   }`);

//#endregion
//#region src/core/staging/AccumulativeShadows/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$13 = ["scale", "rotation"];
const _hoisted_2$8 = [
	"alpha-test",
	"blend",
	"color",
	"map",
	"opacity",
	"tone-mapped"
];
var component_vue_vue_type_script_setup_true_lang_default$3 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		once: {
			type: Boolean,
			required: false,
			default: true
		},
		accumulate: {
			type: Boolean,
			required: false,
			default: true
		},
		frames: {
			type: Number,
			required: false,
			default: 40
		},
		blend: {
			type: Number,
			required: false,
			default: 20
		},
		limit: {
			type: Number,
			required: false,
			default: Infinity
		},
		scale: {
			type: Number,
			required: false,
			default: 10
		},
		opacity: {
			type: Number,
			required: false,
			default: 1
		},
		alphaTest: {
			type: Number,
			required: false,
			default: .65
		},
		color: {
			type: [
				Object,
				String,
				Number
			],
			required: false,
			default: "black"
		},
		colorBlend: {
			type: Number,
			required: false,
			default: 2
		},
		resolution: {
			type: Number,
			required: false,
			default: 1024
		},
		toneMapped: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		extend({ SoftShadowMaterial });
		const { renderer, scene, camera, invalidate } = useTres();
		const gOuter = shallowRef();
		const gPlane = shallowRef(null);
		const gLights = shallowRef(new Group());
		const progressiveLightMap = computed(() => new ProgressiveLightMap(renderer, scene.value, props.resolution));
		const shadowMapTexture = shallowRef();
		let frameCount = 0;
		let frameLimitRemaining = props.limit;
		function reset() {
			progressiveLightMap.value.clear();
			if (gPlane.value) {
				const material = gPlane.value.material;
				material.opacity = 0;
				material.alphaTest = 0;
			}
			frameCount = 0;
			frameLimitRemaining = props.limit;
		}
		function update(frames = 1) {
			if (gPlane.value) {
				const material = gPlane.value.material;
				if (props.accumulate) {
					material.opacity = Math.min(props.opacity, material.opacity + props.opacity / Math.max(2, props.blend));
					material.alphaTest = Math.min(props.alphaTest, material.alphaTest + props.alphaTest / Math.max(2, props.blend));
				} else {
					material.opacity = props.opacity;
					material.alphaTest = props.alphaTest;
				}
			}
			gLights.value.visible = true;
			progressiveLightMap.value.prepare();
			for (let i = 0; i < frames; i++) {
				gLights.value?.children.forEach((light) => {
					if ("update" in light && typeof light.update === "function") light.update();
				});
				if (camera.value) {
					const blend = Math.max(2, props.accumulate ? props.blend : props.frames);
					progressiveLightMap.value.update(camera.value, blend);
				}
			}
			gLights.value.visible = false;
			progressiveLightMap.value.finish();
			shadowMapTexture.value = progressiveLightMap.value.progressiveLightMap2.texture;
		}
		watchEffect(() => {
			if (gPlane.value) progressiveLightMap.value.configure(gPlane.value, gLights.value);
		});
		watch(() => [
			props.frames,
			props.once,
			props.accumulate,
			props.scale,
			props.limit
		], reset);
		watchEffect(reset);
		useLoop().onBeforeRender(() => {
			if (!props.once) frameCount = 0;
			frameLimitRemaining--;
			if (frameLimitRemaining < 0) return;
			if (props.accumulate && props.once) {
				if (frameCount < props.frames || frameCount < props.blend) {
					invalidate();
					update();
					frameCount++;
				}
			} else {
				invalidate();
				if (frameCount < props.frames) {
					update(props.frames - frameCount);
					frameCount = props.frames;
				}
			}
		});
		watchEffect(() => gLights.value.traverse = () => null);
		__expose({
			instance: gOuter,
			update: () => {
				reset();
				update();
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "gOuter",
				ref: gOuter
			}, [createElementVNode("TresGroup", {
				ref_key: "gLights",
				ref: gLights
			}, [renderSlot(_ctx.$slots, "default", {}, () => [createVNode(component_default$14, {
				ambient: .25,
				bias: .001,
				count: 8,
				intensity: Math.PI,
				"map-size": 1024,
				position: [
					5,
					5,
					-10
				],
				radius: 2
			}, null, 8, ["intensity"])])], 512), createElementVNode("TresMesh", {
				ref_key: "gPlane",
				ref: gPlane,
				"receive-shadow": true,
				scale: __props.scale,
				rotation: [
					-Math.PI / 2,
					0,
					0
				]
			}, [_cache[0] || (_cache[0] = createElementVNode("TresPlaneGeometry", null, null, -1)), createElementVNode("TresSoftShadowMaterial", {
				"alpha-test": __props.alphaTest,
				blend: __props.colorBlend,
				color: __props.color,
				"depth-write": false,
				map: shadowMapTexture.value,
				opacity: __props.opacity,
				"tone-mapped": __props.toneMapped,
				transparent: true
			}, null, 8, _hoisted_2$8)], 8, _hoisted_1$13)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/AccumulativeShadows/component.vue
var component_default = component_vue_vue_type_script_setup_true_lang_default$3;

//#endregion
//#region src/core/staging/Align.vue?vue&type=script&setup=true&lang.ts
var Align_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Align",
	props: {
		top: {
			type: Boolean,
			required: false
		},
		right: {
			type: Boolean,
			required: false
		},
		bottom: {
			type: Boolean,
			required: false
		},
		left: {
			type: Boolean,
			required: false
		},
		front: {
			type: Boolean,
			required: false
		},
		back: {
			type: Boolean,
			required: false
		},
		disable: {
			type: Boolean,
			required: false
		},
		disableX: {
			type: Boolean,
			required: false
		},
		disableY: {
			type: Boolean,
			required: false
		},
		disableZ: {
			type: Boolean,
			required: false
		},
		precise: {
			type: Boolean,
			required: false,
			default: true
		},
		cacheKey: {
			type: null,
			required: false,
			default: void 0
		}
	},
	emits: ["update", "change"],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const ref$1 = shallowRef();
		const outer = shallowRef();
		const inner = shallowRef();
		const box3 = new Box3();
		const center = new Vector3();
		const sphere = new Sphere();
		const previous = {
			width: 0,
			height: 0,
			depth: 0,
			position: new Vector3()
		};
		function update() {
			if (!outer.value || !inner.value || !ref$1.value) return;
			outer.value.matrixWorld.identity();
			box3.setFromObject(inner.value, props.precise);
			const width = box3.max.x - box3.min.x;
			const height = box3.max.y - box3.min.y;
			const depth = box3.max.z - box3.min.z;
			box3.getCenter(center);
			box3.getBoundingSphere(sphere);
			const yAlign = props.top ? height / 2 : props.bottom ? -height / 2 : 0;
			const xAlign = props.left ? -width / 2 : props.right ? width / 2 : 0;
			const zAlign = props.front ? depth / 2 : props.back ? -depth / 2 : 0;
			outer.value.position.set(props.disable || props.disableX ? 0 : -center.x + xAlign, props.disable || props.disableY ? 0 : -center.y + yAlign, props.disable || props.disableZ ? 0 : -center.z + zAlign);
			if (previous.width !== width || previous.height !== height || previous.depth !== depth || !outer.value.position.equals(previous.position)) {
				emit("change", {
					parent: ref$1.value.parent,
					container: ref$1.value,
					width,
					height,
					depth,
					boundingBox: box3,
					boundingSphere: sphere,
					center,
					verticalAlignment: yAlign,
					horizontalAlignment: xAlign,
					depthAlignment: zAlign
				});
				previous.width = width;
				previous.height = height;
				previous.depth = depth;
				previous.position.copy(outer.value.position);
			}
		}
		let off = null;
		let cacheKey = null;
		const loop = useLoop();
		watchEffect(() => {
			off?.();
			off = null;
			const nextKey = toValue(props.cacheKey);
			if (nextKey === cacheKey && cacheKey !== null && cacheKey !== void 0) return;
			cacheKey = nextKey;
			if (props.cacheKey === null || props.cacheKey === void 0) off = loop.onBeforeRender(() => {
				update();
			}).off;
			else update();
		});
		__expose({
			instance: ref$1,
			update
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "ref",
				ref: ref$1
			}, [createElementVNode("TresGroup", {
				ref_key: "outer",
				ref: outer
			}, [createElementVNode("TresGroup", {
				ref_key: "inner",
				ref: inner
			}, [renderSlot(_ctx.$slots, "default")], 512)], 512)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Align.vue
var Align_default = Align_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Backdrop.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$12 = ["receive-shadow", "rotation"];
const _hoisted_2$7 = ["args"];
var Backdrop_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Backdrop",
	props: {
		floor: {
			type: Number,
			required: false,
			default: .25
		},
		segments: {
			type: Number,
			required: false,
			default: 20
		},
		receiveShadow: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const easeInExpo = (x) => x === 0 ? 0 : 2 ** (10 * x - 10);
		const { floor, segments, receiveShadow } = toRefs(props);
		const planeRef = ref(null);
		watch([
			segments,
			floor,
			planeRef
		], ([segments$1, floor$1, planeRef$1]) => {
			if (!planeRef$1 || segments$1 === null) return;
			let i = 0;
			const offset = segments$1 / segments$1 / 2;
			const position = planeRef$1.attributes.position;
			for (let x = 0; x < segments$1 + 1; x++) for (let y = 0; y < segments$1 + 1; y++) position.setXYZ(i++, x / segments$1 - offset + (x === 0 ? -floor$1 : 0), y / segments$1 - offset, easeInExpo(x / segments$1));
			position.needsUpdate = true;
			planeRef$1.computeVertexNormals();
		});
		const backdropRef = shallowRef();
		__expose({ instance: backdropRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "backdropRef",
				ref: backdropRef
			}, [createElementVNode("TresMesh", {
				"receive-shadow": unref(receiveShadow),
				rotation: [
					-Math.PI / 2,
					0,
					Math.PI / 2
				]
			}, [createElementVNode("TresPlaneGeometry", {
				ref_key: "planeRef",
				ref: planeRef,
				args: [
					1,
					1,
					unref(segments),
					unref(segments)
				]
			}, null, 8, _hoisted_2$7), renderSlot(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createElementVNode("TresMeshStandardMaterial", {
				color: 8421504,
				side: 2
			}, null, -1))])], 8, _hoisted_1$12)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Backdrop.vue
var Backdrop_default = Backdrop_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Bounds/Bounds.ts
var AnimationState = /* @__PURE__ */ function(AnimationState$1) {
	AnimationState$1[AnimationState$1["NONE"] = 0] = "NONE";
	AnimationState$1[AnimationState$1["ACTIVE"] = 2] = "ACTIVE";
	return AnimationState$1;
}(AnimationState || {});
const isOrthographicCamera = (def) => def && def.isOrthographicCamera;
const isPerspectiveCamera = (def) => def && def.isPerspectiveCamera;
const isBox3 = (def) => def && def.isBox3;
const easingFnDefault = (t) => {
	return 1 - Math.exp(-5 * t) + .007 * t;
};
var Bounds = class extends Object3D {
	camera;
	offset = .2;
	duration = 1;
	clip = true;
	_start = {
		position: new Vector3(),
		quaternion: new Quaternion(),
		zoom: 1
	};
	_goal = {
		position: void 0,
		quaternion: void 0,
		zoom: void 0,
		up: void 0,
		lookAt: void 0,
		box: void 0,
		object: void 0
	};
	_animationState = AnimationState.NONE;
	_t = 0;
	_controls = null;
	_controlsRemoveEventListener = () => {};
	_cachedFitArgs = [this];
	constructor(camera) {
		super();
		this.camera = camera;
	}
	dispose() {
		this.controls = null;
	}
	onStart(_) {}
	onCancel(_) {}
	onEnd(_) {}
	easing = easingFnDefault;
	get controls() {
		return this._controls;
	}
	set controls(controls) {
		this._controlsRemoveEventListener();
		this._controlsRemoveEventListener = () => {};
		if (controls) {
			this._controls = controls;
			const callback = () => {
				if (controls && this._goal.lookAt && this._animationState !== AnimationState.NONE) {
					const front$1 = new Vector3().setFromMatrixColumn(this.camera.matrix, 2);
					const d0 = this._start.position.distanceTo(controls.target);
					const d1 = (this._goal.position || this._start.position).distanceTo(this._goal.lookAt);
					const d = (1 - this._t) * d0 + this._t * d1;
					controls.target.copy(this.camera.position).addScaledVector(front$1, -d);
					controls.update();
					this._stop();
				}
				this._animationState = AnimationState.NONE;
			};
			controls.addEventListener("start", callback);
			this._controlsRemoveEventListener = () => controls.removeEventListener("start", callback);
		}
	}
	_stop() {
		if (this._goal.position) this.onCancel(this._goal);
		_resetGoal(this._goal);
	}
	lookAt(arg0, arg1, arg2) {
		const size = arguments.length;
		let args = this._cachedFitArgs;
		const v1$1 = arg1 ? new Vector3().fromArray(normalizeVectorFlexibleParam(arg1)) : new Vector3();
		const v2$1 = arg2 ? new Vector3().fromArray(normalizeVectorFlexibleParam(arg2)) : new Vector3();
		if (size === 0) args = this._cachedFitArgs;
		else if (!arg0 && arg0 !== 0) {
			if (size === 1) args = [null];
			else if (size === 2) args = [null, v1$1];
			else if (size === 3) args = [
				null,
				v1$1,
				v2$1
			];
		} else if (typeof arg0 === "number" || arg0.isVector3 || Array.isArray(arg0)) {
			const v0 = new Vector3().fromArray(normalizeVectorFlexibleParam(arg0));
			if (size === 1) args = [v0];
			else if (size === 2) args = [v0, v1$1];
			else if (size === 3) args = [
				v0,
				v1$1,
				v2$1
			];
		} else if (arg0.isBox3) if (size === 1) args = [arg0];
		else args = [arg0, arg1];
		else if (arg0.isObject3D) if (size === 1) args = [arg0];
		else args = [arg0, arg1];
		this._cachedFitArgs = args;
		this._stop();
		_resetGoal(this._goal);
		if (args.length > 0 && (args[0] === null || args[0] === void 0 || args[0].isVector3)) {
			const [lookAt, position, up] = args;
			this._start.position.copy(this.camera.position);
			this._start.quaternion.copy(this.camera.quaternion);
			isOrthographicCamera(this.camera) && (this._start.zoom = this.camera.zoom);
			if (position) this._goal.position = Array.isArray(position) ? new Vector3(...position) : position.clone();
			else this._goal.position = this.camera.position;
			if (lookAt) this._goal.lookAt = Array.isArray(lookAt) ? new Vector3(...lookAt) : lookAt.clone();
			else this._goal.lookAt = new Vector3(0, 0, 1).applyQuaternion(this.camera.quaternion);
			if (up) this._goal.up = Array.isArray(up) ? new Vector3(...up) : up.clone();
			const mCamRot = new Matrix4().lookAt(this._goal.position || this.camera.position, this._goal.lookAt, this._goal.up ?? this.camera.up);
			this._goal.quaternion = new Quaternion().setFromRotationMatrix(mCamRot);
		} else {
			const box3OrObject = args[0];
			const { center, distance, box } = _getSize(box3OrObject, this.camera, this.offset);
			this._start.position.copy(this.camera.position);
			this._start.quaternion.copy(this.camera.quaternion);
			isOrthographicCamera(this.camera) && (this._start.zoom = this.camera.zoom);
			const direction = this.camera.position.clone().sub(center).normalize();
			this._goal.object = box3OrObject;
			this._goal.box = box;
			this._goal.position = center.clone().addScaledVector(direction, distance);
			this._goal.lookAt = center.clone();
			const mCamRot = new Matrix4().lookAt(this._goal.position, this._goal.lookAt, this.camera.up);
			this._goal.quaternion = new Quaternion().setFromRotationMatrix(mCamRot);
			if (isOrthographicCamera(this.camera)) {
				let maxHeight = 0;
				let maxWidth = 0;
				const vertices = [
					new Vector3(box.min.x, box.min.y, box.min.z),
					new Vector3(box.min.x, box.max.y, box.min.z),
					new Vector3(box.min.x, box.min.y, box.max.z),
					new Vector3(box.min.x, box.max.y, box.max.z),
					new Vector3(box.max.x, box.max.y, box.max.z),
					new Vector3(box.max.x, box.max.y, box.min.z),
					new Vector3(box.max.x, box.min.y, box.max.z),
					new Vector3(box.max.x, box.min.y, box.min.z)
				];
				const goal = this._goal;
				const pos = goal.position || this.camera.position;
				const target = goal.lookAt || this._controls?.target;
				const up = goal.up || this.camera.up;
				const mCamWInv = target ? new Matrix4().lookAt(pos, target, up).setPosition(pos).invert() : this.camera.matrixWorldInverse;
				for (const v of vertices) {
					v.applyMatrix4(mCamWInv);
					maxHeight = Math.max(maxHeight, Math.abs(v.y));
					maxWidth = Math.max(maxWidth, Math.abs(v.x));
				}
				maxHeight *= 2;
				maxWidth *= 2;
				const zoomForHeight = (this.camera.top - this.camera.bottom) / maxHeight;
				const zoomForWidth = (this.camera.right - this.camera.left) / maxWidth;
				goal.zoom = Math.min(zoomForHeight, zoomForWidth) / (1 + this.offset);
				if (Number.isNaN(goal.zoom)) goal.zoom = 0;
			}
			if (this.clip) {
				if (isPerspectiveCamera(this.camera)) {
					this.camera.near = Math.abs(distance) / 100;
					this.camera.far = Math.abs(distance) * 100;
					this.camera.updateProjectionMatrix();
				}
				if (this._controls) {
					this._controls.maxDistance = Math.abs(distance) * 100;
					this._controls.update();
				}
			}
		}
		this._t = 0;
		this._animationState = AnimationState.ACTIVE;
		this.onStart && this.onStart(this._goal);
	}
	animate(delta) {
		if (this._animationState === AnimationState.NONE) return false;
		if (this._animationState === AnimationState.ACTIVE) {
			this._t += delta / this.duration;
			this._t = MathUtils.clamp(this._t, 0, 1);
			if (this._t >= 1) {
				this._goal.position && this.camera.position.copy(this._goal.position);
				this._goal.quaternion && this.camera.quaternion.copy(this._goal.quaternion);
				this._goal.up && this.camera.up.copy(this._goal.up);
				this._goal.zoom && isOrthographicCamera(this.camera) && (this.camera.zoom = this._goal.zoom);
				this.camera.updateMatrixWorld();
				if (isPerspectiveCamera(this.camera)) this.camera.updateProjectionMatrix();
				if (this._controls && this._goal.lookAt) {
					this._controls.target.copy(this._goal.lookAt);
					this._controls.update();
				}
				this._animationState = AnimationState.NONE;
				this.onEnd && this.onEnd(this._goal);
				_resetGoal(this._goal);
			} else {
				const k = this.easing && this.easing(this._t);
				this._goal.position && this.camera.position.lerpVectors(this._start.position, this._goal.position, k);
				this._goal.quaternion && this.camera.quaternion.slerpQuaternions(this._start.quaternion, this._goal.quaternion, k);
				this._goal.up && this.camera.up.set(0, 1, 0).applyQuaternion(this.camera.quaternion);
				this._goal.zoom && isOrthographicCamera(this.camera) && (this.camera.zoom = (1 - k) * this._start.zoom + k * this._goal.zoom);
				this.camera.updateMatrixWorld();
				if (isPerspectiveCamera(this.camera)) this.camera.updateProjectionMatrix();
			}
		}
		return true;
	}
};
function _getSize(box3OrObject, camera, offset = 0) {
	const box = new Box3();
	if (isBox3(box3OrObject)) box.copy(box3OrObject);
	else {
		box3OrObject.updateWorldMatrix(true, true);
		box.setFromObject(box3OrObject);
	}
	if (box.isEmpty()) {
		const max = camera.position.length() || 10;
		box.setFromCenterAndSize(new Vector3(), new Vector3(max, max, max));
	}
	const boxSize = box.getSize(new Vector3());
	const center = box.getCenter(new Vector3());
	const maxSize = Math.max(boxSize.x, boxSize.y, boxSize.z);
	const fitHeightDistance = isOrthographicCamera(camera) ? maxSize * 4 : maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
	const fitWidthDistance = isOrthographicCamera(camera) ? maxSize * 4 : fitHeightDistance / camera.aspect;
	return {
		box,
		size: boxSize,
		center,
		distance: (1 + offset) * Math.max(fitHeightDistance, fitWidthDistance)
	};
}
function _resetGoal(goal) {
	goal.position = void 0;
	goal.quaternion = void 0;
	goal.zoom = void 0;
	goal.up = void 0;
	goal.lookAt = void 0;
	goal.box = void 0;
	goal.object = void 0;
}

//#endregion
//#region src/core/staging/Bounds/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$11 = [
	"object",
	"duration",
	"offset"
];
var component_vue_vue_type_script_setup_true_lang_default$2 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		duration: {
			type: Number,
			required: false,
			default: 1
		},
		offset: {
			type: Number,
			required: false,
			default: .2
		},
		useResize: {
			type: Boolean,
			required: false,
			default: false
		},
		useMounted: {
			type: Boolean,
			required: false,
			default: false
		},
		clip: {
			type: Boolean,
			required: false,
			default: false
		},
		easing: {
			type: Function,
			required: false
		}
	},
	emits: [
		"start",
		"cancel",
		"end"
	],
	setup(__props, { expose: __expose, emit: __emit }) {
		const props = __props;
		const emit = __emit;
		const { camera, controls, sizes: size, invalidate } = useTres();
		const defaultEasing = (t) => 1 - (1 - t) ** 3;
		const bounds = new Bounds(camera.value ?? new PerspectiveCamera());
		bounds.easing = props.easing ?? defaultEasing;
		bounds.onStart = (arg) => emit("start", arg);
		bounds.onCancel = (arg) => emit("cancel", arg);
		bounds.onEnd = (arg) => emit("end", arg);
		const refresh = () => {
			bounds.offset = props.offset;
			bounds.duration = props.duration;
			bounds.clip = props.clip;
			bounds.lookAt();
			invalidate();
		};
		useLoop().onBeforeRender(({ delta }) => {
			if (bounds.animate(delta)) invalidate();
		});
		watchEffect(() => {
			if (controls.value) bounds.controls = controls.value;
		});
		watch(computed(() => camera.value?.uuid), () => {
			if (camera.value) bounds.camera = camera.value;
		}, {
			immediate: true,
			deep: false
		});
		const refreshDebounce = useDebounceFn(refresh, 250, { maxWait: 2e3 });
		watch(() => [size.width.value, size.height.value], () => {
			if (props.useResize) refreshDebounce();
		});
		watch(() => [props.easing], () => {
			bounds.easing = props.easing ?? defaultEasing;
		}, { immediate: true });
		onMounted(() => {
			if (props.useMounted) refreshDebounce();
		});
		onUnmounted(() => bounds.dispose());
		__expose({ instance: bounds });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", {
				object: unref(bounds),
				duration: __props.duration,
				offset: __props.offset
			}, [renderSlot(_ctx.$slots, "default")], 8, _hoisted_1$11);
		};
	}
});

//#endregion
//#region src/core/staging/Bounds/component.vue
var component_default$2 = component_vue_vue_type_script_setup_true_lang_default$2;

//#endregion
//#region src/core/staging/ContactShadows.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$10 = ["object"];
var ContactShadows_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "ContactShadows",
	props: {
		opacity: {
			type: Number,
			required: false,
			default: 1
		},
		blur: {
			type: Number,
			required: false,
			default: 1
		},
		color: {
			type: null,
			required: false,
			default: "#000000"
		},
		tint: {
			type: null,
			required: false,
			default: void 0
		},
		scale: {
			type: [Number, Array],
			required: false,
			default: 10
		},
		width: {
			type: Number,
			required: false,
			default: 1
		},
		height: {
			type: Number,
			required: false,
			default: 1
		},
		far: {
			type: Number,
			required: false,
			default: 10
		},
		smooth: {
			type: Boolean,
			required: false,
			default: true
		},
		resolution: {
			type: Number,
			required: false,
			default: 512
		},
		frames: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		depthWrite: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		function blurShadow(blur, renderer, pool$1) {
			pool$1.blurPlane.visible = true;
			pool$1.blurPlane.material = pool$1.horizontalBlurMaterial;
			pool$1.horizontalBlurMaterial.uniforms.tDiffuse.value = pool$1.renderTarget.texture;
			pool$1.horizontalBlurMaterial.uniforms.h.value = blur / 256;
			renderer.setRenderTarget(pool$1.renderTargetBlur);
			renderer.render(pool$1.blurPlane, pool$1.shadowCamera);
			pool$1.blurPlane.material = pool$1.verticalBlurMaterial;
			pool$1.verticalBlurMaterial.uniforms.tDiffuse.value = pool$1.renderTargetBlur.texture;
			pool$1.verticalBlurMaterial.uniforms.v.value = blur / 256;
			renderer.setRenderTarget(pool$1.renderTarget);
			renderer.render(pool$1.blurPlane, pool$1.shadowCamera);
			pool$1.blurPlane.visible = false;
		}
		function update(ps, scene, renderer, pool$1) {
			const { renderTarget, shadowCamera, depthMaterial } = pool$1;
			const initialBackground = scene.background;
			scene.background = null;
			scene.overrideMaterial = depthMaterial;
			const initialClearAlpha = renderer.getClearAlpha();
			renderer.setClearAlpha(0);
			renderer.setRenderTarget(renderTarget);
			renderer.render(scene, shadowCamera);
			scene.overrideMaterial = null;
			blurShadow(ps.blur, renderer, pool$1);
			if (ps.smooth) blurShadow(ps.blur * .4, renderer, pool$1);
			renderer.setRenderTarget(null);
			renderer.setClearAlpha(initialClearAlpha);
			scene.background = initialBackground;
		}
		function init(p) {
			const shadowGroup = new Group();
			const renderTarget = new WebGLRenderTarget(p.resolution, p.resolution);
			renderTarget.texture.generateMipmaps = false;
			const renderTargetBlur = new WebGLRenderTarget(p.resolution, p.resolution);
			renderTargetBlur.texture.generateMipmaps = false;
			const planeGeometry = new PlaneGeometry(p.width, p.height).rotateX(Math.PI / 2);
			const plane = new Mesh(planeGeometry, new MeshBasicMaterial({
				map: renderTarget.texture,
				opacity: p.opacity,
				transparent: true,
				depthWrite: p.depthWrite,
				color: new Color(p.color ?? "black")
			}));
			shadowGroup.add(plane);
			plane.scale.y = -1;
			const blurPlane = new Mesh(planeGeometry);
			blurPlane.visible = false;
			shadowGroup.add(blurPlane);
			const shadowCamera = new OrthographicCamera(-p.width / 2, p.width / 2, p.height / 2, -p.height / 2, 0, .3);
			shadowCamera.rotation.x = Math.PI / 2;
			shadowGroup.add(shadowCamera);
			const depthMaterial = new MeshDepthMaterial();
			const horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);
			horizontalBlurMaterial.depthTest = false;
			const verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);
			verticalBlurMaterial.depthTest = false;
			return {
				renderTarget,
				renderTargetBlur,
				shadowCamera,
				depthMaterial,
				horizontalBlurMaterial,
				verticalBlurMaterial,
				shadowGroup,
				plane,
				blurPlane
			};
		}
		function setSize(ps, pool$1) {
			const shadowCamera = pool$1.shadowCamera;
			shadowCamera.left = -ps.width / 2;
			shadowCamera.right = ps.width / 2;
			shadowCamera.top = ps.height / 2;
			shadowCamera.bottom = -ps.height / 2;
			shadowCamera.far = ps.far;
			const w = ps.width * (Array.isArray(ps.scale) ? ps.scale[0] : ps.scale || 1);
			const h = ps.height * (Array.isArray(ps.scale) ? ps.scale[1] : ps.scale || 1);
			pool$1.shadowGroup.scale.set(w, ps.far, h);
		}
		function setResolution(resolution, pool$1) {
			pool$1.renderTarget.dispose();
			pool$1.renderTargetBlur.dispose();
			pool$1.renderTarget = new WebGLRenderTarget(resolution, resolution);
			pool$1.renderTarget.texture.generateMipmaps = false;
			pool$1.renderTargetBlur = new WebGLRenderTarget(resolution, resolution);
			pool$1.renderTargetBlur.texture.generateMipmaps = false;
			pool$1.plane.material.map = pool$1.renderTarget.texture;
		}
		function setColors(ps, pool$1) {
			pool$1.plane.material.color = new Color(ps.color ?? "black");
			pool$1.depthMaterial.dispose();
			pool$1.depthMaterial = new MeshDepthMaterial();
			pool$1.depthMaterial.onBeforeCompile = function(shader) {
				const { r, g, b } = ps.tint ? new Color(ps.tint) : new Color("white");
				shader.fragmentShader = shader.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", `gl_FragColor = vec4( ${r}, ${g}, ${b}, ( 1.0 - fragCoordZ ) * opacity);`);
			};
		}
		const { onBeforeRender } = useLoop();
		const pool = init(props);
		let count = 0;
		const updateOnNextRender = () => count = count >= props.frames ? props.frames - 1 : count;
		onBeforeRender(({ renderer, scene }) => {
			if (count < props.frames) {
				count++;
				update(props, toValue(scene), renderer, pool);
			}
		});
		watch(() => [
			props.opacity,
			props.depthWrite,
			props.blur,
			props.smooth
		], () => {
			pool.plane.material.opacity = props.opacity ?? 1;
			pool.plane.material.depthWrite = props.depthWrite ?? false;
			updateOnNextRender();
		}, { immediate: true });
		watch(() => [props.color, props.tint], () => {
			setColors(props, pool);
			updateOnNextRender();
		}, { immediate: true });
		watch(() => [props.resolution], () => {
			setResolution(props.resolution, pool);
			updateOnNextRender();
		});
		watch(() => [
			props.width,
			props.height,
			props.scale,
			props.far
		], () => {
			setSize(props, pool);
			updateOnNextRender();
		}, { immediate: true });
		onUnmounted(() => {
			for (const obj of Object.values(pool)) if (obj && "dispose" in obj && typeof obj.dispose === "function") obj.dispose();
		});
		__expose({ instance: pool.shadowGroup });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", { object: unref(pool).shadowGroup }, null, 8, _hoisted_1$10);
		};
	}
});

//#endregion
//#region src/core/staging/ContactShadows.vue
var ContactShadows_default = ContactShadows_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Fit.vue?vue&type=script&setup=true&lang.ts
var Fit_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Fit",
	props: {
		into: {
			type: [
				Number,
				Array,
				Object,
				null
			],
			required: false,
			default: () => new Box3(new Vector3(-.5, -.5, -.5), new Vector3(.5, .5, .5))
		},
		precise: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		const middle = shallowRef(new Group());
		const inner = shallowRef(new Group());
		function fit(container, precise) {
			middle.value.position.set(0, 0, 0);
			middle.value.updateMatrixWorld();
			inner.value.scale.set(1, 1, 1);
			inner.value.updateMatrixWorld();
			if (!inner.value.children.length || container === null) return;
			const { box3: containerBox, use } = normalizeContainer(container, precise);
			const childBox = new Box3();
			inner.value.children.forEach((c) => childBox.expandByObject(c, precise));
			const childBoxSize = childBox.getSize(new Vector3());
			const containerBoxSize = containerBox.getSize(new Vector3());
			const scale = Math.min(containerBoxSize.x / childBoxSize.x, containerBoxSize.y / childBoxSize.y, containerBoxSize.z / childBoxSize.z);
			inner.value.scale.setScalar(scale === Number.POSITIVE_INFINITY ? 1 : scale);
			inner.value.updateMatrixWorld();
			const childBoxCenter = middle.value.worldToLocal(childBox.getCenter(new Vector3()));
			if (use.position) {
				const containerBoxCenter = middle.value.worldToLocal(containerBox.getCenter(new Vector3()));
				middle.value.position.copy(containerBoxCenter.sub(childBoxCenter.multiplyScalar(scale)));
			} else middle.value.position.copy(childBoxCenter.sub(childBoxCenter.multiplyScalar(scale)));
			invalidate();
		}
		function normalizeContainer(container, precise) {
			if (typeof container === "number") container = new Vector3(container, container, container);
			else if (Array.isArray(container)) container = new Vector3(...container);
			if (container && "isVector3" in container && container.isVector3) return {
				box3: new Box3(new Vector3(0, 0, 0), container),
				use: { position: false }
			};
			else if (container && "isBox3" in container && container.isBox3) return {
				box3: container,
				use: { position: true }
			};
			else if (container && "isObject3D" in container && container.isObject3D) return {
				box3: new Box3().setFromObject(container, precise ?? false),
				use: { position: true }
			};
			return {
				box3: new Box3(new Vector3(-.5, -.5, -.5), new Vector3(.5, .5, .5)),
				use: { position: true }
			};
		}
		watch(() => [props.into, props.precise], () => fit(props.into, props.precise));
		onMounted(() => {
			fit(props.into, props.precise);
			nextTick().then(() => {
				fit(props.into, props.precise);
			});
		});
		const outer = shallowRef();
		__expose({
			instance: outer,
			fit: (into = new Box3(new Vector3(-.5, -.5, -.5), new Vector3(.5, .5, .5)), precise = false) => {
				fit(into, precise);
			},
			update: () => fit(props.into, props.precise)
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "outer",
				ref: outer
			}, [createElementVNode("TresGroup", {
				ref_key: "middle",
				ref: middle
			}, [createElementVNode("TresGroup", {
				ref_key: "inner",
				ref: inner
			}, [renderSlot(_ctx.$slots, "default")], 512)], 512)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Fit.vue
var Fit_default = Fit_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Grid.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$9 = [
	"side",
	"cell-size",
	"section-size",
	"cell-color",
	"section-color",
	"cell-thickness",
	"section-thickness",
	"fade-distance",
	"fade-strength",
	"fade-from",
	"infinite-grid",
	"follow-camera"
];
const _hoisted_2$6 = ["args"];
var Grid_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Grid",
	props: {
		cellSize: {
			type: Number,
			required: false,
			default: .5
		},
		cellThickness: {
			type: Number,
			required: false,
			default: .5
		},
		cellColor: {
			type: [
				Object,
				String,
				Number
			],
			required: false,
			default: "#000000"
		},
		sectionSize: {
			type: Number,
			required: false,
			default: 1
		},
		sectionThickness: {
			type: Number,
			required: false,
			default: 1
		},
		sectionColor: {
			type: [
				Object,
				String,
				Number
			],
			required: false,
			default: "#0000ff"
		},
		followCamera: {
			type: Boolean,
			required: false,
			default: false
		},
		infiniteGrid: {
			type: Boolean,
			required: false,
			default: false
		},
		fadeDistance: {
			type: Number,
			required: false,
			default: 100
		},
		fadeStrength: {
			type: Number,
			required: false,
			default: 1
		},
		fadeFrom: {
			type: Number,
			required: false,
			default: 1
		},
		side: {
			type: null,
			required: false,
			default: BackSide
		},
		args: {
			type: Array,
			required: false
		}
	},
	setup(__props) {
		const props = __props;
		extend({ GridMaterial: shaderMaterial({
			cellSize: .5,
			sectionSize: 1,
			fadeDistance: 100,
			fadeStrength: 1,
			fadeFrom: 1,
			cellThickness: .5,
			sectionThickness: 1,
			cellColor: new Color(),
			sectionColor: new Color(),
			infiniteGrid: false,
			followCamera: false,
			worldCamProjPosition: new Vector3(),
			worldPlanePosition: new Vector3()
		}, `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `, `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <colorspace_fragment>
    }
  `) });
		const ref$1 = shallowRef(new Mesh());
		const plane = new Plane();
		const upVector = new Vector3(0, 1, 0);
		const zeroVector = new Vector3(0, 0, 0);
		const { onBeforeRender } = useLoop();
		onBeforeRender((state) => {
			if (!state.camera) return;
			plane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(ref$1.value.matrixWorld);
			const gridMaterial = ref$1.value.material;
			const worldCamProjPosition = gridMaterial.uniforms.worldCamProjPosition;
			const worldPlanePosition = gridMaterial.uniforms.worldPlanePosition;
			plane.projectPoint(state.camera.value.position, worldCamProjPosition.value);
			worldPlanePosition.value.set(0, 0, 0).applyMatrix4(ref$1.value.matrixWorld);
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "ref",
				ref: ref$1,
				"frustum-culled": false
			}, [createElementVNode("TresGridMaterial", {
				transparent: true,
				"extensions-derivatives": true,
				side: props.side,
				"cell-size": props.cellSize,
				"section-size": props.sectionSize,
				"cell-color": props.cellColor,
				"section-color": props.sectionColor,
				"cell-thickness": props.cellThickness,
				"section-thickness": props.sectionThickness,
				"fade-distance": props.fadeDistance,
				"fade-strength": props.fadeStrength,
				"fade-from": props.fadeFrom,
				"infinite-grid": props.infiniteGrid,
				"follow-camera": props.followCamera
			}, null, 8, _hoisted_1$9), createElementVNode("TresPlaneGeometry", { args: props.args }, null, 8, _hoisted_2$6)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Grid.vue
var Grid_default = Grid_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Ocean.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$8 = ["rotation-x", "args"];
var Ocean_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Ocean",
	props: {
		textureWidth: {
			type: Number,
			required: false,
			default: 512
		},
		textureHeight: {
			type: Number,
			required: false,
			default: 512
		},
		waterNormals: {
			type: String,
			required: false,
			default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg"
		},
		sunDirection: {
			type: null,
			required: false,
			default: () => new Vector3()
		},
		sunColor: {
			type: null,
			required: false,
			default: 16777215
		},
		waterColor: {
			type: null,
			required: false,
			default: 7695
		},
		distortionScale: {
			type: Number,
			required: false,
			default: 3.7
		},
		size: {
			type: Number,
			required: false,
			default: 1
		},
		clipBias: {
			type: Number,
			required: false,
			default: 0
		},
		alpha: {
			type: Number,
			required: false,
			default: 1
		},
		side: {
			type: null,
			required: false,
			default: FrontSide
		}
	},
	setup(__props, { expose: __expose }) {
		const { textureWidth, textureHeight, waterNormals, sunDirection, sunColor, waterColor, distortionScale, size, clipBias, alpha, side } = toRefs(__props);
		const { extend: extend$1, scene } = useTresContext();
		extend$1({ Water });
		const waterRef = shallowRef();
		const sunRef = shallowRef();
		const _fog = scene.value.fog !== void 0;
		__expose({ instance: waterRef });
		scene.value.traverse((child) => {
			if (Object.prototype.hasOwnProperty.call(child, "isSky")) sunRef.value = child;
		});
		onMounted(async () => {
			await nextTick();
			if (sunRef.value) {
				const sunPosition = sunRef.value.material.uniforms.sunPosition.value;
				waterRef.value.material.uniforms.sunDirection.value.copy(sunPosition);
			}
		});
		const normalMap = new TextureLoader().load(waterNormals.value);
		normalMap.wrapS = normalMap.wrapT = RepeatWrapping;
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ delta }) => {
			if (waterRef.value) waterRef.value.material.uniforms.time.value += delta;
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresWater", {
				ref_key: "waterRef",
				ref: waterRef,
				"rotation-x": -Math.PI / 2,
				args: [void 0, {
					textureWidth: unref(textureWidth),
					textureHeight: unref(textureHeight),
					waterNormals: unref(normalMap),
					sunDirection: unref(sunDirection),
					sunColor: unref(sunColor),
					waterColor: unref(waterColor),
					distortionScale: unref(distortionScale),
					fog: _fog,
					size: unref(size),
					clipBias: unref(clipBias),
					alpha: unref(alpha),
					side: unref(side)
				}]
			}, [renderSlot(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createElementVNode("TresPlaneGeometry", { args: [1e4, 1e4] }, null, -1))])], 8, _hoisted_1$8);
		};
	}
});

//#endregion
//#region src/core/staging/Ocean.vue
var Ocean_default = Ocean_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Precipitation.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$7 = [
	"size",
	"color",
	"alpha-map",
	"map",
	"opacity",
	"alpha-test",
	"depth-write",
	"transparent",
	"size-attenuation"
];
const _hoisted_2$5 = ["position", "velocity"];
var Precipitation_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Precipitation",
	props: {
		size: {
			type: Number,
			required: false,
			default: .1
		},
		area: {
			type: Array,
			required: false,
			default: () => [
				10,
				10,
				20
			]
		},
		color: {
			type: null,
			required: false,
			default: 16777215
		},
		map: {
			type: [
				String,
				Object,
				null
			],
			required: false
		},
		alphaMap: {
			type: [
				String,
				Object,
				null
			],
			required: false
		},
		alphaTest: {
			type: Number,
			required: false,
			default: .01
		},
		opacity: {
			type: Number,
			required: false,
			default: .8
		},
		count: {
			type: Number,
			required: false,
			default: 5e3
		},
		speed: {
			type: Number,
			required: false,
			default: .1
		},
		randomness: {
			type: Number,
			required: false,
			default: .5
		},
		depthWrite: {
			type: Boolean,
			required: false,
			default: false
		},
		transparent: {
			type: Boolean,
			required: false,
			default: true
		},
		sizeAttenuation: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	setup(__props, { expose: __expose }) {
		const { size, area, color, alphaMap: alphaMapUrl, map: mapUrl, opacity, alphaTest, depthWrite, transparent, sizeAttenuation, count, speed, randomness } = toRefs(__props);
		const geometryRef = shallowRef();
		let positionArray = [];
		let velocityArray = [];
		const setPosition = () => {
			positionArray = new Float32Array(count.value * 3);
			for (let i = 0; i < count.value; i++) {
				const i3 = i * 3;
				positionArray[i3] = (Math.random() - .5) * area.value[0];
				positionArray[i3 + 1] = (Math.random() - .5) * area.value[1];
				positionArray[i3 + 2] = (Math.random() - .5) * area.value[2];
			}
		};
		const setSpeed = () => {
			velocityArray = new Float32Array(count.value * 2);
			for (let i = 0; i < count.value * 2; i += 2) {
				velocityArray[i] = (Math.random() - .5) / 5 * speed.value * randomness.value;
				velocityArray[i + 1] = Math.random() / 5 * speed.value;
			}
		};
		setSpeed();
		setPosition();
		watch(speed, () => {
			setSpeed();
		});
		watchEffect(() => {
			if (speed.value) return;
			setPosition();
		});
		const alphaMapTexture = shallowRef(null);
		const mapTexture = shallowRef(null);
		watchEffect(async () => {
			if (typeof alphaMapUrl.value === "string") {
				const { state: alphaMap } = useTexture(alphaMapUrl.value);
				alphaMapTexture.value = alphaMap.value;
			} else alphaMapTexture.value = alphaMapUrl.value ?? null;
			if (typeof mapUrl.value === "string") {
				const { state: map } = useTexture(mapUrl.value);
				mapTexture.value = map.value;
			} else mapTexture.value = mapUrl.value ?? null;
		});
		const { onBeforeRender } = useLoop();
		onBeforeRender(() => {
			if (geometryRef.value?.attributes.position.array && geometryRef.value?.attributes.position.count) {
				const positionArray$1 = geometryRef.value.attributes.position.array;
				for (let i = 0; i < geometryRef.value.attributes.position.count; i++) {
					const velocityX = velocityArray[i * 2];
					const velocityY = velocityArray[i * 2 + 1];
					positionArray$1[i * 3] += velocityX;
					positionArray$1[i * 3 + 1] -= velocityY;
					if (positionArray$1[i * 3] <= -area.value[0] / 2 || positionArray$1[i * 3] >= area.value[0] / 2) positionArray$1[i * 3] = positionArray$1[i * 3] * -1;
					if (positionArray$1[i * 3 + 1] <= -area.value[1] / 2 || positionArray$1[i * 3 + 1] >= area.value[1] / 2) positionArray$1[i * 3 + 1] = positionArray$1[i * 3 + 1] * -1;
				}
				geometryRef.value.attributes.position.needsUpdate = true;
			}
		});
		const pointsRef = shallowRef();
		__expose({ instance: pointsRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresPoints", {
				ref_key: "pointsRef",
				ref: pointsRef
			}, [createElementVNode("TresPointsMaterial", {
				size: unref(size),
				color: unref(color),
				"alpha-map": alphaMapTexture.value,
				map: mapTexture.value,
				opacity: unref(opacity),
				"alpha-test": unref(alphaTest),
				"depth-write": unref(depthWrite),
				transparent: unref(transparent),
				"size-attenuation": unref(sizeAttenuation)
			}, null, 8, _hoisted_1$7), createElementVNode("TresBufferGeometry", {
				ref_key: "geometryRef",
				ref: geometryRef,
				position: [unref(positionArray), 3],
				velocity: [unref(velocityArray)]
			}, null, 8, _hoisted_2$5)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Precipitation.vue
var Precipitation_default = Precipitation_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/CircleShadow.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$6 = ["rotation-x"];
const _hoisted_2$4 = [
	"opacity",
	"fog",
	"depth-write",
	"side",
	"map"
];
const SIZE = 128;
var CircleShadow_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CircleShadow",
	props: {
		color: {
			type: [
				Object,
				Number,
				String
			],
			required: false,
			default: "black"
		},
		offset: {
			type: Number,
			required: false,
			default: 0
		},
		opacity: {
			type: Number,
			required: false,
			default: .5
		},
		fog: {
			type: Boolean,
			required: false,
			default: false
		},
		depthWrite: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const canvas = document.createElement("canvas");
		canvas.width = SIZE;
		canvas.height = SIZE;
		const context = canvas.getContext("2d");
		const texture$1 = new Texture(canvas);
		function createCanvas() {
			const gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
			gradient.addColorStop(props.offset, new Color(props.color).getStyle());
			gradient.addColorStop(1, "rgba(0,0,0,0)");
			context.clearRect(0, 0, SIZE, SIZE);
			context.fillStyle = gradient;
			context.fillRect(0, 0, canvas.width, canvas.height);
			texture$1.needsUpdate = true;
		}
		watchEffect(createCanvas);
		const shadowRef = shallowRef();
		__expose({ instance: shadowRef });
		onUnmounted(() => texture$1.dispose());
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "shadowRef",
				ref: shadowRef,
				"rotation-x": -Math.PI * .5
			}, [_cache[0] || (_cache[0] = createElementVNode("TresPlaneGeometry", null, null, -1)), createElementVNode("TresMeshBasicMaterial", {
				transparent: "",
				opacity: props.opacity,
				fog: props.fog,
				"depth-write": __props.depthWrite,
				side: unref(DoubleSide),
				map: unref(texture$1)
			}, null, 8, _hoisted_2$4)], 8, _hoisted_1$6);
		};
	}
});

//#endregion
//#region src/core/staging/CircleShadow.vue
var CircleShadow_default = CircleShadow_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Sky.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$5 = [
	"object",
	"material-uniforms-turbidity-value",
	"material-uniforms-rayleigh-value",
	"material-uniforms-mieCoefficient-value",
	"material-uniforms-mieDirectionalG-value",
	"material-uniforms-sunPosition-value",
	"scale"
];
var Sky_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Sky",
	props: {
		turbidity: {
			type: Number,
			required: false,
			default: 3.4
		},
		rayleigh: {
			type: Number,
			required: false,
			default: 3
		},
		mieCoefficient: {
			type: Number,
			required: false,
			default: .005
		},
		mieDirectionalG: {
			type: Number,
			required: false,
			default: .7
		},
		elevation: {
			type: Number,
			required: false,
			default: .6
		},
		azimuth: {
			type: Number,
			required: false,
			default: 180
		},
		distance: {
			type: Number,
			required: false,
			default: 45e4
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const { invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const skyImpl = new Sky();
		const sunPosition = computed(() => getSunPosition(props.azimuth, props.elevation));
		function getSunPosition(azimuth, elevation) {
			const phi = MathUtils.degToRad(90 - elevation);
			const theta = MathUtils.degToRad(azimuth);
			return new Vector3().setFromSphericalCoords(1, phi, theta);
		}
		__expose({
			instance: skyImpl,
			sunPosition: sunPosition.value
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", {
				object: unref(skyImpl),
				"material-uniforms-turbidity-value": props.turbidity,
				"material-uniforms-rayleigh-value": props.rayleigh,
				"material-uniforms-mieCoefficient-value": props.mieCoefficient,
				"material-uniforms-mieDirectionalG-value": props.mieDirectionalG,
				"material-uniforms-sunPosition-value": sunPosition.value,
				scale: props.distance
			}, null, 8, _hoisted_1$5);
		};
	}
});

//#endregion
//#region src/core/staging/Sky.vue
var Sky_default = Sky_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Smoke.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$4 = ["position"];
const _hoisted_2$3 = ["position"];
const _hoisted_3$2 = ["scale"];
const _hoisted_4$2 = [
	"map",
	"depth-test",
	"color-space",
	"color",
	"opacity"
];
var Smoke_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Smoke",
	props: {
		color: {
			type: null,
			required: false,
			default: "#ffffff"
		},
		opacity: {
			type: Number,
			required: false,
			default: .5
		},
		speed: {
			type: Number,
			required: false,
			default: .4
		},
		width: {
			type: Number,
			required: false,
			default: 10
		},
		depth: {
			type: Number,
			required: false,
			default: 1.5
		},
		segments: {
			type: Number,
			required: false,
			default: 20
		},
		texture: {
			type: String,
			required: false,
			default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png"
		},
		depthTest: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	setup(__props, { expose: __expose }) {
		const { width, depth, segments, texture: texture$1, color, depthTest, opacity, speed } = toRefs(__props);
		const smokeRef = shallowRef();
		const groupRef = shallowRef();
		__expose({ instance: smokeRef });
		const smoke = [...[segments]].map((_, index) => ({
			x: width.value / 2 - Math.random() * width.value,
			y: width.value / 2 - Math.random() * width.value,
			scale: .4 + Math.sin((index + 1) / segments.value * Math.PI) * ((.2 + Math.random()) * 10),
			density: Math.max(.2, Math.random()),
			rotation: Math.max(.002, .005 * Math.random()) * speed.value
		}));
		const calculateOpacity = (scale, density) => scale / 6 * density * opacity.value;
		const { state: map } = useTexture(texture$1.value);
		const { renderer, camera } = useTresContext();
		const colorSpace = computed(() => renderer.instance?.outputColorSpace);
		const { onBeforeRender } = useLoop();
		onBeforeRender(() => {
			if (smokeRef.value && camera.activeCamera.value && groupRef.value) {
				groupRef.value?.children.forEach((child, index) => {
					child.rotation.z += smoke[index].rotation;
				});
				smokeRef.value.lookAt(camera.activeCamera.value?.position);
			}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "smokeRef",
				ref: smokeRef
			}, [createElementVNode("TresGroup", {
				ref_key: "groupRef",
				ref: groupRef,
				position: [
					0,
					0,
					unref(segments) / 2 * unref(depth)
				]
			}, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(smoke), ({ scale, x, y, density }, index) => {
				return openBlock(), createElementBlock("TresMesh", {
					key: `${index}`,
					position: [
						x,
						y,
						-index * unref(depth)
					]
				}, [createElementVNode("TresPlaneGeometry", {
					scale: [
						scale,
						scale,
						scale
					],
					rotation: [
						0,
						0,
						0
					]
				}, null, 8, _hoisted_3$2), createElementVNode("TresMeshStandardMaterial", {
					map: unref(map),
					"depth-test": unref(depthTest),
					"color-space": colorSpace.value,
					color: unref(color),
					"depth-write": false,
					transparent: "",
					opacity: calculateOpacity(scale, density)
				}, null, 8, _hoisted_4$2)], 8, _hoisted_2$3);
			}), 128))], 8, _hoisted_1$4)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Smoke.vue
var Smoke_default = Smoke_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/CameraShake.vue?vue&type=script&setup=true&lang.ts
var CameraShake_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "CameraShake",
	props: {
		intensity: {
			type: Number,
			required: false,
			default: 1
		},
		decay: {
			type: Boolean,
			required: false,
			default: false
		},
		decayRate: {
			type: Number,
			required: false,
			default: .65
		},
		maxYaw: {
			type: Number,
			required: false,
			default: .01
		},
		maxPitch: {
			type: Number,
			required: false,
			default: .01
		},
		maxRoll: {
			type: Number,
			required: false,
			default: .01
		},
		yawFrequency: {
			type: Number,
			required: false,
			default: .1
		},
		pitchFrequency: {
			type: Number,
			required: false,
			default: .1
		},
		rollFrequency: {
			type: Number,
			required: false,
			default: .1
		}
	},
	setup(__props) {
		const props = __props;
		const { intensity, decay, decayRate, maxYaw, maxPitch, maxRoll, yawFrequency, pitchFrequency, rollFrequency } = toRefs(props);
		const { camera, controls } = useTresContext();
		let cleanUpFn = null;
		const currentIntensity = shallowRef(props.intensity);
		const initialRotation = shallowRef(camera.activeCamera.value?.rotation.clone());
		const yawNoise = new SimplexNoise();
		const pitchNoise = new SimplexNoise();
		const rollNoise = new SimplexNoise();
		function constrainIntensity() {
			if (currentIntensity.value < 0) currentIntensity.value = 0;
			if (currentIntensity.value > 1) currentIntensity.value = 1;
		}
		watch(intensity, (newVal) => {
			currentIntensity.value = newVal;
			constrainIntensity();
		});
		function updateInitialRotation() {
			if (camera.activeCamera.value) initialRotation.value = camera.activeCamera.value.rotation.clone();
		}
		watch([camera.activeCamera, controls], () => {
			cleanUpFn?.();
			if (controls.value) cleanUpFn = useEventListener(controls.value, "change", updateInitialRotation);
			updateInitialRotation();
		});
		function setIntensity(v) {
			currentIntensity.value = Math.min(1, Math.max(0, v));
		}
		const { onBeforeRender } = useLoop();
		onBeforeRender(({ elapsed, delta }) => {
			const cam = camera.activeCamera.value;
			if (!cam) return;
			if (!decay.value && currentIntensity.value < intensity.value) setIntensity(currentIntensity.value + decayRate.value * delta);
			const shakeFactor = currentIntensity.value * currentIntensity.value;
			const yaw = maxYaw.value * shakeFactor * yawNoise.noise(elapsed * yawFrequency.value, 1);
			const pitch = maxPitch.value * shakeFactor * pitchNoise.noise(elapsed * pitchFrequency.value, 1);
			const roll = maxRoll.value * shakeFactor * rollNoise.noise(elapsed * rollFrequency.value, 1);
			cam.rotation.set(initialRotation.value.x + pitch, initialRotation.value.y + yaw, initialRotation.value.z + roll);
			if (decay.value) setIntensity(currentIntensity.value - decayRate.value * delta);
		});
		onUnmounted(() => {
			cleanUpFn?.();
		});
		return (_ctx, _cache) => {
			return renderSlot(_ctx.$slots, "default");
		};
	}
});

//#endregion
//#region src/core/staging/CameraShake.vue
var CameraShake_default = CameraShake_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/SoftShadows.vue?vue&type=script&setup=true&lang.ts
const PCSSGetShadow = `
return PCSS( shadowMap, shadowCoord );
`;
var SoftShadows_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "SoftShadows",
	props: {
		size: {
			type: Number,
			required: false,
			default: 25
		},
		samples: {
			type: Number,
			required: false,
			default: 10
		},
		focus: {
			type: Number,
			required: false,
			default: 0
		}
	},
	setup(__props) {
		const props = __props;
		const getPcss = ({ focus = 0, size = 25, samples = 10 } = {}) => `
#define PENUMBRA_FILTER_SIZE float(${size})
#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
vec3 randRGB(vec2 uv) {
  return vec3(
    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
  );
}

vec3 lowPassRandRGB(vec2 uv) {
  // 3x3 convolution (average)
  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
  vec3 result = vec3(0);
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
  result *= 0.111111111; // 1.0 / 9.0
  return result;
}
vec3 highPassRandRGB(vec2 uv) {
  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
  // hp(x) = x - lp(x)
  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
}


vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}
float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
  return (zReceiver - zBlocker) / zBlocker;
}
float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float blockerDepthSum = float(${focus});
  float blockers = 0.0;

  int j = 0;
  vec2 offset = vec2(0.);
  float depth = 0.;

  #pragma unroll_loop_start
  for(int i = 0; i < ${samples}; i ++) {
    offset = (vogelDiskSample(j, ${samples}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
    if (depth < compare) {
      blockerDepthSum += depth;
      blockers++;
    }
    j++;
  }
  #pragma unroll_loop_end

  if (blockers > 0.0) {
    return blockerDepthSum / blockers;
  }
  return -1.0;
}

        
float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float shadow = 0.0f;
  int j = 0;
  vec2 vogelSample = vec2(0.0);
  vec2 offset = vec2(0.0);
  #pragma unroll_loop_start
  for (int i = 0; i < ${samples}; i++) {
    vogelSample = vogelDiskSample(j, ${samples}, angle) * texelSize;
    offset = vogelSample * (1.0 + filterRadius * float(${size}));
    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    j++;
  }
  #pragma unroll_loop_end
  return shadow * 1.0 / ${samples}.0;
}

float PCSS (sampler2D shadowMap, vec4 coords) {
  vec2 uv = coords.xy;
  float zReceiver = coords.z; // Assumed to be eye-space z in this code
  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
  if (avgBlockerDepth == -1.0) {
    return 1.0;
  }
  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
}`;
		const originalShadowsFragment = ShaderChunk.shadowmap_pars_fragment;
		const { renderer, scene, camera } = useTres();
		function injectSoftShadowsFragment(renderer$1, props$1) {
			let shader = originalShadowsFragment;
			shader = shader.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
    ${getPcss(props$1)}`);
			shader = shader.replace("#if defined( SHADOWMAP_TYPE_PCF )", `${PCSSGetShadow} 
    #if defined( SHADOWMAP_TYPE_PCF )`);
			ShaderChunk.shadowmap_pars_fragment = shader;
			renderer$1.shadowMap.enabled = true;
		}
		function reset(renderer$1, scene$1, camera$1) {
			if (renderer$1 instanceof WebGLRenderer) {
				scene$1.traverse((object) => {
					if ("material" in object && object.material) {
						renderer$1.properties.remove(object.material);
						if (typeof object.material === "object" && "dispose" in object.material && typeof object.material.dispose === "function") object.material.dispose?.();
					}
				});
				if (renderer$1.info.programs) renderer$1.info.programs.length = 0;
			}
			renderer$1.compile(scene$1, camera$1);
		}
		onUnmounted(() => {
			if (camera.value) {
				ShaderChunk.shadowmap_pars_fragment = originalShadowsFragment;
				reset(renderer, scene.value, camera.value);
			}
		});
		watch(props, () => {
			if (camera.value) {
				injectSoftShadowsFragment(renderer, props);
				reset(renderer, scene.value, camera.value);
			}
		}, { immediate: true });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup");
		};
	}
});

//#endregion
//#region src/core/staging/SoftShadows.vue
var SoftShadows_default = SoftShadows_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/utils/Gradient.ts
function normalizeColorGradient(gradient) {
	return normalizeGradient(gradient, {
		normalizeValue: (input) => normalizeColor(input),
		getDefaultValue: () => new Color(0, 0, 0),
		isSingleValue: (t) => !Array.isArray(t),
		isMultipleValues: (t) => Array.isArray(t) && (t.length === 0 || !Array.isArray(t[0])),
		isMultipleValuesWithStops: (t) => Array.isArray(t) && t.length > 0 && Array.isArray(t[0]),
		isEmpty: (t) => Array.isArray(t) && t.length === 0
	});
}
function isVectorFlexibleParams(p) {
	return "isVector3" in p || Array.isArray(p) && p.length > 0 && p.every((v) => typeof v === "number");
}
function normalizeFlexibleVector3Gradient(gradient) {
	return normalizeGradient(gradient, {
		normalizeValue: (input) => normalizeVectorFlexibleParam(input),
		getDefaultValue: () => [
			0,
			0,
			0
		],
		isSingleValue: (t) => isVectorFlexibleParams(t),
		isMultipleValues: (t) => Array.isArray(t) && t.length > 0 && isVectorFlexibleParams(t[0]),
		isMultipleValuesWithStops: (t) => Array.isArray(t) && t.length > 0 && Array.isArray(t[0]) && t[0].length === 2 && isVectorFlexibleParams(t[0][1]),
		isEmpty: (t) => Array.isArray(t) && t.length === 0
	});
}
function normalizeScalarGradient(gradient) {
	return normalizeGradient(gradient, {
		normalizeValue: (input) => input,
		getDefaultValue: () => 1,
		isSingleValue: (t) => !Array.isArray(t) && typeof t !== "undefined",
		isMultipleValues: (t) => Array.isArray(t) && (t.length === 0 || !Array.isArray(t[0])),
		isMultipleValuesWithStops: (t) => Array.isArray(t) && t.length > 0 && Array.isArray(t[0]),
		isEmpty: (t) => Array.isArray(t) && t.length === 0
	});
}
function normalizeGradient(gradient, config) {
	const { normalizeValue, getDefaultValue, isEmpty } = config;
	const isSingleValue = (t) => config.isSingleValue(t);
	const isMultipleValues = (t) => config.isMultipleValues(t);
	const isMultipleValuesWithStops = (t) => config.isMultipleValuesWithStops(t);
	if (isEmpty(gradient)) return [[0, getDefaultValue()]];
	else if (isSingleValue(gradient)) return [[0, normalizeValue(gradient)]];
	else if (isMultipleValues(gradient)) {
		const step = gradient.length > 1 ? 1 / (gradient.length - 1) : 1;
		return gradient.map((input, i) => [step * i, normalizeValue(input)]);
	} else if (isMultipleValuesWithStops(gradient)) return gradient.map(([u, v], _) => [u, normalizeValue(v)]);
	return [[0, getDefaultValue()]];
}

//#endregion
//#region src/core/staging/Sparkles/ShaderData.ts
var ShaderData = class {
	entries;
	resolution;
	constructor(entries, resolution) {
		this.entries = entries;
		this.resolution = resolution;
	}
	useTexture() {
		return new ShaderDataTexture(this.entries, this.resolution).use();
	}
};
var ShaderDataEntry = class {
	data;
	ref;
	name;
	valueMin;
	valueMax;
	suffix;
	renderToCanvasGradient;
	constructor(data, name, valueMin, valueMax, suffix, renderToCanvasGradient) {
		this.data = isRef(data) ? data.value : data;
		this.ref = isRef(data) ? data : null;
		this.name = name;
		this.valueMin = valueMin;
		this.valueMax = valueMax;
		this.suffix = suffix;
		this.renderToCanvasGradient = renderToCanvasGradient;
	}
};
var ShaderDataEntryTresColorGradient = class extends ShaderDataEntry {
	constructor(data, name = "color", valueMin = 0, valueMax = 1, suffix = "rgba", renderToCanvasGradient = GradientTresColorRenderToCanvasGradient) {
		super(data, name, valueMin, valueMax, suffix, renderToCanvasGradient);
	}
};
var ShaderDataEntryScalarGradient = class extends ShaderDataEntry {
	constructor(data, name = "scalar", valueMin = 0, valueMax = 1, suffix = "x", renderToCanvasGradient = GradientScalarRenderToCanvasGradient) {
		super(data, name, valueMin, valueMax, suffix, renderToCanvasGradient);
	}
};
var ShaderDataEntryXyzGradient = class extends ShaderDataEntry {
	constructor(data, name = "scalar3", valueMin = 0, valueMax = 1, suffix = "xyz", renderToCanvasGradient = GradientXyzRenderToCanvasGradient) {
		super(data, name, valueMin, valueMax, suffix, renderToCanvasGradient);
	}
};
var ShaderDataTexture = class {
	entries;
	size;
	dirty = shallowRef(0);
	context;
	constructor(entries, resolution) {
		this.entries = entries;
		this.size = Math.max(resolution, entries.length);
		const canvas = document.createElement("canvas");
		canvas.height = this.size;
		canvas.width = this.size;
		this.context = canvas.getContext("2d");
	}
	use() {
		const texture$1 = this.build();
		const textureRef = shallowRef(texture$1);
		for (const entry of this.entries) if (entry.ref) watch(entry.ref, () => {
			entry.data = entry.ref?.value;
			triggerRef(this.dirty);
		});
		watchThrottled(this.dirty, () => {
			this.build(texture$1);
			textureRef.value = texture$1;
		}, { throttle: 1e3 / 60 });
		return {
			texture: textureRef,
			dispose: () => texture$1.dispose(),
			yFor: this.entries.reduce((obj, entry, i) => {
				obj[entry.name] = (i + .5) / this.size;
				return obj;
			}, {})
		};
	}
	build(recycledTexture) {
		this.entries.forEach((entry, i) => {
			const gradient = this.context.createLinearGradient(0, i, this.size, i);
			entry.renderToCanvasGradient(gradient, entry);
			this.context.fillStyle = gradient;
			this.context.fillRect(0, i, this.size, 1);
		});
		if (recycledTexture) recycledTexture.source.data = this.context.getImageData(0, 0, this.size, this.size);
		const texture$1 = recycledTexture ?? new DataTexture(this.context.getImageData(0, 0, this.size, this.size).data, this.size, this.size, RGBAFormat, UnsignedByteType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping);
		texture$1.needsUpdate = true;
		return texture$1;
	}
};
function clampedMapLinear(v, minIn, maxIn, minOut, maxOut) {
	return MathUtils.mapLinear(MathUtils.clamp(v, minIn, maxIn), minIn, maxIn, minOut, maxOut);
}
function GradientTresColorRenderToCanvasGradient(g, entry) {
	return normalizeColorGradient(entry.data).forEach(([offset, color]) => g.addColorStop(offset, `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`));
}
function GradientScalarRenderToCanvasGradient(g, entry) {
	return normalizeScalarGradient(entry.data).forEach(([offset, scalar]) => {
		g.addColorStop(offset, `rgb(${clampedMapLinear(scalar, entry.valueMin, entry.valueMax, 0, 255)}, 0, 0)`);
	});
}
function GradientXyzRenderToCanvasGradient(g, entry) {
	return normalizeFlexibleVector3Gradient(entry.data).forEach(([offset, xyz]) => g.addColorStop(offset, `rgb(${xyz.map((v) => clampedMapLinear(v, entry.valueMin, entry.valueMax, 0, 255))})`));
}

//#endregion
//#region src/core/staging/Sparkles/ShaderDataBuilder.ts
var ShaderDataBuilder = class {
	entries;
	resolution;
	constructor(resolution = 256) {
		this.resolution = resolution;
		this.entries = [];
	}
	withResolution(resolution) {
		this.resolution = resolution;
		return this;
	}
	get add() {
		return new ShaderDataBuilderAdd((entry) => this.onAdd(entry));
	}
	build() {
		return new ShaderData(this.entries, this.resolution);
	}
	onAdd(entry) {
		this.entries.push(entry);
		return new ShaderDataEntryBuilder(entry, this);
	}
};
var ShaderDataEntryBuilder = class {
	entry;
	parent;
	constructor(entry, parent) {
		this.entry = entry;
		this.parent = parent;
	}
	id(s) {
		this.entry.name = s;
		return this;
	}
	range(min, max) {
		this.entry.valueMin = min;
		this.entry.valueMax = max;
		return this;
	}
	suffix(s) {
		this.entry.suffix = s;
		return this;
	}
	canvasGradientRenderer(fn) {
		this.entry.renderToCanvasGradient = fn;
		return this;
	}
	/**
	* Add another entry to the ShaderDataBuilder
	*/
	get add() {
		return this.parent.add;
	}
	/**
	* Finalize the ShaderDataBuilder
	* @returns ShaderData
	*/
	build() {
		return this.parent.build();
	}
};
var ShaderDataBuilderAdd = class {
	onAdd;
	constructor(onAdd) {
		this.onAdd = onAdd;
	}
	GradientTresColor(data) {
		return this.onAdd(new ShaderDataEntryTresColorGradient(data));
	}
	Gradient01(data) {
		return this.onAdd(new ShaderDataEntryScalarGradient(data, "zeroOne", 0, 1));
	}
	GradientScalar(data, min, max) {
		return this.onAdd(new ShaderDataEntryScalarGradient(data, "scalar", min, max));
	}
	GradientXyz(data, min, max) {
		return this.onAdd(new ShaderDataEntryXyzGradient(data, "position", min, max));
	}
};

//#endregion
//#region src/core/staging/Sparkles/useEmptyDataTexture.ts
let texture = null;
function useEmptyDataTexture() {
	if (texture === null) texture = new DataTexture(new Uint8Array([
		0,
		0,
		0,
		0
	]), 1, 1);
	return texture;
}

//#endregion
//#region src/core/staging/Sparkles/component.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$3 = ["object"];
var component_vue_vue_type_script_setup_true_lang_default$1 = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		map: {
			type: [Object, String],
			required: false,
			default: "https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png"
		},
		geometry: {
			type: Object,
			required: false,
			default: void 0
		},
		directionalLight: {
			type: Object,
			required: false,
			default: void 0
		},
		lifetimeSec: {
			type: Number,
			required: false,
			default: .4
		},
		cooldownSec: {
			type: Number,
			required: false,
			default: 2
		},
		normalThreshold: {
			type: Number,
			required: false,
			default: .7
		},
		noiseScale: {
			type: Number,
			required: false,
			default: 3
		},
		scaleNoise: {
			type: Number,
			required: false,
			default: 1
		},
		offsetNoise: {
			type: Number,
			required: false,
			default: .1
		},
		lifetimeNoise: {
			type: Number,
			required: false,
			default: 0
		},
		size: {
			type: Number,
			required: false,
			default: 1
		},
		alpha: {
			type: Number,
			required: false,
			default: 1
		},
		offset: {
			type: Number,
			required: false,
			default: 1
		},
		surfaceDistance: {
			type: Number,
			required: false,
			default: 1
		},
		sequenceColor: {
			type: null,
			required: false,
			default: () => [[.7, "#82dbc5"], [.8, "#fbb03b"]]
		},
		sequenceAlpha: {
			type: [Number, Array],
			required: false,
			default: () => [
				[0, 0],
				[.1, 1],
				[.5, 1],
				[.9, 0]
			]
		},
		sequenceOffset: {
			type: [
				Object,
				Array,
				Number
			],
			required: false,
			default: () => [
				0,
				0,
				0
			]
		},
		sequenceNoise: {
			type: [
				Object,
				Array,
				Number
			],
			required: false,
			default: () => [
				.1,
				.1,
				.1
			]
		},
		sequenceSize: {
			type: [Number, Array],
			required: false,
			default: () => [0, 1]
		},
		sequenceSurfaceDistance: {
			type: [Number, Array],
			required: false,
			default: () => [
				.05,
				.08,
				.1
			]
		},
		mixColor: {
			type: Number,
			required: false,
			default: .5
		},
		mixAlpha: {
			type: Number,
			required: false,
			default: 1
		},
		mixOffset: {
			type: Number,
			required: false,
			default: 1
		},
		mixSize: {
			type: Number,
			required: false,
			default: 0
		},
		mixSurfaceDistance: {
			type: Number,
			required: false,
			default: 1
		},
		mixNoise: {
			type: Number,
			required: false,
			default: 1
		},
		blending: {
			type: null,
			required: false,
			default: AdditiveBlending
		},
		transparent: {
			type: Boolean,
			required: false,
			default: true
		},
		depthWrite: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const version$1 = Number.parseInt(REVISION.replace(/\D+/g, ""));
		const refs = toRefs(props);
		const map = typeof props.map === "string" ? useEmptyDataTexture() : props.map;
		const { texture: infoTexture, yFor } = new ShaderDataBuilder(256).add.GradientTresColor(refs.sequenceColor).id("sequenceColor").add.Gradient01(refs.sequenceAlpha).id("sequenceAlpha").add.Gradient01(refs.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(refs.sequenceSize).id("sequenceSize").add.GradientXyz(refs.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(refs.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture();
		const mat = new ShaderMaterial({
			blending: props.blending,
			transparent: props.transparent,
			depthWrite: props.depthWrite,
			uniforms: {
				uMap: new Uniform(map),
				uPixelRatio: new Uniform(1),
				uNormal: new Uniform(Object3D.DEFAULT_UP),
				uNormalThreshold: new Uniform(props.normalThreshold),
				uTime: new Uniform(0),
				uCooldownRatio: new Uniform(1),
				uSize: new Uniform(props.size),
				uAlpha: new Uniform(props.alpha),
				uOffset: new Uniform(props.offset),
				uSurfaceDistance: new Uniform(props.surfaceDistance),
				uNoiseScale: new Uniform(props.noiseScale),
				uScaleNoise: new Uniform(props.scaleNoise),
				uOffsetNoise: new Uniform(props.offsetNoise),
				uLifetimeNoise: new Uniform(props.lifetimeNoise),
				uMixColor: new Uniform(props.mixColor),
				uMixAlpha: new Uniform(props.mixAlpha),
				uMixOffset: new Uniform(props.mixOffset),
				uMixSize: new Uniform(props.mixSize),
				uMixSurfaceDistance: new Uniform(props.mixSurfaceDistance),
				uMixNoise: new Uniform(props.mixNoise),
				uInfoTexture: new Uniform(infoTexture.value)
			},
			vertexShader: `
    uniform float uPixelRatio;
    uniform vec3 uNormal;
    uniform float uNormalThreshold;
    uniform float uTime;
    uniform float uCooldownRatio;
    uniform float uSize;
    uniform float uAlpha;
    uniform float uOffset;
    uniform float uSurfaceDistance;
    uniform float uNoiseScale;
    uniform float uScaleNoise;
    uniform float uOffsetNoise;
    uniform float uLifetimeNoise;
    uniform float uMixColor;
    uniform float uMixAlpha;
    uniform float uMixOffset;
    uniform float uMixSize;
    uniform float uMixSurfaceDistance;
    uniform float uMixNoise;
    uniform sampler2D uInfoTexture;

    varying vec4 vColor;

    void main() {
      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;
      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);
      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);

      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + 
      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;

      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
      float surfaceDistance = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixSurfaceDistance),
        ${yFor.sequenceSurfaceDistance})).x * uSurfaceDistance;

      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
      vec3 noise = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixNoise),
        ${yFor.sequenceNoise})).xyz;
      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixOffset),
        ${yFor.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;

      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;

      gl_PointSize = 2.
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${yFor.sequenceSize})).x
      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;

      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }

      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${yFor.sequenceColor}))
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${yFor.sequenceAlpha})).x * uAlpha;
    }`,
			fragmentShader: `
    varying vec4 vColor;

    uniform sampler2D uMap;
    uniform sampler2D uInfoTexture;

    void main() {
      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
      #include <tonemapping_fragment>
      #include <${version$1 >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }`
		});
		const sparkles = new Points(void 0, mat);
		__expose({ instance: sparkles });
		const u = mat.uniforms;
		const NOW = { immediate: true };
		[
			[u.uPixelRatio, useTresContext().sizes.aspectRatio],
			[u.uSize, refs.size],
			[u.uNormalThreshold, refs.normalThreshold],
			[u.uAlpha, refs.alpha],
			[u.uOffset, refs.offset],
			[u.uOffsetNoise, refs.offsetNoise],
			[u.uMixColor, refs.mixColor],
			[u.uMixAlpha, refs.mixAlpha],
			[u.uMixOffset, refs.mixOffset],
			[u.uMixSize, refs.mixSize],
			[u.uMixSurfaceDistance, refs.mixSurfaceDistance],
			[u.uMixNoise, refs.mixNoise],
			[u.uInfoTexture, infoTexture]
		].forEach(([uniform, ref$1]) => watch(ref$1, () => {
			uniform.value = ref$1.value;
		}, NOW));
		watch([refs.noiseScale, refs.lifetimeSec], () => {
			u.uNoiseScale.value = refs.noiseScale.value * refs.lifetimeSec.value;
		}, NOW);
		watch([refs.lifetimeSec, refs.cooldownSec], () => {
			u.uCooldownRatio.value = refs.cooldownSec.value / refs.lifetimeSec.value;
		}, NOW);
		watch(refs.map, () => {
			if (typeof refs.map.value === "string") {
				const { state: texture$1 } = useTexture(refs.map.value);
				mat.uniforms.uMap.value = texture$1;
			} else mat.uniforms.uMap.value = refs.map.value;
		});
		const rotation = new Quaternion();
		const normal = new Vector3();
		useLoop().onBeforeRender(({ elapsed }) => {
			sparkles.getWorldQuaternion(rotation);
			normal.copy(props.directionalLight ? props.directionalLight.position : Object3D.DEFAULT_UP).normalize();
			normal.applyQuaternion(rotation.invert());
			mat.uniforms.uNormal.value = normal;
			mat.uniforms.uTime.value = elapsed / (props.cooldownSec + props.lifetimeSec);
		});
		function isObject3D(o) {
			return o && "isObject3D" in o;
		}
		function isBufferGeometry(o) {
			return o && "isBufferGeometry" in o;
		}
		onMounted(() => {
			if (props.geometry) {
				if (isBufferGeometry(props.geometry)) sparkles.geometry.copy(props.geometry);
				else if (isObject3D(props.geometry) && "geometry" in props.geometry && isBufferGeometry(props.geometry.geometry)) sparkles.geometry.copy(props.geometry.geometry);
			} else if (isObject3D(sparkles.parent) && "geometry" in sparkles.parent && isBufferGeometry(sparkles.parent.geometry)) sparkles.geometry.copy(sparkles.parent.geometry);
			else sparkles.geometry = new IcosahedronGeometry(1, 16);
			if (typeof props.map === "string") {
				const { state: texture$1 } = useTexture(props.map);
				mat.uniforms.uMap.value = texture$1;
			}
		});
		onUnmounted(() => {
			mat.uniforms.uMap.value?.dispose();
			infoTexture.value.dispose();
			mat.dispose();
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("primitive", { object: unref(sparkles) }, null, 8, _hoisted_1$3);
		};
	}
});

//#endregion
//#region src/core/staging/Sparkles/component.vue
var component_default$16 = component_vue_vue_type_script_setup_true_lang_default$1;

//#endregion
//#region src/core/staging/Stage.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$2 = { key: 0 };
const _hoisted_2$2 = ["intensity"];
const _hoisted_3$1 = [
	"position",
	"intensity",
	"castShadow",
	"shadow-bias",
	"shadow-normalBias",
	"shadow-mapSize-x",
	"shadow-mapSize-y"
];
const _hoisted_4$1 = ["position", "intensity"];
const _hoisted_5 = ["position"];
var Stage_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Stage",
	props: {
		lighting: {
			type: [
				null,
				Boolean,
				String,
				Object
			],
			required: false,
			skipCheck: true,
			default: "rembrandt"
		},
		shadows: {
			type: [
				Boolean,
				String,
				Object
			],
			required: false,
			default: "contact"
		},
		adjustCamera: {
			type: [Boolean, Number],
			required: false,
			default: true
		},
		environment: {
			type: null,
			required: false,
			default: () => ({ preset: "city" })
		},
		intensity: {
			type: Number,
			required: false,
			default: .5
		},
		align: {
			type: Object,
			required: false
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const lightingPresets = {
			rembrandt: {
				main: [
					1,
					2,
					1
				],
				fill: [
					-2,
					-.5,
					-2
				]
			},
			portrait: {
				main: [
					-1,
					2,
					.5
				],
				fill: [
					-1,
					.5,
					-1.5
				]
			},
			upfront: {
				main: [
					0,
					2,
					1
				],
				fill: [
					-1,
					.5,
					-1.5
				]
			},
			soft: {
				main: [
					-2,
					4,
					4
				],
				fill: [
					-1,
					.5,
					-1.5
				]
			}
		};
		const radius = ref(2);
		const height = ref(0);
		const stageRef = shallowRef();
		const boundsRef = shallowRef();
		const alignRef = shallowRef();
		const accumulativeShadowsRef = shallowRef();
		const debouncedLookAt = useDebounceFn(() => {
			if (boundsRef.value?.instance) boundsRef.value.instance.lookAt(boundsRef.value.instance);
		}, 500, { maxWait: 2e3 });
		watch(() => [props.adjustCamera, radius.value], () => {
			alignRef.value?.update();
			if (props.adjustCamera !== false && boundsRef.value) {
				boundsRef.value.instance.offset = typeof props.adjustCamera === "boolean" ? .3 : props.adjustCamera;
				debouncedLookAt();
			}
		});
		watch(() => [props.shadows], () => {
			accumulativeShadowsRef.value?.update();
		});
		const lightingPresetComputed = computed(() => {
			let preset = lightingPresets.rembrandt;
			if (typeof props.lighting === "string") preset = lightingPresets[props.lighting];
			else if (props.lighting) preset = props.lighting;
			return preset;
		});
		const lightingMainComputed = computed(() => {
			return lightingPresetComputed.value.main.map((v) => v * radius.value);
		});
		const lightingFillComputed = computed(() => {
			return lightingPresetComputed.value.fill.map((v) => v * radius.value);
		});
		const contactShadowsComputed = computed(() => {
			if (props.shadows === true || props.shadows === "contact") return { type: "contact" };
			else if (typeof props.shadows === "object" && props.shadows.type === "contact") return props.shadows;
			else return null;
		});
		const accumulativeShadowsComputed = computed(() => {
			if (props.shadows === "accumulative") return { type: "accumulative" };
			else if (typeof props.shadows === "object" && props.shadows.type === "accumulative") return props.shadows;
			else return null;
		});
		const environmentComputed = computed(() => {
			if (props.environment === null) return null;
			else if (!props.environment) return { preset: "city" };
			else if (typeof props.environment === "string") return { preset: props.environment };
			else return props.environment;
		});
		const onAlignChange = (alignProps) => {
			radius.value = alignProps.boundingSphere.radius;
			if (props.adjustCamera !== false) debouncedLookAt();
		};
		__expose({
			instance: stageRef,
			update: () => {}
		});
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresGroup", {
				ref_key: "stageRef",
				ref: stageRef
			}, [
				props.lighting ? (openBlock(), createElementBlock("TresGroup", _hoisted_1$2, [
					createElementVNode("TresAmbientLight", { intensity: __props.intensity / 3 }, null, 8, _hoisted_2$2),
					createElementVNode("TresSpotLight", {
						penumbra: 1,
						position: lightingMainComputed.value,
						intensity: __props.intensity * 2,
						castShadow: !!__props.shadows,
						"shadow-bias": __props.shadows?.bias ?? 0,
						"shadow-normalBias": __props.shadows?.normalBias ?? 0,
						"shadow-mapSize-x": __props.shadows?.size ?? 1024,
						"shadow-mapSize-y": __props.shadows?.size ?? 1024
					}, null, 8, _hoisted_3$1),
					createElementVNode("TresPointLight", {
						position: lightingFillComputed.value,
						intensity: __props.intensity
					}, null, 8, _hoisted_4$1)
				])) : createCommentVNode("v-if", true),
				createVNode(unref(component_default$2), mergeProps({
					ref_key: "boundsRef",
					ref: boundsRef,
					clip: !!__props.adjustCamera,
					offset: typeof props.adjustCamera === "boolean" ? .3 : props.adjustCamera,
					"use-mounted": "",
					"use-resize": ""
				}, props), {
					default: withCtx(() => [createVNode(unref(Align_default), mergeProps({
						ref_key: "alignRef",
						ref: alignRef
					}, __props.align, { onChange: onAlignChange }), {
						default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
						_: 3
					}, 16)]),
					_: 3
				}, 16, ["clip", "offset"]),
				createElementVNode("TresGroup", { position: [
					0,
					-height.value / 2 - (__props.shadows?.offset ?? 0) / 2,
					0
				] }, [
					contactShadowsComputed.value ? (openBlock(), createBlock(unref(ContactShadows_default), mergeProps({
						key: 0,
						scale: radius.value * 4,
						far: radius.value,
						blur: 2
					}, contactShadowsComputed.value), null, 16, ["scale", "far"])) : createCommentVNode("v-if", true),
					accumulativeShadowsComputed.value ? (openBlock(), createBlock(unref(component_default), mergeProps({
						key: 1,
						ref_key: "accumulativeShadowsRef",
						ref: accumulativeShadowsRef,
						frames: 100,
						"alpha-test": .5,
						"tone-mapped": true,
						scale: radius.value * 4
					}, accumulativeShadowsComputed.value), {
						default: withCtx(() => [createVNode(unref(component_default$14), mergeProps({
							position: lightingMainComputed.value,
							count: accumulativeShadowsComputed.value.count ?? 8,
							radius: accumulativeShadowsComputed.value.radius ?? radius.value,
							intensity: accumulativeShadowsComputed.value.intensity ?? 1.5,
							ambient: accumulativeShadowsComputed.value.ambient ?? .5,
							size: radius.value * 4,
							bias: accumulativeShadowsComputed.value.bias ?? 0,
							"map-size": accumulativeShadowsComputed.value.size ?? 1024
						}, accumulativeShadowsComputed.value), null, 16, [
							"position",
							"count",
							"radius",
							"intensity",
							"ambient",
							"size",
							"bias",
							"map-size"
						])]),
						_: 1
					}, 16, ["scale"])) : createCommentVNode("v-if", true),
					(openBlock(), createBlock(Suspense, null, {
						default: withCtx(() => [environmentComputed.value ? (openBlock(), createBlock(unref(component_default$4), normalizeProps(mergeProps({ key: 0 }, environmentComputed.value)), null, 16)) : createCommentVNode("v-if", true)]),
						_: 1
					}))
				], 8, _hoisted_5)
			], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Stage.vue
var Stage_default = Stage_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/Stars.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1$1 = ["position", "a-scale"];
const _hoisted_2$1 = [
	"size",
	"size-attenuation",
	"transparent",
	"alpha-test",
	"alpha-map"
];
var Stars_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "Stars",
	props: {
		size: {
			type: Number,
			required: false,
			default: .1
		},
		sizeAttenuation: {
			type: Boolean,
			required: false,
			default: true
		},
		transparent: {
			type: Boolean,
			required: false,
			default: true
		},
		alphaTest: {
			type: Number,
			required: false,
			default: .01
		},
		count: {
			type: Number,
			required: false,
			default: 5e3
		},
		depth: {
			type: Number,
			required: false,
			default: 50
		},
		radius: {
			type: Number,
			required: false,
			default: 100
		},
		alphaMap: {
			type: null,
			required: false,
			default: null
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const position = ref();
		const scale = ref();
		const { radius, depth, count, size, sizeAttenuation, transparent, alphaMap, alphaTest } = toRefs(props);
		const { invalidate } = useTres();
		watch(props, () => {
			invalidate();
		});
		const setStars = () => {
			let circle$1 = radius.value + depth.value;
			const increment = computed(() => depth.value / count.value);
			const positionArray = [];
			const scaleArray = Array.from({ length: count.value }, () => (.5 + .5 * Math.random()) * 4);
			const generateStars = (circle$2) => {
				return new Vector3().setFromSpherical(new Spherical(circle$2, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
			};
			for (let i = 0; i < count.value; i++) {
				circle$1 -= increment.value * Math.random();
				positionArray.push(...generateStars(circle$1));
			}
			position.value = new Float32Array(positionArray);
			scale.value = new Float32Array(scaleArray);
		};
		watchEffect(() => {
			setStars();
		});
		const starsRef = shallowRef();
		__expose({ instance: starsRef });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresPoints", {
				ref_key: "starsRef",
				ref: starsRef
			}, [createElementVNode("TresBufferGeometry", {
				position: [position.value, 3],
				"a-scale": [scale.value, 1]
			}, null, 8, _hoisted_1$1), createElementVNode("TresPointsMaterial", {
				size: unref(size),
				"size-attenuation": unref(sizeAttenuation),
				transparent: unref(transparent),
				"alpha-test": unref(alphaTest),
				"alpha-map": unref(alphaMap)
			}, null, 8, _hoisted_2$1)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/Stars.vue
var Stars_default = Stars_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/useEnvironment/EnvironmentScene.ts
var EnvironmentScene = class extends Object3D {
	virtualScene = null;
	constructor() {
		super();
		this.virtualScene = new Scene();
	}
	add(...object) {
		for (const obj of object) this.virtualScene.add(obj);
		return this;
	}
	dispose() {
		this.virtualScene.traverse((object) => {
			if (object instanceof Mesh) {
				object.geometry.dispose();
				object.material.dispose();
				if (object.material.map) object.material.map.dispose();
				this.virtualScene.remove(object);
			}
		});
		this.virtualScene = null;
	}
};
var EnvironmentScene_default = EnvironmentScene;

//#endregion
//#region src/core/staging/useEnvironment/component.vue?vue&type=script&setup=true&lang.ts
var component_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "component",
	props: {
		background: {
			type: [Boolean, String],
			required: false,
			default: false
		},
		blur: {
			type: Number,
			required: false,
			default: 0
		},
		files: {
			type: [String, Array],
			required: false,
			default: () => []
		},
		path: {
			type: String,
			required: false,
			default: ""
		},
		preset: {
			type: null,
			required: false,
			default: void 0
		},
		resolution: {
			type: Number,
			required: false,
			default: 256
		},
		near: {
			type: Number,
			required: false,
			default: 1
		},
		far: {
			type: Number,
			required: false,
			default: 1e3
		},
		frames: {
			type: Number,
			required: false,
			default: Number.POSITIVE_INFINITY
		},
		backgroundIntensity: {
			type: Number,
			required: false,
			default: 1
		},
		backgroundRotation: {
			type: [
				Object,
				Array,
				Number
			],
			required: false
		},
		environmentIntensity: {
			type: Number,
			required: false,
			default: 1
		},
		environmentRotation: {
			type: [
				Object,
				Array,
				Number
			],
			required: false
		},
		syncMaterials: {
			type: Boolean,
			required: false
		}
	},
	async setup(__props, { expose: __expose }) {
		let __temp, __restore;
		const props = __props;
		const texture$1 = ref(null);
		__expose({ texture: texture$1 });
		const { extend: extend$1, renderer, scene } = useTresContext();
		extend$1({ EnvironmentScene: EnvironmentScene_default });
		let slots = null;
		const fbo = ref(null);
		let cubeCamera = null;
		const environmentScene = ref(null);
		const useEnvironmentTexture = ([__temp, __restore] = withAsyncContext(() => useEnvironment(props, fbo)), __temp = await __temp, __restore(), __temp);
		const { onBeforeRender } = useLoop();
		let count = 1;
		onBeforeRender(() => {
			if (cubeCamera && environmentScene.value && fbo.value) {
				if (props.frames === Number.POSITIVE_INFINITY || count < props.frames) {
					const autoClear = renderer.instance.autoClear;
					renderer.instance.autoClear = true;
					const rawScene = toRaw(environmentScene.value).virtualScene;
					cubeCamera.update(renderer.instance, rawScene);
					renderer.instance.autoClear = autoClear;
					count++;
				}
			}
		}, -1);
		watch([useEnvironmentTexture, environmentScene], ([texture$2, scene$1]) => {
			if (texture$2 && scene$1?.virtualScene) {
				const rawScene = toRaw(scene$1).virtualScene;
				let envMesh = rawScene.children.find((child) => child instanceof Mesh && child.userData.isEnvironment);
				if (!envMesh) {
					envMesh = new Mesh(new BoxGeometry(1, 1, 1), new MeshBasicMaterial({ side: BackSide }));
					envMesh.userData.isEnvironment = true;
					rawScene.add(envMesh);
				}
				rawScene.background = texture$2;
				rawScene.backgroundBlurriness = props.blur;
			}
		}, { immediate: true });
		const setTextureEnvAndBG = (fbo$1) => {
			if (fbo$1 && slots?.length) {
				scene.value.environment = fbo$1.texture;
				if (props.background) scene.value.background = fbo$1.texture;
			} else if (useEnvironmentTexture.value) {
				scene.value.environment = useEnvironmentTexture.value;
				if (props.background) scene.value.background = useEnvironmentTexture.value;
			}
		};
		watch(useEnvironmentTexture, () => {
			if (fbo.value) setTextureEnvAndBG(fbo.value);
		}, {
			immediate: true,
			deep: true
		});
		watch(() => useSlots().default, (value) => {
			if (value) {
				slots = value();
				if (Array.isArray(slots) && slots.length > 0) {
					extend$1({ EnvironmentScene: EnvironmentScene_default });
					fbo.value = new WebGLCubeRenderTarget(props.resolution);
					fbo.value.texture.type = HalfFloatType;
					cubeCamera = new CubeCamera(props.near, props.far, fbo.value);
					setTextureEnvAndBG(fbo.value);
					return;
				}
			}
			fbo.value?.dispose();
			fbo.value = null;
			setTextureEnvAndBG();
		}, {
			immediate: true,
			deep: true
		});
		texture$1.value = useEnvironmentTexture.value;
		onUnmounted(() => {
			environmentScene.value?.dispose();
			fbo.value?.dispose();
		});
		return (_ctx, _cache) => {
			return fbo.value ? (openBlock(), createElementBlock("TresEnvironmentScene", {
				key: 0,
				ref_key: "environmentScene",
				ref: environmentScene
			}, [renderSlot(_ctx.$slots, "default")], 512)) : createCommentVNode("v-if", true);
		};
	}
});

//#endregion
//#region src/core/staging/useEnvironment/component.vue
var component_default$4 = component_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/core/staging/useEnvironment/lightformer/index.vue?vue&type=script&setup=true&lang.ts
const _hoisted_1 = {
	key: 0,
	args: [
		0,
		1,
		64
	]
};
const _hoisted_2 = {
	key: 1,
	args: [
		.5,
		1,
		64
	]
};
const _hoisted_3 = { key: 2 };
const _hoisted_4 = [
	"tone-mapped",
	"map",
	"side",
	"color"
];
var index_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
	__name: "index",
	props: {
		args: {
			type: Array,
			required: false,
			default: null
		},
		form: {
			type: null,
			required: false,
			default: "rect"
		},
		toneMapped: {
			type: Boolean,
			required: false,
			default: false
		},
		map: {
			type: Object,
			required: false,
			default: null
		},
		intensity: {
			type: Number,
			required: false,
			default: 1
		},
		color: {
			type: null,
			required: false,
			default: new Color(16777215)
		}
	},
	setup(__props, { expose: __expose }) {
		const props = __props;
		const material = ref();
		const mesh = ref();
		watchEffect(() => {
			if (material.value) {
				material.value.color.copy(new Color(props.color));
				material.value.color.multiplyScalar(props.intensity);
				material.value.needsUpdate = true;
			}
		});
		__expose({ mesh });
		return (_ctx, _cache) => {
			return openBlock(), createElementBlock("TresMesh", {
				ref_key: "mesh",
				ref: mesh
			}, [__props.form === "circle" ? (openBlock(), createElementBlock("TresRingGeometry", _hoisted_1)) : __props.form === "ring" ? (openBlock(), createElementBlock("TresRingGeometry", _hoisted_2)) : __props.form === "rect" ? (openBlock(), createElementBlock("TresPlaneGeometry", _hoisted_3)) : (openBlock(), createBlock(props.form, {
				key: 3,
				args: __props.args
			}, null, 8, ["args"])), createElementVNode("TresMeshBasicMaterial", {
				ref_key: "material",
				ref: material,
				"tone-mapped": __props.toneMapped,
				map: __props.map,
				side: unref(DoubleSide),
				color: __props.color
			}, null, 8, _hoisted_4)], 512);
		};
	}
});

//#endregion
//#region src/core/staging/useEnvironment/lightformer/index.vue
var lightformer_default = index_vue_vue_type_script_setup_true_lang_default;

//#endregion
//#region src/utils/index.ts
/**
* Update the function signature to explicitly specify the type of the props parameter
*
* @export
* @template T
* @template K
* @param {T} obj
* @param {K[]} props
* @return {*}  {Pick<T, K>}
*/
function pick(obj, props) {
	const pickedProperties = {};
	for (const prop of props) if (Object.prototype.hasOwnProperty.call(obj, prop)) pickedProperties[prop] = obj[prop];
	return pickedProperties;
}
/**
* Check if the object has a setter for the given property
*
* @export
* @param {*} obj
* @param {string} prop
* @return {*}  {boolean}
*/
function hasSetter(obj, prop) {
	return obj[`set${prop[0].toUpperCase()}${prop.slice(1)}`] !== void 0;
}
function extractBindingPosition(binding) {
	let observer = binding.value;
	if (binding.value && binding.value?.value?.isMesh) observer = binding.value.value.position;
	if (Array.isArray(binding.value)) observer = new Vector3(...observer);
	return observer;
}

//#endregion
export { component_default as AccumulativeShadows, Align_default as Align, component_default$1 as AnimatedSprite, Backdrop_default as Backdrop, BakeShadows, BaseCameraControls, Billboard_default as Billboard, component_default$2 as Bounds, Box_default as Box, CameraControls_default as CameraControls, CameraShake_default as CameraShake, CatmullRomCurve3_default as CatmullRomCurve3, Circle_default as Circle, CircleShadow_default as CircleShadow, Cone_default as Cone, ContactShadows_default as ContactShadows, component_default$3 as CubeCamera, CubicBezierLine_default as CubicBezierLine, customShaderMaterial_default as CustomShaderMaterial, Cylinder_default as Cylinder, Dodecahedron_default as Dodecahedron, Edges_default as Edges, component_default$4 as Environment, component_default$5 as FBXModel, component_default$6 as Fbo, Fit_default as Fit, component_default$7 as GLTFModel, GlobalAudio, GradientTexture_default as GradientTexture, Grid_default as Grid, component_default$8 as Helper, holographicMaterial_default as HolographicMaterial, HTML_default as Html, Icosahedron_default as Icosahedron, component_default$9 as Image, KeyboardControls_default as KeyboardControls, LOD_default as LOD, component_default$10 as Lensflare, Levioso_default as Levioso, lightformer_default as Lightformer, Line2_default as Line2, MapControls_default as MapControls, MarchingCube_default as MarchingCube, MarchingCubes_default as MarchingCubes, MarchingPlane_default as MarchingPlane, component_default$11 as Mask, meshDiscardMaterial_default as MeshDiscardMaterial, meshGlassMaterial_default as MeshGlassMaterial, meshReflectionMaterial_default as MeshReflectionMaterial, meshWobbleMaterial_default as MeshWobbleMaterial, MouseParallax_default as MouseParallax, Ocean_default as Ocean, Octahedron_default as Octahedron, OrbitControls_default as OrbitControls, component_default$12 as Outline, Plane_default as Plane, component_default$13 as PointMaterial, PointerLockControls_default as PointerLockControls, PositionalAudio_default as PositionalAudio, Precipitation_default as Precipitation, QuadraticBezierLine_default as QuadraticBezierLine, component_default$14 as RandomizedLights, Reflector_default as Reflector, Ring_default as Ring, RoundedBox_default as RoundedBox, component_default$15 as Sampler, ScreenQuad_default as ScreenQuad, ScreenSizer_default as ScreenSizer, ScreenSpace_default as ScreenSpace, ScrollControls_default as ScrollControls, Sky_default as Sky, Smoke_default as Smoke, SoftShadows_default as SoftShadows, component_default$16 as Sparkles, Sphere_default as Sphere, Stage_default as Stage, Stars_default as Stars, Stats, StatsGl, Superformula_default as Superformula, Tetrahedron_default as Tetrahedron, Text3D_default as Text3D, Torus_default as Torus, TorusKnot_default as TorusKnot, TransformControls_default as TransformControls, Tube_default as Tube, component_default$17 as UseSVG, component_default$18 as UseTexture, extractBindingPosition, hasSetter, pick, useAnimations, useEnvironment, useFBO, useFBX, useGLTF, useGLTFExporter, useIntersect, useMask, useProgress, useSVG, useSurfaceSampler, useTexture, useTextures, useVideoTexture };